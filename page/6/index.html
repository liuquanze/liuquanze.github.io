<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-105-从前序与中序遍历序列构造二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html" class="article-date">
  <time class="dt-published" datetime="2022-10-03T12:52:58.000Z" itemprop="datePublished">2022-10-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html">105. 从前序与中序遍历序列构造二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="105">
<li>从前序与中序遍历序列构造二叉树</li>
</ol>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: preorder &#x3D; [-1], inorder &#x3D; [-1]
输出: [-1]</code></pre>

<p>提示：</p>
<p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    Map&lt;Integer, Integer&gt; map;
    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;
        map &#x3D; new HashMap&lt;&gt;();
        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置
            map.put(inorder[i], i);
        &#125;

        return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);  &#x2F;&#x2F; 前闭后开
    &#125;

    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) &#123;
        &#x2F;&#x2F; 参数里的范围都是前闭后开
        if (preBegin &gt;&#x3D; preEnd || inBegin &gt;&#x3D; inEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树
            return null;
        &#125;
        int rootIndex &#x3D; map.get(preorder[preBegin]);  &#x2F;&#x2F; 找到前序遍历的第一个元素在中序遍历中的位置
        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点
        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定前序数列的个数
        root.left &#x3D; findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,  
                            inorder, inBegin, rootIndex);
        root.right &#x3D; findNode(preorder, preBegin + lenOfLeft + 1, preEnd,
                            inorder, rootIndex + 1, inEnd);

        return root;
    &#125;
&#125;</code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html" data-id="cldlogw8w000ka8ykfvj4d9jt" data-title="105. 从前序与中序遍历序列构造二叉树" class="article-share-link">Share</a>
      
        <a href="http://example.com/post/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-112-路径综合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/112-%E8%B7%AF%E5%BE%84%E7%BB%BC%E5%90%88.html" class="article-date">
  <time class="dt-published" datetime="2022-10-01T15:19:03.000Z" itemprop="datePublished">2022-10-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/112-%E8%B7%AF%E5%BE%84%E7%BB%BC%E5%90%88.html">112.路径综合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="112-路径综合"><a href="#112-路径综合" class="headerlink" title="112.路径综合"></a>112.路径综合</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="112">
<li>路径总和</li>
</ol>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --&gt; 2): 和为 3
(1 --&gt; 3): 和为 4
不存在 sum &#x3D; 5 的根节点到叶子节点的路径。</code></pre>

<p>example 3:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [], targetSum &#x3D; 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。</code></pre>

<p>提示：</p>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum">https://leetcode.cn/problems/path-sum</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    &#x2F;&#x2F;递归，传入三个参数，第一个是当前节点，一个是从根节点到当前节点的父节点路径上的val之和，targetNum是目标路径上的节点val之和
    public boolean traverse(TreeNode node,int count,int targetSum)&#123;
        &#x2F;&#x2F;加上当前节点的val，表示根节点到当前节点这条路径上的所有节点的val之和
        count+&#x3D;node.val;
        &#x2F;&#x2F;如果当前节点是叶子节点，则判断当前路径节点的val之和是否等于目标路径的节点val之和，如果等于，则返回true，否则返回false
        if(node.left&#x3D;&#x3D;null&amp;&amp;node.right&#x3D;&#x3D;null)&#123;
            if(count&#x3D;&#x3D;targetSum)&#123;
                return true;
            &#125;else&#123;
                return false;
            &#125;
        &#125;
        &#x2F;&#x2F;如果当前节点不是叶子节点，则分别判断左右子树中是否存在目标路径，下面两个变量分别存储左右子树是否存在目标路径
        boolean left&#x3D;false;
        boolean right&#x3D;false;
        &#x2F;&#x2F;若左子树非空，则对左子树进行递归
        if(node.left!&#x3D;null)&#123;
            left&#x3D;traverse(node.left,count,targetSum);
        &#125;
        &#x2F;&#x2F;对右子树进行递归
        if(node.right!&#x3D;null)&#123;
            right&#x3D;traverse(node.right,count,targetSum);
        &#125;
        &#x2F;&#x2F;当左子树或者右子树中存在一条目标路径则表示该树存在目标路径，这里使用||
        return left||right;

    &#125;

    public boolean hasPathSum(TreeNode root, int targetSum) &#123;
        if(root&#x3D;&#x3D;null)
            return false;
        return traverse(root,0,targetSum);
    &#125;
&#125;</code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/112-%E8%B7%AF%E5%BE%84%E7%BB%BC%E5%90%88.html" data-id="cldlogw920012a8ykex4id0ja" data-title="112.路径综合" class="article-share-link">Share</a>
      
        <a href="http://example.com/post/112-%E8%B7%AF%E5%BE%84%E7%BB%BC%E5%90%88.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-513-找树左下角的值" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html" class="article-date">
  <time class="dt-published" datetime="2022-09-30T15:03:56.000Z" itemprop="datePublished">2022-09-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html">513.找树左下角的值</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="513">
<li>找树左下角的值</li>
</ol>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p>example 1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: root &#x3D; [2,1,3]
输出: 1</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7</code></pre>

<p>提示：</p>
<ul>
<li>二叉树的节点个数的范围是 <code>[1,104]</code></li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<p>题目来源：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public int findBottomLeftValue(TreeNode root) &#123;
        if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)&#123;
            return root.val;
        &#125;
        int[] deepest&#x3D;new int[2];
        
        deepest[0]&#x3D;0;
        deepest[1]&#x3D;0;
        findAllLeftLeaf(root,deepest,1);
        return deepest[1];
    &#125;
    public void findAllLeftLeaf(TreeNode root,int[] deepest,int depth)&#123;
        if(root&#x3D;&#x3D;null)
            return ;
        if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)
            return ;
        if(root.left!&#x3D;null&amp;&amp;root.left.left&#x3D;&#x3D;null&amp;&amp;root.left.right&#x3D;&#x3D;null)&#123;
            &#x2F;&#x2F;若深度更深
            if(depth+1&gt;deepest[0])&#123;
                deepest[0]&#x3D;depth+1;
                deepest[1]&#x3D;root.left.val;
            &#125;
        &#125;
        findAllLeftLeaf(root.left,deepest,depth+1);
        findAllLeftLeaf(root.right,deepest,depth+1);

            
    &#125;
&#125;</code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html" data-id="cldlogw9w005ea8ykbham4dpx" data-title="513.找树左下角的值" class="article-share-link">Share</a>
      
        <a href="http://example.com/post/513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-404-左叶子之和" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html" class="article-date">
  <time class="dt-published" datetime="2022-09-30T14:44:06.000Z" itemprop="datePublished">2022-09-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html">404.左叶子之和</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="404">
<li>左叶子之和</li>
</ol>
<p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p>
<p>example 1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: root &#x3D; [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: root &#x3D; [1]
输出: 0</code></pre>

<p>提示：</p>
<ul>
<li>节点数在 <code>[1, 1000]</code> 范围内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves">https://leetcode.cn/problems/sum-of-left-leaves</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public int sumOfLeftLeaves(TreeNode root) &#123;
        &#x2F;&#x2F;若当前节点为空，则返回0
        if(root&#x3D;&#x3D;null)
            return 0;
        &#x2F;&#x2F;若当前节点为叶子节点，则返回0
        if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)
            return 0;
        &#x2F;&#x2F;记录左子树的所有叶子节点的值
        int leftValue&#x3D;0;
        &#x2F;&#x2F;如果左孩子节点就是叶子节点，则leftValue就是左孩子节点的值
        if(root.left!&#x3D;null&amp;&amp;root.left.left&#x3D;&#x3D;null&amp;&amp;root.left.right&#x3D;&#x3D;null)
            leftValue&#x3D;root.left.val;
        &#x2F;&#x2F;返回当前节点左子树和右子树的所有左叶子节点的值之和
        return leftValue+sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right);
    &#125;
&#125;</code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html" data-id="cldlogw9m0044a8ykg72jcdnr" data-title="404.左叶子之和" class="article-share-link">Share</a>
      
        <a href="http://example.com/post/404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-257-二叉树的所有路径" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html" class="article-date">
  <time class="dt-published" datetime="2022-09-29T13:48:25.000Z" itemprop="datePublished">2022-09-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">257.二叉树的所有路径</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="257">
<li>二叉树的所有路径</li>
</ol>
<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [1,2,3,null,5]
输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [1]
输出：[&quot;1&quot;]</code></pre>

<p>提示：</p>
<ul>
<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;

    &#x2F;&#x2F;递归+回溯的方法
    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;
        &#x2F;&#x2F;创建结果列表，列表元素是字符串，字符串表示的是路径
        List&lt;String&gt; result&#x3D;new ArrayList&lt;&gt;();
        if(root&#x3D;&#x3D;null)
            return result;
        &#x2F;&#x2F;用于存储路径，列表元素是整型变量，变量表示的是每一个节点的值
        List&lt;Integer&gt; paths&#x3D;new ArrayList&lt;&gt;();
        &#x2F;&#x2F;进行递归和回溯
        traverse(root,paths,result);
        &#x2F;&#x2F;返回搜索的路径结果
        return result;
    &#125;

    public void traverse(TreeNode node,List&lt;Integer&gt; paths,List&lt;String&gt; result)&#123;
        &#x2F;&#x2F;将该节点加入路径
        paths.add(node.val);

        &#x2F;&#x2F;判断是否为叶子节点，如果是叶子节点，则将paths列表转化为路径字符串，并加入到result中，并返回
        if(node.left&#x3D;&#x3D;null&amp;&amp;node.right&#x3D;&#x3D;null)&#123;
            StringBuffer temp&#x3D;new StringBuffer();
            for(int i&#x3D;0;i&lt;paths.size()-1;i++)&#123;
                temp.append(paths.get(i)).append(&quot;-&gt;&quot;);
            &#125;
            temp.append(paths.get(paths.size()-1));
            result.add(temp.toString());
            return;
        &#125;
        &#x2F;&#x2F;如果该节点存在左孩子，则将左孩子进行递归
        &#x2F;&#x2F;注意，这里需要将paths列表的最后一个元素弹出，
        &#x2F;&#x2F;若该元素的左孩子就是叶子节点，则paths最后一个元素就是左孩子节点，因为后续要继续寻找路径，所以这里的叶节点需要弹出。
        if(node.left!&#x3D;null)&#123;
            traverse(node.left,paths,result);
            paths.remove(paths.size()-1);
        &#125;
        if(node.right!&#x3D;null)&#123;
            traverse(node.right,paths,result);
            paths.remove(paths.size()-1);
        &#125;
    &#125;
&#125;</code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html" data-id="cldlogw9i003ca8yke07n244s" data-title="257.二叉树的所有路径" class="article-share-link">Share</a>
      
        <a href="http://example.com/post/257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-110-平衡二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html" class="article-date">
  <time class="dt-published" datetime="2022-09-27T14:53:38.000Z" itemprop="datePublished">2022-09-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html">110.平衡二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="110">
<li>平衡二叉树</li>
</ol>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [3,9,20,null,null,15,7]
输出：true</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]
输出：false</code></pre>

<p>example 3:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; []
输出：true</code></pre>

<p>提示：</p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public int is_balanced(TreeNode node)&#123;
        &#x2F;&#x2F;若节点为空，则返回高度为0
        if(node&#x3D;&#x3D;null)
            return 0;
        &#x2F;&#x2F;左子树高度，并检查是否左子树是否平衡
        int left_depth&#x3D;is_balanced(node.left);
        if(left_depth&#x3D;&#x3D;-1)  return -1;
        &#x2F;&#x2F;右子树高度，并检查是否右子树是否平衡
        int right_depth&#x3D;is_balanced(node.right);
        if(right_depth&#x3D;&#x3D;-1) return -1;
        &#x2F;&#x2F;如果左子树和右子树高度差大于1，则不平衡，若平衡，则返回当前节点为根节点的树高度
        return Math.abs(left_depth-right_depth)&gt;1?-1:1+Math.max(right_depth,left_depth);
    &#125;

    public boolean isBalanced(TreeNode root) &#123;
        return is_balanced(root)&#x3D;&#x3D;-1?false:true;
    &#125;
&#125;</code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html" data-id="cldlogw91000wa8yka2it8bey" data-title="110.平衡二叉树" class="article-share-link">Share</a>
      
        <a href="http://example.com/post/110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-222-完全二叉树的节点个数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html" class="article-date">
  <time class="dt-published" datetime="2022-09-25T14:17:21.000Z" itemprop="datePublished">2022-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html">222.完全二叉树的节点个数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="222">
<li>完全二叉树的节点个数</li>
</ol>
<p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [1,2,3,4,5,6]
输出：6</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; []
输出：0</code></pre>

<p>example 3:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [1]
输出：1</code></pre>

<p>提示：</p>
<ul>
<li>树中节点的数目范围是<code>[0, 5 * 104]</code></li>
<li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li>
<li>题目数据保证输入的树是 <strong>完全二叉树</strong></li>
</ul>
<p>题目来源：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">https://leetcode.cn/problems/count-complete-tree-nodes/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;解法1：层序遍历，记录节点个数
class Solution &#123;
    &#x2F;&#x2F;迭代法
    public int countNodes(TreeNode root) &#123;
        if(root&#x3D;&#x3D;null)
            return 0;
        int node_count&#x3D;0;
        Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();
        queue.offer(root);
        while(!queue.isEmpty())&#123;
            TreeNode temp&#x3D;queue.poll();
            node_count++;
            if(temp.left!&#x3D;null) queue.offer(temp.left);
            if(temp.right!&#x3D;null) queue.offer(temp.right);
        &#125;
        return node_count;

    &#125;
&#125;

&#x2F;&#x2F;解法2：利用二叉树性质
class Solution &#123;
    &#x2F;&#x2F;利用完全二叉树的性质，使用递归，查看左遍历深度left_depth，和右深度right_depth,若左右深度相同，则该二叉树为完全二叉树，返回节点个数2^depth-1
    &#x2F;&#x2F;若左右深度不同，则递归左孩子，求出左子树的节点个数，递归右子树，求出右子树的节点个数，再加上1为根节点。
    public int countNodes(TreeNode root) &#123;
        if(root&#x3D;&#x3D;null)
            return 0;
        TreeNode left_child&#x3D;root.left;
        TreeNode right_child&#x3D;root.right;
        int left_depth&#x3D;0;
        int right_depth&#x3D;0;
        while(left_child!&#x3D;null)&#123;
            left_child&#x3D;left_child.left;
            left_depth++;
        &#125;
        
        System.out.println(left_depth);
        while(right_child!&#x3D;null)&#123;
            right_child&#x3D;right_child.right;
            right_depth++;
        &#125;
        System.out.println(right_depth);
        &#x2F;&#x2F; 若左右深度相同，则该二叉树为完全二叉树，返回节点个数2^depth-1
        if(right_depth&#x3D;&#x3D;left_depth)&#123;
            return (2&lt;&lt;right_depth)-1;
        &#125;
        else&#123;
            &#x2F;&#x2F; 若左右深度不同，则递归左孩子，求出左子树的节点个数，递归右子树，求出右子树的节点个数，再加上1为根节点。
            return countNodes(root.right)+countNodes(root.left)+1;
        &#125;
    &#125;
&#125;</code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html" data-id="cldlogw9c002ga8ykf8iy6m92" data-title="222.完全二叉树的节点个数" class="article-share-link">Share</a>
      
        <a href="http://example.com/post/222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-111-二叉树的最小深度" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html" class="article-date">
  <time class="dt-published" datetime="2022-09-24T14:45:07.000Z" itemprop="datePublished">2022-09-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html">111.二叉树的最小深度</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><ol start="111">
<li>二叉树的最小深度</li>
</ol>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [3,9,20,null,null,15,7]
输出：2</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]
输出：5</code></pre>

<p>提示：</p>
<ul>
<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p>题目来源：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    &#x2F;**
    层序遍历，和最大深度不同，最大深度是记录二叉树拥有的层次，而最小深度，是寻找距离根节点最近的叶子节点，即层序遍历遇到的第一个叶子节点（没有左孩子和右孩子的节点）。
    
     *&#x2F;
    public int minDepth(TreeNode root) &#123;
        
        if(root&#x3D;&#x3D;null)
            return 0;
        Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();
        int deep&#x3D;0;
        queue.offer(root);
        while(!queue.isEmpty())&#123;
            int size&#x3D;queue.size();
            deep++;
            for(int i&#x3D;0;i&lt;size;i++)&#123;
                TreeNode temp&#x3D;queue.poll();
                if(temp.left&#x3D;&#x3D;null&amp;&amp;temp.right&#x3D;&#x3D;null)&#123;
                    return deep;
                &#125;
                if(temp.left!&#x3D;null)&#123;
                    queue.offer(temp.left);
                &#125;
                if(temp.right!&#x3D;null) &#123;
                    queue.offer(temp.right);
                &#125;

            &#125;
        &#125;
        return deep;

    &#125;
&#125;
</code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html" data-id="cldlogw910010a8yk0f0zfjwo" data-title="111.二叉树的最小深度" class="article-share-link">Share</a>
      
        <a href="http://example.com/post/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-101-对称二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html" class="article-date">
  <time class="dt-published" datetime="2022-09-23T13:05:24.000Z" itemprop="datePublished">2022-09-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html">101.对称二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>example 1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">		1
      |    |
      2    2
    |   |  |   |
    3   4   4   3
输入：root &#x3D; [1,2,2,3,4,4,3]
输出：true</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">		1
      |    |
      2    2
        |      |
        3       3
输入：root &#x3D; [1,2,2,null,3,null,3]
输出：false</code></pre>

<p>提示：</p>
<ul>
<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public boolean isSymmetric(TreeNode root) &#123;
        return check(root.left,root.right);
    &#125;
    public boolean check(TreeNode left,TreeNode right)&#123;
        &#x2F;&#x2F;当一个空，一个不空，则不对称
        if(left&#x3D;&#x3D;null&amp;&amp;right!&#x3D;null)
            return false;
        if(left!&#x3D;null&amp;&amp;right&#x3D;&#x3D;null)
            return false;
        &#x2F;&#x2F;若两个都为空，则对称
        if(left&#x3D;&#x3D;null&amp;&amp;right&#x3D;&#x3D;null)
            return true;
        &#x2F;&#x2F;若两个值不一致，则不对称
        if(left.val!&#x3D;right.val)
            return false;
        &#x2F;&#x2F;若两个值一致，继续判断下一层节点是否对称
        boolean left_check&#x3D;check(left.left,right.right);
        boolean right_check&#x3D;check(left.right,right.left);
        &#x2F;&#x2F;仅当下层所有的节点都对称时，才对称，否则都不对称
        return left_check&amp;&amp;right_check;
    &#125;
&#125;</code></pre>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html" data-id="cldlogw8u000ca8ykbs48el60" data-title="101.对称二叉树" class="article-share-link">Share</a>
      
        <a href="http://example.com/post/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-226-翻转二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html" class="article-date">
  <time class="dt-published" datetime="2022-09-22T14:25:52.000Z" itemprop="datePublished">2022-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html">226.翻转二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">		4
      |    |
      2    7
    |   |  |   |
    1   3   6   9
        4
      |    |
      7    2
    |   |  |   |
    9   6   3   1
输入：root &#x3D; [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">		2
      |    |
      1    3
        2
      |    |
      1    3
输入：root &#x3D; [2,1,3]
输出：[2,3,1]</code></pre>

<p>example 3:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; []
输出：[]</code></pre>

<p>提示：</p>
<ul>
<li>树中节点数目范围在 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>题目来源:<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    &#x2F;&#x2F;后序遍历，若将遍历节点的左右孩子互换
    public void postOrder(TreeNode root)&#123;
        if(root&#x3D;&#x3D;null)
            return;
        if(root.left!&#x3D;null) postOrder(root.left);
        if(root.right!&#x3D;null) postOrder(root.right);
        TreeNode temp&#x3D;root.left;
        root.left&#x3D;root.right;
        root.right&#x3D;temp;
        
    &#125;
    public TreeNode invertTree(TreeNode root) &#123;
        if(root&#x3D;&#x3D;null)
            return null;
        postOrder(root);
        return root;
    &#125;
&#125;</code></pre>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html" data-id="cldlogw9d002na8yk1vw879f6" data-title="226.翻转二叉树" class="article-share-link">Share</a>
      
        <a href="http://example.com/post/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDN/">SDN</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%89%8D%E7%AB%AF/">WEB前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%89%8D%E7%AB%AF/">Web前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA/">个人</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">个人博客</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/">个人日志</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E9%AA%8C/">实验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">数据结构和算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结果与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">阅读笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" rel="tag">Java并发编程实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pycharm/" rel="tag">Pycharm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" rel="tag">使用方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" rel="tag">使用说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="tag">哈希表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" rel="tag">回溯算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%A5%E9%94%99/" rel="tag">报错</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" rel="tag">栈和队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9D%97/" rel="tag">模块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%91%E7%A0%94/" rel="tag">科研</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%BD%95/" rel="tag">记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF/" rel="tag">语法错误</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" style="font-size: 10.91px;">Java并发编程实战</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Pycharm/" style="font-size: 10px;">Pycharm</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Vue/" style="font-size: 11.82px;">Vue</a> <a href="/tags/leetcode/" style="font-size: 19.09px;">leetcode</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 18.18px;">二叉树</a> <a href="/tags/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" style="font-size: 10px;">使用方法</a> <a href="/tags/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">使用说明</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 16.36px;">动态规划</a> <a href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 10.91px;">单调栈</a> <a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" style="font-size: 12.73px;">哈希表</a> <a href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" style="font-size: 15.45px;">回溯算法</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 14.55px;">字符串</a> <a href="/tags/%E6%8A%A5%E9%94%99/" style="font-size: 11.82px;">报错</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10.91px;">数据结构</a> <a href="/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 10.91px;">日常</a> <a href="/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" style="font-size: 13.64px;">栈和队列</a> <a href="/tags/%E6%A8%A1%E5%9D%97/" style="font-size: 10px;">模块</a> <a href="/tags/%E7%A7%91%E7%A0%94/" style="font-size: 10px;">科研</a> <a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">记录</a> <a href="/tags/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF/" style="font-size: 10px;">语法错误</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 17.27px;">贪心算法</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 12.73px;">链表</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/comeback.html">comeback</a>
          </li>
        
          <li>
            <a href="/post/01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8002.html">01背包理论基础02</a>
          </li>
        
          <li>
            <a href="/post/01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001.html">01背包理论基础01</a>
          </li>
        
          <li>
            <a href="/post/84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html">84.柱状图中最大的矩形</a>
          </li>
        
          <li>
            <a href="/post/42-%E6%8E%A5%E9%9B%A8%E6%B0%B4.html">42.接雨水</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'XXX';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.async = true;
    dsq.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>



<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>