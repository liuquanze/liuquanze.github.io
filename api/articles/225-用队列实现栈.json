{"title":"225.用队列实现栈","uid":"5411a6b47b43d9c6d288402eac141a08","slug":"225-用队列实现栈","date":"2022-09-14T14:46:17.000Z","updated":"2022-09-14T14:48:54.649Z","comments":true,"path":"api/articles/225-用队列实现栈.json","keywords":null,"cover":null,"content":"<h1 id=\"225-用队列实现栈\"><a href=\"#225-用队列实现栈\" class=\"headerlink\" title=\"225.用队列实现栈\"></a>225.用队列实现栈</h1><h2 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h2><ol start=\"225\">\n<li>用队列实现栈</li>\n</ol>\n<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>\n<p>实现 <code>MyStack</code> 类：</p>\n<ul>\n<li><code>void push(int x)</code> 将元素 x 压入栈顶。</li>\n<li><code>int pop()</code> 移除并返回栈顶元素。</li>\n<li><code>int top()</code> 返回栈顶元素。</li>\n<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ul>\n<li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li>\n<li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>\n</ul>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：\n[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 2, 2, false]\n\n解释：\nMyStack myStack &#x3D; new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); &#x2F;&#x2F; 返回 2\nmyStack.pop(); &#x2F;&#x2F; 返回 2\nmyStack.empty(); &#x2F;&#x2F; 返回 False</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= x &lt;= 9</code></li>\n<li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li>\n<li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/implement-stack-using-queues\">https://leetcode.cn/problems/implement-stack-using-queues</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class MyStack &#123;\n    &#x2F;** \n        队列模拟栈，其实一个队列就够了，那么我们先说一说两个队列来实现栈的思路。\n\n    队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。\n\n    所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。\n\n    但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是另一个队列完全用又来备份的！\n\n    如下面动画所示，用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。\n    *&#x2F;\n    &#x2F;&#x2F; Deque 接口继承了 Queue 接口\n    &#x2F;&#x2F; 所以 Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst\n    Deque&lt;Integer&gt; que1;\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    public MyStack() &#123;\n        que1 &#x3D; new ArrayDeque&lt;&gt;();\n    &#125;\n    \n    &#x2F;** Push element x onto stack. *&#x2F;\n    public void push(int x) &#123;\n        que1.addLast(x);\n    &#125;\n    \n    &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;\n    public int pop() &#123;\n        int size &#x3D; que1.size();\n        size--;\n        &#x2F;&#x2F; 将 que1 除了最后一个元素之外的所有元素从队头移到队尾，相当于暴露最后一个元素，用以满足栈的先进后出的特性，同时将元素从队头移到队尾的操作可以替换原先的使用另一个辅助队列的方式，降低了时间复杂度\n        while (size-- &gt; 0) &#123;\n            que1.addLast(que1.peekFirst());\n            que1.pollFirst();\n        &#125;\n\n        int res &#x3D; que1.pollFirst();\n        return res;\n    &#125;\n    \n    &#x2F;** Get the top element. *&#x2F;\n    public int top() &#123;\n        return que1.peekLast();\n    &#125;\n    \n    &#x2F;** Returns whether the stack is empty. *&#x2F;\n    public boolean empty() &#123;\n        return que1.isEmpty();\n    &#125;\n&#125;\n\n&#x2F;**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj &#x3D; new MyStack();\n * obj.push(x);\n * int param_2 &#x3D; obj.pop();\n * int param_3 &#x3D; obj.top();\n * boolean param_4 &#x3D; obj.empty();\n *&#x2F;</code></pre>\n\n","text":"225.用队列实现栈问题描述： 用队列实现栈 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":120,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":114,"path":"api/tags/leetcode.json"},{"name":"栈和队列","slug":"栈和队列","count":6,"path":"api/tags/栈和队列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88\"><span class=\"toc-text\">225.用队列实现栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">问题描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"20.有效的括号","uid":"965581e4ba331d2a60f395aea86a2168","slug":"20-有效的括号","date":"2022-09-15T15:43:52.000Z","updated":"2022-09-15T15:46:45.717Z","comments":true,"path":"api/articles/20-有效的括号.json","keywords":null,"cover":null,"text":"20.有效的括号题目描述： 有效的括号 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":120,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":114,"path":"api/tags/leetcode.json"},{"name":"栈和队列","slug":"栈和队列","count":6,"path":"api/tags/栈和队列.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"232.用栈实现队列","uid":"d91274a3d01b11b2d199e36958cb424f","slug":"232-用栈实现队列","date":"2022-09-12T11:50:50.000Z","updated":"2022-09-12T11:53:41.606Z","comments":true,"path":"api/articles/232-用栈实现队列.json","keywords":null,"cover":null,"text":"232.用栈实现队列题目描述： 用栈实现队列 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":120,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":114,"path":"api/tags/leetcode.json"},{"name":"栈和队列","slug":"栈和队列","count":6,"path":"api/tags/栈和队列.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}