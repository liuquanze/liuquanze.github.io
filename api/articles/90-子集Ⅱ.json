{"title":"90.子集Ⅱ","uid":"5318d9a835b8dca882f536085827709f","slug":"90-子集Ⅱ","date":"2022-11-09T03:50:16.000Z","updated":"2022-11-09T03:52:54.427Z","comments":true,"path":"api/articles/90-子集Ⅱ.json","keywords":null,"cover":null,"content":"<h1 id=\"90-子集Ⅱ\"><a href=\"#90-子集Ⅱ\" class=\"headerlink\" title=\"90.子集Ⅱ\"></a>90.子集Ⅱ</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><p>90.子集 II</p>\n<p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>\n<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>\n<p>example 1：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [1,2,2]\n输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [0]\n输出：[[],[0]]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n<p>题目来源：</p>\n<p><a href=\"https://leetcode.cn/problems/subsets-ii/description/\">https://leetcode.cn/problems/subsets-ii/description/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    &#x2F;&#x2F;本题和子集Ⅰ的那一题的区别在于，本次的nums数组中包含重复元素，需要进行去重操作，完成该操作的手段是通过对nums进行排序，则加入元素之前判断前一个元素和当前元素是否相同，如果相同，且没有使用过，则跳过该元素的选取\n   List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F; 存放符合条件结果的集合\n   LinkedList&lt;Integer&gt; path &#x3D; new LinkedList&lt;&gt;();&#x2F;&#x2F; 用来存放符合条件结果\n   boolean[] used;\n    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;\n        if (nums.length &#x3D;&#x3D; 0)&#123;\n            result.add(path);\n            return result;\n        &#125;\n        Arrays.sort(nums);\n        used &#x3D; new boolean[nums.length];\n        subsetsWithDupHelper(nums, 0);\n        return result;\n    &#125;\n    \n    private void subsetsWithDupHelper(int[] nums, int startIndex)&#123;\n        result.add(new ArrayList&lt;&gt;(path));\n        if (startIndex &gt;&#x3D; nums.length)&#123;\n            return;\n        &#125;\n        &#x2F;&#x2F;used为true则表示使用过了，表示上一个元素和该元素位于不同的层次，此时可以出现重复数字，若used为false，则表示上一个元素已经被选取过了，该元素和上一个元素位于同一层，就不可以出现重复数字。通过下面的if判断完成去重的操作\n        for (int i &#x3D; startIndex; i &lt; nums.length; i++)&#123;\n            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1] &amp;&amp; !used[i - 1])&#123;\n                continue;\n            &#125;\n            path.add(nums[i]);\n            used[i] &#x3D; true;\n            subsetsWithDupHelper(nums, i + 1);\n            path.removeLast();\n            used[i] &#x3D; false;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n","text":"90.子集Ⅱ题目描述：90.子集 II 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 example 1： 输入：nums &#x3D; [1,2,2] 输出：[...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":101,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":106,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":100,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":9,"path":"api/tags/回溯算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#90-%E5%AD%90%E9%9B%86%E2%85%A1\"><span class=\"toc-text\">90.子集Ⅱ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java并发编程实战_第一章","uid":"b4ca66fa8cf36946a93ed492ada823ba","slug":"Java并发编程实战-第一章","date":"2022-11-09T15:25:33.000Z","updated":"2022-11-16T13:06:17.293Z","comments":true,"path":"api/articles/Java并发编程实战-第一章.json","keywords":null,"cover":null,"text":"Java并发编程实战——第一章【简介】1.并发简史 早期的计算机仅仅包含一个操作系统，从头到尾仅执行一个程序，并且该程序可访问计算机中所有资源 操作系统的出现使得计算机每次可以运行多个程序 不同的程序在不同的进程中运行 操作系统为每个独立运行的进程分配各种资源：内存、文件句柄、安...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"阅读笔记","slug":"阅读笔记","count":2,"path":"api/categories/阅读笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":106,"path":"api/tags/Java.json"},{"name":"Java并发编程实战","slug":"Java并发编程实战","count":2,"path":"api/tags/Java并发编程实战.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"78.子集","uid":"73e62cf89f554b3cf0c0c9da24853098","slug":"78-子集","date":"2022-11-07T13:36:20.000Z","updated":"2022-11-07T13:41:29.109Z","comments":true,"path":"api/articles/78-子集.json","keywords":null,"cover":null,"text":"78.子集问题描述：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 example 1: 输入：nums &#x3D; [1,2,3] 输出：[[],[1],[2],[1,2]...","link":"","photos":[],"count_time":{"symbolsCount":961,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":101,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":106,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":100,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":9,"path":"api/tags/回溯算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}