{"title":"701.二叉搜索树中的插入操作","uid":"de679446ce90a96213f1c24b7dcd05cc","slug":"701-二叉搜索树中的插入操作","date":"2022-10-12T02:51:28.000Z","updated":"2022-10-12T02:55:13.376Z","comments":true,"path":"api/articles/701-二叉搜索树中的插入操作.json","keywords":null,"cover":null,"content":"<h1 id=\"701-二叉搜索树中的插入操作\"><a href=\"#701-二叉搜索树中的插入操作\" class=\"headerlink\" title=\"701.二叉搜索树中的插入操作\"></a>701.二叉搜索树中的插入操作</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"701\">\n<li>二叉搜索树中的插入操作</li>\n</ol>\n<p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5\n输出：[4,2,7,1,3,5]</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25\n输出：[40,20,60,10,30,50,70,null,null,25]</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5\n输出：[4,2,7,1,3,5]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li>\n<li><code>-108 &lt;= Node.val &lt;= 108</code></li>\n<li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li>\n<li><code>-108 &lt;= val &lt;= 108</code></li>\n<li><strong>保证</strong> <code>val</code> 在原始BST中不存在</li>\n</ul>\n<p>题目来源：</p>\n<p><a href=\"https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/\">https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public TreeNode insertIntoBST(TreeNode root, int val) &#123;\n        &#x2F;&#x2F;若当前二叉搜索树为空，则创建新节点，并返回\n        if(root&#x3D;&#x3D;null)\n            return new TreeNode(val);\n        &#x2F;&#x2F;记录树的根节点，创建前驱节点\n        TreeNode newRoot&#x3D;root;\n        TreeNode pre&#x3D;null;\n        &#x2F;&#x2F;当活动节点不为null时进行循环遍历\n        while(root!&#x3D;null)&#123;\n            &#x2F;&#x2F;记录当前位置\n            pre&#x3D;root;\n            &#x2F;&#x2F;若当前节点val大于val则表示插入元素应该在当前节点的左子树\n            if(root.val&gt;val)&#123;\n                root&#x3D;root.left;\n            &#125;else&#123;\n                root&#x3D;root.right;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;当root&#x3D;null时跳出循环，此时pre指向的是叶子节点，若叶子节点的val大于插入元素，则作为左孩子，否则作为右孩子\n        if(pre.val&gt;val)&#123;\n            pre.left&#x3D;new TreeNode(val);\n        &#125;else&#123;\n            pre.right&#x3D;new TreeNode(val);\n        &#125;\n        return newRoot;\n    &#125;\n&#125;</code></pre>\n\n","text":"701.二叉搜索树中的插入操作题目描述： 二叉搜索树中的插入操作 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":97,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":102,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":96,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">701.二叉搜索树中的插入操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"450.删除二叉搜索树中的节点","uid":"4ddc27e8ab5fa8f62bf22aca925f034e","slug":"450-删除二叉搜索树中的节点","date":"2022-10-15T03:25:12.000Z","updated":"2022-10-15T03:28:21.883Z","comments":true,"path":"api/articles/450-删除二叉搜索树中的节点.json","keywords":null,"cover":null,"text":"450.删除二叉搜索树中的节点题目描述： 删除二叉搜索树中的节点 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":97,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":102,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":96,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"236.二叉搜索树的最近公共祖先","uid":"2f59e63c36776555eba1dd17097990fc","slug":"236-二叉搜索树的最近公共祖先","date":"2022-10-11T03:12:26.000Z","updated":"2022-10-11T03:14:52.266Z","comments":true,"path":"api/articles/236-二叉搜索树的最近公共祖先.json","keywords":null,"cover":null,"text":"236.二叉搜索树的最近公共祖先题目描述： 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":97,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":102,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":96,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}