{"title":"406.根据身高重建队列","uid":"6d39faed18394c3054176cba486feae5","slug":"406-根据身高重建队列","date":"2022-12-19T13:34:04.000Z","updated":"2022-12-19T13:37:49.949Z","comments":true,"path":"api/articles/406-根据身高重建队列.json","keywords":null,"cover":null,"content":"<h1 id=\"406-根据身高重建队列\"><a href=\"#406-根据身高重建队列\" class=\"headerlink\" title=\"406.根据身高重建队列\"></a>406.根据身高重建队列</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><ol start=\"406\">\n<li>根据身高重建队列</li>\n</ol>\n<p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>\n<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>\n<p>example 1：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n解释：\n编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。\n编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。\n编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。\n编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。\n编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\n输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= people.length &lt;= 2000</code></li>\n<li><code>0 &lt;= hi &lt;= 106</code></li>\n<li><code>0 &lt;= ki &lt; people.length</code></li>\n<li>题目数据确保队列可以被重建</li>\n</ul>\n<p>题目来源：</p>\n<p><a href=\"https://leetcode.cn/problems/queue-reconstruction-by-height/description/\">https://leetcode.cn/problems/queue-reconstruction-by-height/description/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int[][] reconstructQueue(int[][] people) &#123;\n        &#x2F;&#x2F;先对数组元素进行排序，先按照身高排序，从高到低排序，高度相同的元素按照第二个元素从低到高排列\n        Arrays.sort(people,(a,b)-&gt;&#123;\n            if(a[0]&#x3D;&#x3D;b[0])return a[1]-b[1];\n            return b[0]-a[0];\n        &#125;);\n\n        LinkedList&lt;int[]&gt; que&#x3D;new LinkedList&lt;&gt;();\n        &#x2F;&#x2F;将排序完成的数组从左至右开始按照插入到一个新的数组中，被插入位置的元素及其之后的元素集体后移，因此这里使用链表实现。插入的位置依照元素的第二个下标元素的大小。比如[x,1]插入一号位置。之所以从左至右选择元素进行插入是因为，后面插入的小元素不会影响前面大元素的相对位置要求\n        for(int[] p:people)&#123;\n            que.add(p[1],p);\n        &#125;\n        return que.toArray(new int[people.length][]);\n\n    &#125;\n&#125;</code></pre>\n\n","text":"406.根据身高重建队列题目描述 根据身高重建队列 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":110,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":116,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":110,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":15,"path":"api/tags/贪心算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97\"><span class=\"toc-text\">406.根据身高重建队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">题目描述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"452.用最少数量的箭引爆气球","uid":"e4f64fdd68d0e2cde5cecce7c3e76096","slug":"452-用最少数量的箭引爆气球","date":"2022-12-20T12:00:52.000Z","updated":"2022-12-20T12:03:07.557Z","comments":true,"path":"api/articles/452-用最少数量的箭引爆气球.json","keywords":null,"cover":null,"text":"452.用最少数量的箭引爆气球题目描述： 用最少数量的箭引爆气球 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":110,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":116,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":110,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":15,"path":"api/tags/贪心算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"860.柠檬水找零","uid":"f4bc994415987b6fe405c0f307a1279e","slug":"860-柠檬水找零","date":"2022-12-18T12:40:17.000Z","updated":"2022-12-18T12:44:14.170Z","comments":true,"path":"api/articles/860-柠檬水找零.json","keywords":null,"cover":null,"text":"860.柠檬水找零题目描述： 柠檬水找零 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":110,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":116,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":110,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":15,"path":"api/tags/贪心算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}