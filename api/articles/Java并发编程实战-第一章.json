{"title":"Java并发编程实战_第一章","uid":"b4ca66fa8cf36946a93ed492ada823ba","slug":"Java并发编程实战-第一章","date":"2022-11-09T15:25:33.000Z","updated":"2022-11-16T13:06:17.293Z","comments":true,"path":"api/articles/Java并发编程实战-第一章.json","keywords":null,"cover":null,"content":"<h1 id=\"Java并发编程实战——第一章【简介】\"><a href=\"#Java并发编程实战——第一章【简介】\" class=\"headerlink\" title=\"Java并发编程实战——第一章【简介】\"></a>Java并发编程实战——第一章【简介】</h1><h2 id=\"1-并发简史\"><a href=\"#1-并发简史\" class=\"headerlink\" title=\"1.并发简史\"></a>1.并发简史</h2><ul>\n<li>早期的计算机仅仅包含一个操作系统，从头到尾仅执行一个程序，并且该程序可访问计算机中所有资源</li>\n<li>操作系统的出现使得计算机每次可以运行多个程序<ul>\n<li>不同的程序在不同的进程中运行</li>\n<li>操作系统为每个独立运行的进程分配各种资源：内存、文件句柄、安全证书等</li>\n<li>不同进程间可进行通信，通信机制包括：套接字、信号处理器、共享内存、信号量以及文件等</li>\n</ul>\n</li>\n<li>为什么在计算机中加入操作系统以实现多个程序的同时执行？<ul>\n<li>资源利用率：单个程序等待外部操作时，无法进行其他操作，造成计算资源的浪费</li>\n<li>公平性：不同的用户和程序对计算机资源具有相同的使用权</li>\n<li>便利性：编写多个程序，并且在必要时进行程序间通信相比于编写单个程序而言更易于实现</li>\n</ul>\n</li>\n<li>这些促使进程出现的因素，同样促使线程的出现：<ul>\n<li>线程允许同一个进程中存在多个程序控制流。</li>\n<li>线程共享进程范围内的资源，例如内存句柄和文件句柄</li>\n<li>每个线程都有自己的程序计数器、栈、变量等</li>\n<li>在同一个程序中的多个线程可以被调度到多个CPU上运行</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-线程的优势\"><a href=\"#2-线程的优势\" class=\"headerlink\" title=\"2.线程的优势\"></a>2.线程的优势</h2><ul>\n<li>发挥多处理器的强大能力<ul>\n<li>在双处理器系统上，单线程的程序只能使用一半的CPU资源，在100个处理器的系统上，将有99%的资源无法使用，而多线程可以同时在多个处理器上执行，若设计正确，多线程程序可以通过提高处理器资源的利用率来提升系统吞吐率</li>\n<li>使用多线程同样可以有助于在单处理器上获得更高的吞吐率</li>\n</ul>\n</li>\n<li>建模的简单性<ul>\n<li>若程序中只包含一种类型的任务，那么比包含多个不同类型的任务的程序要更加易于编写，错误更少，也更加易于测试</li>\n<li>通过线程，可以将复杂且异步的工作流进一步分解为一组简单且同步的工作流，每个工作流在一个线程中运行，并且在特定同步位置进行交互。</li>\n</ul>\n</li>\n<li>异步事件的简化处理<ul>\n<li>服务器应用程序在接收来自多个远程客户端的套接字连接请求时，为每一个请求连接都分配其各自的一个线程并且使用同步IO将会降低该类程序的开发难度</li>\n<li>若使用单线程，则每一次只可以处理一个请求，其他的请求必须阻塞，这大大降低了请求的处理速度，为了解决这个问题，可以使用<strong>非阻塞IO</strong>来实现请求阻塞的问题，但是<strong>非阻塞IO</strong>的复杂度远远高于<strong>同步IO</strong><ul>\n<li>非阻塞IO不太了解</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-线程带来的风险\"><a href=\"#3-线程带来的风险\" class=\"headerlink\" title=\"3.线程带来的风险\"></a>3.线程带来的风险</h2><ul>\n<li>安全性问题：【永远不发生糟糕的事情】<ul>\n<li>线程安全性可能是非常复杂的，在没有充分同步的情况下，多个线程中的操作顺序是不可预测的，甚至会产生奇怪的结果</li>\n<li>当多个线程要共享相同的内存地址空间，并且是并发运行时，可能会存在一个线程访问或修改其他线程正在使用的变量，这是一个极大的便利，同时也带来了巨大风险：线程会因为无法预料的数据变化而发生错误。</li>\n<li>当多个线程同时访问和修改相同变量时，将会在串行编程模型中引入非串行因素，并且这种非串行性是很难分析的。</li>\n<li>要使得多线程程序的行为是可以预测的，必须对共享便利的访问操作进行协同，防止线程之间相互干扰。</li>\n<li>Java也提供了各种同步机制来协同这种访问</li>\n</ul>\n</li>\n<li>活跃性问题：【活跃性：某件事情终将会发生】<ul>\n<li>形式之一：无意中造成的无限循环，从而使得循环体之后的代码得不到执行</li>\n</ul>\n</li>\n<li>性能问题：<ul>\n<li>在多线程程序种，频繁的进行线程切换不仅会造成资源开销，同时会压缩线程执行的时间，因此，应该尽量分析和减少此类开销</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-线程无处不在\"><a href=\"#4-线程无处不在\" class=\"headerlink\" title=\"4.线程无处不在\"></a>4.线程无处不在</h2><ul>\n<li>即使程序中没有显式的创建线程，但在框架种仍然可能会创建线程，因此在这些线程中调用的代码必须是线程安全的</li>\n</ul>\n","text":"Java并发编程实战——第一章【简介】1.并发简史 早期的计算机仅仅包含一个操作系统，从头到尾仅执行一个程序，并且该程序可访问计算机中所有资源 操作系统的出现使得计算机每次可以运行多个程序 不同的程序在不同的进程中运行 操作系统为每个独立运行的进程分配各种资源：内存、文件句柄、安...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"阅读笔记","slug":"阅读笔记","count":2,"path":"api/categories/阅读笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":104,"path":"api/tags/Java.json"},{"name":"Java并发编程实战","slug":"Java并发编程实战","count":2,"path":"api/tags/Java并发编程实战.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%90%E7%AE%80%E4%BB%8B%E3%80%91\"><span class=\"toc-text\">Java并发编程实战——第一章【简介】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%B9%B6%E5%8F%91%E7%AE%80%E5%8F%B2\"><span class=\"toc-text\">1.并发简史</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">2.线程的优势</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%BA%BF%E7%A8%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%A3%8E%E9%99%A9\"><span class=\"toc-text\">3.线程带来的风险</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E7%BA%BF%E7%A8%8B%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8\"><span class=\"toc-text\">4.线程无处不在</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java并发编程实战-第二章","uid":"d9d4098d77d12fc0df1e3b0cd1199653","slug":"Java并发编程实战-第二章","date":"2022-11-16T13:04:07.000Z","updated":"2022-11-16T13:31:45.963Z","comments":true,"path":"api/articles/Java并发编程实战-第二章.json","keywords":null,"cover":null,"text":"Java并发编程实战——第二章【线程安全性】 判断一个对象是否是线程安全的，取决于它是否被多个线程访问 要使得对象是线程安全的，需要采用同步机制来协同对对象的可变状态的访问。 当多个线程访问同一个可变的状态变量时，若没有使用合适的同步，程序可能出现错误，可使用以下三种方式修复这个...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"阅读笔记","slug":"阅读笔记","count":2,"path":"api/categories/阅读笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":104,"path":"api/tags/Java.json"},{"name":"Java并发编程实战","slug":"Java并发编程实战","count":2,"path":"api/tags/Java并发编程实战.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"90.子集Ⅱ","uid":"5318d9a835b8dca882f536085827709f","slug":"90-子集Ⅱ","date":"2022-11-09T03:50:16.000Z","updated":"2022-11-09T03:52:54.427Z","comments":true,"path":"api/articles/90-子集Ⅱ.json","keywords":null,"cover":null,"text":"90.子集Ⅱ题目描述：90.子集 II 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 example 1： 输入：nums &#x3D; [1,2,2] 输出：[...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":99,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":104,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":98,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":9,"path":"api/tags/回溯算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}