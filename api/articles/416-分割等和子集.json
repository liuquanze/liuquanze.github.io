{"title":"416.分割等和子集","uid":"be7f5c6dc71f9de739df383de800893c","slug":"416-分割等和子集","date":"2022-08-20T01:04:47.000Z","updated":"2022-08-20T01:11:13.233Z","comments":true,"path":"api/articles/416-分割等和子集.json","keywords":null,"cover":null,"content":"<h1 id=\"416-分割等和子集\"><a href=\"#416-分割等和子集\" class=\"headerlink\" title=\"416.分割等和子集\"></a>416.分割等和子集</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"416\">\n<li>分割等和子集</li>\n</ol>\n<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [1,5,11,5]\n输出：true\n解释：数组可以分割成 [1, 5, 5] 和 [11] 。</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [1,2,3,5]\n输出：false\n解释：数组不能分割成两个元素和相等的子集。</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/partition-equal-subset-sum/\">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;滚动数组，一维的dp数组\nclass Solution &#123;\n    public boolean canPartition(int[] nums) &#123;\n        if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;\n            return false;\n        &#125;\n        int sum&#x3D;0;\n        for(int num:nums)&#123;\n            sum+&#x3D;num;\n        &#125;\n        &#x2F;&#x2F;是奇数，必无法分割成两个等和的子数组\n        if(sum%2&#x3D;&#x3D;1)&#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F;背包大小即为和\n        &#x2F;&#x2F;物品重量为nums[i],物品价值为nums[i]\n        int target&#x3D;sum&#x2F;2;\n        int[] dp&#x3D;new int[target+1];\n        for(int i&#x3D;nums[0];i&lt;&#x3D;target;i++)&#123;\n            dp[i]&#x3D;nums[0];\n        &#125;\n        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;\n            for(int j&#x3D;target;j&gt;&#x3D;nums[i];j--)&#123;\n                &#x2F;&#x2F;为了防止覆盖问题，背包容量从后往前遍历\n                dp[j]&#x3D;Math.max(dp[j],dp[j-nums[i]]+nums[i]);\n            &#125;\n        &#125;\n        return dp[target]&#x3D;&#x3D;target;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;01背包，二维dp数组\nclass Solution &#123;\n    public boolean canPartition(int[] nums) &#123;\n        if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;\n            return false;\n        &#125;\n        int sum&#x3D;0;\n        for(int num:nums)&#123;\n            sum+&#x3D;num;\n        &#125;\n        if(sum%2&#x3D;&#x3D;1)&#123;\n            return false;\n        &#125;\n        int target&#x3D;sum&#x2F;2;\n        int[][] dp&#x3D;new int[nums.length][target+1];\n        &#x2F;&#x2F;dp数组初始化\n        for(int i&#x3D;nums[0];i&lt;&#x3D;target;i++)&#123;\n            dp[0][i]&#x3D;nums[0];\n        &#125;\n        &#x2F;&#x2F;遍历物品从第一个开始，因为初始化的时候第0个已经遍历过了\n        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;target;j++)&#123;\n                if(j&lt;nums[i])&#123;\n                    dp[i][j]&#x3D;dp[i-1][j];\n                &#125;else&#123;\n                    dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[nums.length-1][target]&#x3D;&#x3D;target;\n    &#125;\n&#125;</code></pre>\n\n","text":"416.分割等和子集题目描述： 分割等和子集 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 example 1: 输入：nums &#x3D; [1,5,11,5] 输出：true 解释：数组可以分割成 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":101,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":106,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":7,"path":"api/tags/动态规划.json"},{"name":"leetcode","slug":"leetcode","count":100,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86\"><span class=\"toc-text\">416.分割等和子集</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"203.移除链表元素","uid":"e036cd89658c33624bfd31dd2060c058","slug":"203-移除链表元素","date":"2022-08-20T01:35:04.000Z","updated":"2022-08-20T01:37:27.376Z","comments":true,"path":"api/articles/203-移除链表元素.json","keywords":null,"cover":null,"text":"203.移除链表元素题目描述： 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 example 1: 输入：head &#x3D; [1,2,6,3,4,5,6], val &...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":101,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":106,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":100,"path":"api/tags/leetcode.json"},{"name":"链表","slug":"链表","count":4,"path":"api/tags/链表.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"59.螺旋矩阵Ⅱ","uid":"fb852bf52649b6773513d798310ccbeb","slug":"59-螺旋矩阵Ⅱ","date":"2022-08-19T12:59:09.000Z","updated":"2022-08-19T13:01:10.824Z","comments":true,"path":"api/articles/59-螺旋矩阵Ⅱ.json","keywords":null,"cover":null,"text":"59.螺旋矩阵Ⅱ题目描述： 螺旋矩阵 II 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 example 1: 输入：n &#x3D; 3 输出：[[1,2,3],[8,9,4],[7,6,5]...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":101,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":106,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":100,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}