{"title":"划分字母区间","uid":"b3d8a41da3eeb7700876b944e097bd03","slug":"划分字母区间","date":"2022-08-03T02:16:17.000Z","updated":"2022-08-03T02:18:46.609Z","comments":true,"path":"api/articles/划分字母区间.json","keywords":null,"cover":null,"content":"<h1 id=\"763-划分字母区间\"><a href=\"#763-划分字母区间\" class=\"headerlink\" title=\"763.划分字母区间\"></a>763.划分字母区间</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><h4 id=\"763-划分字母区间-1\"><a href=\"#763-划分字母区间-1\" class=\"headerlink\" title=\"763. 划分字母区间\"></a>763. 划分字母区间</h4><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：S &#x3D; &quot;ababcbacadefegdehijhklij&quot;\n输出：[9,7,8]\n解释：\n划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。\n每个字母最多出现在一个片段中。\n像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</code></pre>\n\n<p>题目来源：<a href=\"https://leetcode.cn/problems/partition-labels/\">https://leetcode.cn/problems/partition-labels/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public List&lt;Integer&gt; partitionLabels(String s) &#123;\n        &#x2F;** \n        贪心算法：\n            由于每个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。\n            在得到每个字母的最后一次出现的下标位置之后，可以使用贪心算法将字符串划分为尽可能多的片段，具体做法如下：\n            1.从左到右遍历字符串，遍历的同时维护当前片段的开始下标start和结束下标end，初始化start&#x3D;end&#x3D;0；\n            2.对于每一个访问到的字母c，得到当前字母的最后一次出现的下标位置endc，则当前片段的结束下标一定不会小于endc，因此令end&#x3D;max(end,endc);\n            3.当访问到下标end时，当前片段访问结束，当前片段的下标范围是[start,end]，长度为end-start+1，将当前片段的长度添加到返回值，然后令start&#x3D;end+1，继续寻找下一个片段；\n            4.重复上述过程，知道遍历完字符串\n        *&#x2F;\n        用于记录每个字母出现的最后位置\n        int[] chars&#x3D;new int[26];\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            &#x2F;&#x2F;将当前字母在s中出现的位置存入chars数组中对应字母的下标位置中\n            chars[s.charAt(i)-&#39;a&#39;]&#x3D;i;\n        &#125;\n        List&lt;Integer&gt; partition&#x3D;new ArrayList&lt;&gt;();\n        int start&#x3D;0;\n        int end&#x3D;0;\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            &#x2F;&#x2F;得到对应字母c的最迟出现位置，若endc&gt;end则更新end的值，表示出现了比之前end对应字母还晚的字母，如果endc&lt;end则表示字母c的end所对应的字母的最晚出现位置已经在c的最晚出现位置之后了\n            end&#x3D;Math.max(end,chars[s.charAt(i)-&#39;a&#39;]);\n            if(end&#x3D;&#x3D;i)&#123;\n                &#x2F;&#x2F;添加片段长度，更新start的值\n                partition.add(end-start+1);\n                start&#x3D;end+1;\n            &#125;\n        &#125;\n        return partition;\n\n\n    &#125;\n&#125;</code></pre>\n\n\n\n","text":"763.划分字母区间题目描述：763. 划分字母区间字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。 example 1: 输入：S &#x3D; &quot;ababcbacadefegd...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":44,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":46,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":42,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4\"><span class=\"toc-text\">763.划分字母区间</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-1\"><span class=\"toc-text\">763. 划分字母区间</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"x的平方根","uid":"3b8822123bb08af7e60b15ed39819f81","slug":"x的平方根","date":"2022-08-04T01:36:47.000Z","updated":"2022-08-06T03:39:18.130Z","comments":true,"path":"api/articles/x的平方根.json","keywords":null,"cover":null,"text":"69. x的平方根题目描述：给你一个非负整数 x ，计算并返回 x 的 算术平方根 。 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。 example 1: 输入...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":44,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":46,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":42,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"最大子数组和","uid":"f6c56b941ed067956656bab8c3d0bb61","slug":"最大子数组和","date":"2022-08-02T01:22:15.000Z","updated":"2022-08-02T01:26:05.471Z","comments":true,"path":"api/articles/最大子数组和.json","keywords":null,"cover":null,"text":"最大子数组和题目描述： 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 example 1: 输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4] ...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":44,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":46,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":42,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}