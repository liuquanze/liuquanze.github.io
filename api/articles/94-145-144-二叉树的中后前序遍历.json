{"title":"94&145&144.二叉树的中后前序遍历","uid":"ed6d09f7c666a266cc6ff445e8452d5b","slug":"94-145-144-二叉树的中后前序遍历","date":"2022-09-19T11:44:26.000Z","updated":"2022-09-19T11:51:12.740Z","comments":true,"path":"api/articles/94-145-144-二叉树的中后前序遍历.json","keywords":null,"cover":null,"content":"<h1 id=\"94-amp-145-amp-144-二叉树的中后前序遍历\"><a href=\"#94-amp-145-amp-144-二叉树的中后前序遍历\" class=\"headerlink\" title=\"94&amp;145&amp;144.二叉树的中后前序遍历\"></a>94&amp;145&amp;144.二叉树的中后前序遍历</h1><h2 id=\"题目描述-中-：\"><a href=\"#题目描述-中-：\" class=\"headerlink\" title=\"题目描述[中]：\"></a>题目描述[中]：</h2><ol start=\"94\">\n<li>二叉树的中序遍历</li>\n</ol>\n<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1,null,2,3]\n输出：[1,3,2]</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1]\n输出：[1]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/\">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p>\n<h2 id=\"题解-中-：\"><a href=\"#题解-中-：\" class=\"headerlink\" title=\"题解[中]：\"></a>题解[中]：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n        public void inOrder(TreeNode root,List&lt;Integer&gt; result)&#123;\n        if(root&#x3D;&#x3D;null)\n            return;\n        inOrder(root.left,result);\n        result.add(root.val);\n        inOrder(root.right,result);\n    &#125;\n\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        inOrder(root,result);\n        return result;\n    &#125;\n\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"题目描述-后-：\"><a href=\"#题目描述-后-：\" class=\"headerlink\" title=\"题目描述[后]：\"></a>题目描述[后]：</h2><ol start=\"145\">\n<li>二叉树的后序遍历</li>\n</ol>\n<p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1,null,2,3]\n输出：[3,2,1]</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1]\n输出：[1]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/binary-tree-postorder-traversal/\">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p>\n<h2 id=\"题解-后-：\"><a href=\"#题解-后-：\" class=\"headerlink\" title=\"题解[后]：\"></a>题解[后]：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public void postOrder(TreeNode root,List&lt;Integer&gt; result)&#123;\n        if(root&#x3D;&#x3D;null)\n            return ;\n        postOrder(root.left,result);\n        postOrder(root.right,result);\n        result.add(root.val);\n    &#125;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        postOrder(root,result);\n        return result;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"题目描述-前-：\"><a href=\"#题目描述-前-：\" class=\"headerlink\" title=\"题目描述[前]：\"></a>题目描述[前]：</h2><ol start=\"144\">\n<li>二叉树的前序遍历</li>\n</ol>\n<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1,null,2,3]\n输出：[1,2,3]</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1]\n输出：[1]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/binary-tree-preorder-traversal/\">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p>\n<h2 id=\"题解-前-：\"><a href=\"#题解-前-：\" class=\"headerlink\" title=\"题解[前]：\"></a>题解[前]：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public void preOrder(TreeNode root,List&lt;Integer&gt; result)&#123;\n        if(root&#x3D;&#x3D;null)\n            return;\n        result.add(root.val);\n        preOrder(root.left,result);\n        preOrder(root.right,result);\n    &#125;\n\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        preOrder(root,result);\n        return result;\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n","text":"94&amp;145&amp;144.二叉树的中后前序遍历题目描述[中]： 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 example 1: 输入：root &#x3D; [1,null,2,3] 输出：[1,3,2] example 2: ...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":104,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":110,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":104,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#94-amp-145-amp-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%90%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">94&amp;145&amp;144.二叉树的中后前序遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-%E4%B8%AD-%EF%BC%9A\"><span class=\"toc-text\">题目描述[中]：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-%E4%B8%AD-%EF%BC%9A\"><span class=\"toc-text\">题解[中]：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-%E5%90%8E-%EF%BC%9A\"><span class=\"toc-text\">题目描述[后]：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-%E5%90%8E-%EF%BC%9A\"><span class=\"toc-text\">题解[后]：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-%E5%89%8D-%EF%BC%9A\"><span class=\"toc-text\">题目描述[前]：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-%E5%89%8D-%EF%BC%9A\"><span class=\"toc-text\">题解[前]：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"94-145-144-二叉树的中后前序遍历-迭代法","uid":"c8b3d710ba9b825096c6638c8fc52d7d","slug":"94-145-144-二叉树的中后前序遍历-迭代法","date":"2022-09-20T12:40:17.000Z","updated":"2022-09-20T12:43:37.992Z","comments":true,"path":"api/articles/94-145-144-二叉树的中后前序遍历-迭代法.json","keywords":null,"cover":null,"text":"94&amp;145&amp;144.二叉树的中后前序遍历题目描述[中]： 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 example 1: 输入：root &#x3D; [1,null,2,3] 输出：[1,3,2] example 2: ...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"239.滑动窗口的最大值","uid":"9087aaa078842eff85ab79f796fcf5f3","slug":"239-滑动窗口的最大值","date":"2022-09-18T05:03:58.000Z","updated":"2022-09-18T05:06:02.341Z","comments":true,"path":"api/articles/239-滑动窗口的最大值.json","keywords":null,"cover":null,"text":"239.滑动窗口的最大值题目描述： 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 example 1: 输入：nums ...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":104,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":110,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":104,"path":"api/tags/leetcode.json"},{"name":"栈和队列","slug":"栈和队列","count":6,"path":"api/tags/栈和队列.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}