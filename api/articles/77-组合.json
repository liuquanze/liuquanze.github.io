{"title":"77.组合","uid":"1b150da79eed14110a1dc1998320aec7","slug":"77-组合","date":"2022-10-24T15:30:39.000Z","updated":"2022-10-24T15:32:53.207Z","comments":true,"path":"api/articles/77-组合.json","keywords":null,"cover":null,"content":"<h1 id=\"77-组合\"><a href=\"#77-组合\" class=\"headerlink\" title=\"77.组合\"></a>77.组合</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"77\">\n<li>组合</li>\n</ol>\n<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>\n<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>\n<p>example 1：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：n &#x3D; 4, k &#x3D; 2\n输出：\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]</code></pre>\n\n<p>exmaple 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：n &#x3D; 1, k &#x3D; 1\n输出：[[1]]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= n &lt;= 20</code></li>\n<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/combinations/description/\">https://leetcode.cn/problems/combinations/description/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; result&#x3D;new LinkedList&lt;&gt;();\n    public LinkedList&lt;Integer&gt; path&#x3D;new LinkedList&lt;&gt;();\n    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;\n        getResult(n,k,1);\n        return result;\n\n    &#125;\n\n    public void getResult(int n,int k,int startIndex)&#123;\n        &#x2F;&#x2F;若路径上的元素个数达到k个，则加入结果集\n        if(path.size()&#x3D;&#x3D;k)&#123;\n            result.add(new ArrayList(path));\n            return ;\n        &#125;\n        &#x2F;&#x2F;减枝操作，剩余所需元素个数为k-path.size个\n        for(int i&#x3D;startIndex;i&lt;&#x3D;n-(k-path.size())+1;i++)&#123;\n            path.add(i);\n            getResult(n,k,i+1);\n            path.removeLast();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n","text":"77.组合题目描述： 组合 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 example 1： 输入：n &#x3D; 4, k &#x3D; 2 输出： [ [2,4], [3,4], [2,3], [1,2]...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":94,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":97,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":93,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":7,"path":"api/tags/回溯算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#77-%E7%BB%84%E5%90%88\"><span class=\"toc-text\">77.组合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"216.组合总和Ⅲ","uid":"16a3361e9df66c3302f57a7e8e439d54","slug":"216-组合总和Ⅲ","date":"2022-10-27T15:01:56.000Z","updated":"2022-10-27T15:04:35.192Z","comments":true,"path":"api/articles/216-组合总和Ⅲ.json","keywords":null,"cover":null,"text":"216.组合总和Ⅲ题目描述： 组合总和 III 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 example 1: 输入: k &#...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":94,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":97,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":93,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":7,"path":"api/tags/回溯算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"538. 把二叉搜索树转换为累加树","uid":"02ff0e8752a89b69920bc0868292de56","slug":"538-把二叉搜索树转换为累加树","date":"2022-10-19T14:48:37.000Z","updated":"2022-10-19T14:51:27.465Z","comments":true,"path":"api/articles/538-把二叉搜索树转换为累加树.json","keywords":null,"cover":null,"text":"题目描述： 把二叉搜索树转换为累加树 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":94,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":97,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":93,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}