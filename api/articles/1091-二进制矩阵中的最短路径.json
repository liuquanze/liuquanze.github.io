{"title":"1091.二进制矩阵中的最短路径","uid":"401c664502fc1c05444b73fd7436e5f7","slug":"1091-二进制矩阵中的最短路径","date":"2022-08-13T02:39:07.000Z","updated":"2022-08-13T02:45:44.716Z","comments":true,"path":"api/articles/1091-二进制矩阵中的最短路径.json","keywords":null,"cover":null,"content":"<h1 id=\"1091-二进制矩阵中的最短路径\"><a href=\"#1091-二进制矩阵中的最短路径\" class=\"headerlink\" title=\"1091.二进制矩阵中的最短路径\"></a>1091.二进制矩阵中的最短路径</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"1091\">\n<li>二进制矩阵中的最短路径</li>\n</ol>\n<p>难度中等214收藏分享切换为英文接收动态反馈</p>\n<p>给你一个 <code>n x n</code> 的二进制矩阵 <code>grid</code> 中，返回矩阵中最短 <strong>畅通路径</strong> 的长度。如果不存在这样的路径，返回 <code>-1</code> 。</p>\n<p>二进制矩阵中的 畅通路径 是一条从 <strong>左上角</strong> 单元格（即，<code>(0, 0)</code>）到 右下角 单元格（即，<code>(n - 1, n - 1)</code>）的路径，该路径同时满足下述要求：</p>\n<ul>\n<li>路径途经的所有单元格都的值都是 <code>0</code> 。</li>\n<li>路径中所有相邻的单元格应当在 <strong>8 个方向之一</strong> 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</li>\n</ul>\n<p><strong>畅通路径的长度</strong> 是该路径途经的单元格总数。</p>\n<p>example:1</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：grid &#x3D; [[0,1],[1,0]]\n输出：2</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：grid &#x3D; [[0,0,0],[1,1,0],[1,1,0]]\n输出：4</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：grid &#x3D; [[1,0,0],[1,1,0],[1,1,0]]\n输出：-1</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>n == grid.length</code></li>\n<li><code>n == grid[i].length</code></li>\n<li><code>1 &lt;= n &lt;= 100</code></li>\n<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/shortest-path-in-binary-matrix/\">https://leetcode.cn/problems/shortest-path-in-binary-matrix/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\nclass Solution &#123;\n    public int shortestPathBinaryMatrix(int[][] grid) &#123;\n        &#x2F;&#x2F;判断参数是否合法\n        if(grid&#x3D;&#x3D;null||grid.length&#x3D;&#x3D;0||grid[0].length&#x3D;&#x3D;0)&#123;\n            return -1;\n        &#125;        \n        int m&#x3D;grid.length;\n        int n&#x3D;grid[0].length;\n        &#x2F;&#x2F;判断起点和终点是否合法\n        if(grid[0][0]&#x3D;&#x3D;1||grid[m-1][m-1]&#x3D;&#x3D;1)&#123;\n            return -1;\n        &#125;\n        &#x2F;&#x2F;定义8个移动方向\n        int[][] dirs&#x3D;&#123;&#123;1,1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;-1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;\n        &#x2F;&#x2F;创建队列，加入起点坐标\n        Queue&lt;int[]&gt; queue&#x3D;new LinkedList&lt;&gt;();\n        &#x2F;&#x2F;起点设为1，防止重复遍历,初始化层次计数\n        queue.offer(new int[]&#123;0,0&#125;);\n        grid[0][0]&#x3D;1;\n        int path&#x3D;1;\n        &#x2F;&#x2F;遍历队列\n        while(!queue.isEmpty())&#123;\n            &#x2F;&#x2F;这里获取队列大小的目的是为了区分当前遍历层次和下一个层次，若不记录size，则在队列加入新的元素后无法区分路径长度。\n            int size&#x3D;queue.size();\n            &#x2F;&#x2F;当该层的元素（size大小），全部遍历完毕，就path+1，然后进入下一层。\n            for(int i&#x3D;0;i&lt;size;i++)&#123;\n                int[] cur&#x3D;queue.poll();\n                int x&#x3D;cur[0];\n                int y&#x3D;cur[1];\n                if(x&#x3D;&#x3D;m-1&amp;&amp;y&#x3D;&#x3D;n-1)&#123;\n                    return path;\n                &#125;\n\t\t\t\t&#x2F;&#x2F;将与当前cur相邻的八个方向元素进行遍历，符合条件的入队\n                for(int[] dir:dirs)&#123;\n                    int x1&#x3D;x+dir[0];\n                    int y1&#x3D;y+dir[1];\n                    if(x1&gt;&#x3D;0&amp;&amp; x1&lt;m &amp;&amp; y1&gt;&#x3D;0&amp;&amp; y1&lt;n&amp;&amp; grid[x1][y1]&#x3D;&#x3D;0)&#123;\n                        queue.offer(new int[]&#123;x1,y1&#125;);\n                        grid[x1][y1]&#x3D;1;\n                    &#125;\n                &#125;\n\n            &#125;\n            path++;\n\n        &#125;\n\n        return -1;    \n    &#125;\n&#125;\n</code></pre>\n\n","text":"1091.二进制矩阵中的最短路径题目描述： 二进制矩阵中的最短路径 难度中等214收藏分享切换为英文接收动态反馈 给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。 二进制矩阵中的 畅通路径 是一条从 左上角 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":46,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":48,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":44,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">1091.二进制矩阵中的最短路径</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"509.斐波那契数列","uid":"084b6d4a3eb1719c740e694cde17f8e9","slug":"斐波那契数列","date":"2022-08-13T03:54:49.000Z","updated":"2022-08-13T04:42:40.478Z","comments":true,"path":"api/articles/斐波那契数列.json","keywords":null,"cover":null,"text":"509.斐波那契数列 斐波那契数 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) &#x3D; 0，F(1) &#x3D; 1 F(n) &#x3D; F(n - 1) +...","link":"","photos":[],"count_time":{"symbolsCount":967,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":46,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":48,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":7,"path":"api/tags/动态规划.json"},{"name":"leetcode","slug":"leetcode","count":44,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"不同的二叉搜索树Ⅱ","uid":"3a8637d28c1ed4973b1acb4bbd24e5f2","slug":"不同的二叉搜索树Ⅱ","date":"2022-08-12T02:59:34.000Z","updated":"2022-08-12T03:02:09.663Z","comments":true,"path":"api/articles/不同的二叉搜索树Ⅱ.json","keywords":null,"cover":null,"text":"95.不同的二叉搜索树Ⅱ题目描述： 不同的二叉搜索树 II 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。 example 1: 输入：n &#x3D; 3 输出：[[1,null,2,n...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":46,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":48,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":44,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}