{"title":"判断子序列","uid":"82a606d2417be24205d07d3a23121174","slug":"判断子序列","date":"2022-07-31T03:01:34.000Z","updated":"2022-07-31T03:03:49.790Z","comments":true,"path":"api/articles/判断子序列.json","keywords":null,"cover":null,"content":"<h1 id=\"392-判断子序列\"><a href=\"#392-判断子序列\" class=\"headerlink\" title=\"392.判断子序列\"></a>392.判断子序列</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>\n<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;\n输出：true</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;\n输出：false</code></pre>\n\n<p>题目来源：<a href=\"https://leetcode.cn/problems/is-subsequence/\">https://leetcode.cn/problems/is-subsequence/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public boolean isSubsequence(String s, String t) &#123;\n        &#x2F;&#x2F;定义分别指向两个字符串序列的指针\n        int index_s&#x3D;0;\n        int index_t&#x3D;0;\n        &#x2F;&#x2F;当匹配成功，子序列后移，匹配失败，主序列后移&#x3D;&#x3D;贪心算法\n        while(index_s&lt;s.length()&amp;&amp;index_t&lt;t.length())&#123;\n            if(s.charAt(index_s)&#x3D;&#x3D;t.charAt(index_t))&#123;\n                index_s++;\n            &#125;\n            index_t++;\n        &#125;\n        &#x2F;&#x2F;当子序列达到末尾，表示子序列匹配成功，返回true\n        if(index_s&#x3D;&#x3D;s.length())&#123;\n            return true;\n        &#125;\n        &#x2F;&#x2F;否则表示匹配失败，返回false\n        return false;\n    &#125;\n&#125;</code></pre>\n\n","text":"392.判断子序列题目描述：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 example 1: 输...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":50,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":52,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":48,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">392.判断子序列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"非递减数列","uid":"ec406ffdb14348b593a8eaccf18d5ae3","slug":"非递减数列","date":"2022-08-01T02:10:59.000Z","updated":"2022-08-01T02:13:53.891Z","comments":true,"path":"api/articles/非递减数列.json","keywords":null,"cover":null,"text":"非递减数列题目描述：665. 非递减数列难度中等681收藏分享切换为英文接收动态反馈 给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &lt;= ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":50,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":52,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":48,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"种花问题","uid":"17a5d31322fb6873ed3794c44302ea45","slug":"种花问题","date":"2022-07-30T01:41:20.000Z","updated":"2022-07-30T01:44:14.639Z","comments":true,"path":"api/articles/种花问题.json","keywords":null,"cover":null,"text":"605.种花问题题目描述：假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":50,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":52,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":48,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}