{"title":"150. 逆波兰表达式求值","uid":"b64a14a9b898433644724b2c4c472c30","slug":"150-逆波兰表达式求值","date":"2022-09-17T00:27:04.000Z","updated":"2022-09-17T00:29:56.625Z","comments":true,"path":"api/articles/150-逆波兰表达式求值.json","keywords":null,"cover":null,"content":"<h1 id=\"150-逆波兰表达式求值\"><a href=\"#150-逆波兰表达式求值\" class=\"headerlink\" title=\"150.逆波兰表达式求值\"></a>150.逆波兰表达式求值</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"150\">\n<li>逆波兰表达式求值</li>\n</ol>\n<p>根据<a href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\"> 逆波兰表示法</a>，求表达式的值。</p>\n<p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>\n<p><strong>注意</strong> 两个整数之间的除法只保留整数部分。</p>\n<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n输出：9\n解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;]\n输出：6\n解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n输出：22\n解释：该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5\n&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5\n&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5\n&#x3D; ((10 * 0) + 17) + 5\n&#x3D; (0 + 17) + 5\n&#x3D; 17 + 5\n&#x3D; 22</code></pre>\n\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; tokens.length &lt;&#x3D; 104</li>\n<li>tokens[i] 是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数</li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/evaluate-reverse-polish-notation\">https://leetcode.cn/problems/evaluate-reverse-polish-notation</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    &#x2F;**\n    如果是遍历到数字，则进站，如果遍历到运算符，则将栈顶的两个元素出栈，然后经过该运算符运算，将运算结果入栈。遍历完成后将栈顶元素出栈，该元素就是最终的运算结果\n     *&#x2F;\n    public int evalRPN(String[] tokens) &#123;\n        Deque&lt;Integer&gt; stack &#x3D; new LinkedList();\n        for (String s : tokens) &#123;\n            if (&quot;+&quot;.equals(s)) &#123;        &#x2F;&#x2F; leetcode 内置jdk的问题，不能使用&#x3D;&#x3D;判断字符串是否相等\n                stack.push(stack.pop() + stack.pop());      &#x2F;&#x2F; 注意 - 和&#x2F; 需要特殊处理\n            &#125; else if (&quot;-&quot;.equals(s)) &#123;\n                stack.push(-stack.pop() + stack.pop());\n            &#125; else if (&quot;*&quot;.equals(s)) &#123;\n                stack.push(stack.pop() * stack.pop());\n            &#125; else if (&quot;&#x2F;&quot;.equals(s)) &#123;\n                int temp1 &#x3D; stack.pop();\n                int temp2 &#x3D; stack.pop();\n                stack.push(temp2 &#x2F; temp1);\n            &#125; else &#123;\n                stack.push(Integer.valueOf(s));\n            &#125;\n        &#125;\n        return stack.pop();\n    &#125;\n&#125;</code></pre>\n\n","text":"150.逆波兰表达式求值题目描述： 逆波兰表达式求值 根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 注意 两个整数之间的除法只保留整数部分。 可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":103,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":109,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":103,"path":"api/tags/leetcode.json"},{"name":"栈和队列","slug":"栈和队列","count":6,"path":"api/tags/栈和队列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC\"><span class=\"toc-text\">150.逆波兰表达式求值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"239.滑动窗口的最大值","uid":"9087aaa078842eff85ab79f796fcf5f3","slug":"239-滑动窗口的最大值","date":"2022-09-18T05:03:58.000Z","updated":"2022-09-18T05:06:02.341Z","comments":true,"path":"api/articles/239-滑动窗口的最大值.json","keywords":null,"cover":null,"text":"239.滑动窗口的最大值题目描述： 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 example 1: 输入：nums ...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":103,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":109,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":103,"path":"api/tags/leetcode.json"},{"name":"栈和队列","slug":"栈和队列","count":6,"path":"api/tags/栈和队列.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"1047.删除字符串中所有相邻重复项","uid":"1e9d09714216aecd266bb235c84e915f","slug":"1047-删除字符串中所有相邻重复项","date":"2022-09-16T15:21:54.000Z","updated":"2022-09-16T15:23:59.161Z","comments":true,"path":"api/articles/1047-删除字符串中所有相邻重复项.json","keywords":null,"cover":null,"text":"1047.删除字符串中所有相邻重复项题目描述： 删除字符串中的所有相邻重复项 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":103,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":109,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":103,"path":"api/tags/leetcode.json"},{"name":"栈和队列","slug":"栈和队列","count":6,"path":"api/tags/栈和队列.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}