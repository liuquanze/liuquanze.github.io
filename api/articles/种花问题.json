{"title":"种花问题","uid":"17a5d31322fb6873ed3794c44302ea45","slug":"种花问题","date":"2022-07-30T01:41:20.000Z","updated":"2022-07-30T01:44:14.639Z","comments":true,"path":"api/articles/种花问题.json","keywords":null,"cover":null,"content":"<h1 id=\"605-种花问题\"><a href=\"#605-种花问题\" class=\"headerlink\" title=\"605.种花问题\"></a>605.种花问题</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>\n<p>给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1\n输出：true</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2\n输出：false</code></pre>\n\n\n\n<p>题目来源：<a href=\"https://leetcode.cn/problems/can-place-flowers/\">https://leetcode.cn/problems/can-place-flowers/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public boolean canPlaceFlowers(int[] flowerbed, int n) &#123;\n        if(flowerbed.length&#x3D;&#x3D;0)&#123;\n            return false;\n        &#125;\n        for(int i&#x3D;0;i&lt;flowerbed.length;i++)&#123;\n            &#x2F;&#x2F;遇到的情况\n            &#x2F;&#x2F;1.当前元素为0，并且后续也为0，则插入花，并减少剩余数量，i++，向后跳两格\n            &#x2F;&#x2F;2.当前元素为0，且为最后一个元素，则插入花，向后跳两格子\n            &#x2F;&#x2F;3.当前元素为1，则继续向后跳两格，因为后一个位子必定没法插入\n            &#x2F;&#x2F;4.若当前元素为0，后续为1，则跳一格，进入第三种情况\n            &#x2F;&#x2F;每次只需要判断当前元素和后一个元素，无需考虑前一个元素，并且从第一个元素开始判断\n            if(flowerbed[i]&#x3D;&#x3D;0&amp;&amp;(i+1&#x3D;&#x3D;flowerbed.length||flowerbed[i+1]&#x3D;&#x3D;0))&#123;\n                i++;\n                n--;\n            &#125;else if(flowerbed[i]&#x3D;&#x3D;1)&#123;\n                i++;\n            &#125;\n\n        &#125;\n        return n&lt;&#x3D;0? true:false;\n    &#125;\n&#125;</code></pre>\n\n","text":"605.种花问题题目描述：假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":22,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":24,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":21,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">605.种花问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"判断子序列","uid":"82a606d2417be24205d07d3a23121174","slug":"判断子序列","date":"2022-07-31T03:01:34.000Z","updated":"2022-07-31T03:03:49.790Z","comments":true,"path":"api/articles/判断子序列.json","keywords":null,"cover":null,"text":"392.判断子序列题目描述：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 example 1: 输...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":22,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":24,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":21,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"买卖股票的最佳时机2","uid":"6b879bd90cb55e176f69ea7d49b28d19","slug":"卖出股票的最佳时机2","date":"2022-07-29T02:18:33.000Z","updated":"2022-07-29T02:20:44.442Z","comments":true,"path":"api/articles/卖出股票的最佳时机2.json","keywords":null,"cover":null,"text":"122. 买卖股票的最佳时机2题目描述：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":22,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":24,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":21,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}