{"title":"不同的二叉搜索树Ⅱ","uid":"3a8637d28c1ed4973b1acb4bbd24e5f2","slug":"不同的二叉搜索树Ⅱ","date":"2022-08-12T02:59:34.000Z","updated":"2022-08-12T03:02:09.663Z","comments":true,"path":"api/articles/不同的二叉搜索树Ⅱ.json","keywords":null,"cover":null,"content":"<h1 id=\"95-不同的二叉搜索树Ⅱ\"><a href=\"#95-不同的二叉搜索树Ⅱ\" class=\"headerlink\" title=\"95.不同的二叉搜索树Ⅱ\"></a>95.不同的二叉搜索树Ⅱ</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"95\">\n<li>不同的二叉搜索树 II</li>\n</ol>\n<p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：n &#x3D; 3\n输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：n &#x3D; 1\n输出：[[1]]</code></pre>\n\n<p>提示：</p>\n<p>1&lt;&#x3D;n&lt;&#x3D;8</p>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/unique-binary-search-trees-ii/\">https://leetcode.cn/problems/unique-binary-search-trees-ii/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public List&lt;TreeNode&gt; generateTrees(int n) &#123;\n        &#x2F;&#x2F;若n&#x3D;0则直接返回一个空的列表\n        if(n&#x3D;&#x3D;0)&#123;\n            return new ArrayList&lt;TreeNode&gt;();\n        &#125;\n        &#x2F;&#x2F;递归生成二叉搜索树\n        return generateNodes(1,n);\n    &#125;\n\n    public List&lt;TreeNode&gt; generateNodes(int left,int right)&#123;\n        &#x2F;&#x2F;返回值，存放不同的头节点，（头节点包含子对象left和right，我们只管传入不同的二叉搜索树的头节点即可）\n        List&lt;TreeNode&gt; list&#x3D;new ArrayList&lt;TreeNode&gt;();\n        &#x2F;&#x2F;当left&gt;right表示左边或者右边没有节点了，返回null\n        if(left&gt;right)&#123;\n            list.add(null);\n            return list;\n        &#125;\n        &#x2F;&#x2F;循环所有的节点，将每个遍历的节点作为根节点\n        for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;\n            &#x2F;&#x2F;获取左子树和右子树的所有可能的组合\n            List&lt;TreeNode&gt; left_sub_tree&#x3D;generateNodes(left,i-1);\n            List&lt;TreeNode&gt; right_sub_tree&#x3D;generateNodes(i+1,right);\n            &#x2F;&#x2F;对根节点进行拼接。组成不同的二叉搜索树\n            for(TreeNode a:left_sub_tree)&#123;\n                for(TreeNode b:right_sub_tree)&#123;\n                    &#x2F;&#x2F;注意根节点在此处创建，因为左右子树不同代表不同的二叉搜索树\n                    TreeNode root&#x3D;new TreeNode(i);\n                    root.left&#x3D;a;\n                    root.right&#x3D;b;\n                    &#x2F;&#x2F;将该二叉搜索树存入list\n                    list.add(root);\n                &#125;\n            &#125;\n\n        &#125;\n        return list;\n\n    &#125;\n&#125;</code></pre>\n\n","text":"95.不同的二叉搜索树Ⅱ题目描述： 不同的二叉搜索树 II 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。 example 1: 输入：n &#x3D; 3 输出：[[1,null,2,n...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":74,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":77,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":73,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E2%85%A1\"><span class=\"toc-text\">95.不同的二叉搜索树Ⅱ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"1091.二进制矩阵中的最短路径","uid":"401c664502fc1c05444b73fd7436e5f7","slug":"1091-二进制矩阵中的最短路径","date":"2022-08-13T02:39:07.000Z","updated":"2022-08-13T02:45:44.716Z","comments":true,"path":"api/articles/1091-二进制矩阵中的最短路径.json","keywords":null,"cover":null,"text":"1091.二进制矩阵中的最短路径题目描述： 二进制矩阵中的最短路径 难度中等214收藏分享切换为英文接收动态反馈 给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。 二进制矩阵中的 畅通路径 是一条从 左上角 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":74,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":77,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":73,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"为运算表达式设计优先级","uid":"a2d24fc395bf8cf342e3b277c21f191b","slug":"为运算表达式设计优先级","date":"2022-08-12T02:29:37.000Z","updated":"2022-08-12T02:34:59.010Z","comments":true,"path":"api/articles/为运算表达式设计优先级.json","keywords":null,"cover":null,"text":"241.为运算表达式设计优先级题目描述： 为运算表达式设计优先级 给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。 生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":74,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":77,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":73,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}