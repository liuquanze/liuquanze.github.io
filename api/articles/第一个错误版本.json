{"title":"第一个错误版本","uid":"37fafcaad932621c324a857d69f2ce34","slug":"第一个错误版本","date":"2022-08-08T02:00:30.000Z","updated":"2022-08-08T02:10:52.932Z","comments":true,"path":"api/articles/第一个错误版本.json","keywords":null,"cover":null,"content":"<h1 id=\"278-第一个错误版本\"><a href=\"#278-第一个错误版本\" class=\"headerlink\" title=\"278.第一个错误版本\"></a>278.第一个错误版本</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><h4 id=\"278-第一个错误的版本\"><a href=\"#278-第一个错误的版本\" class=\"headerlink\" title=\"278. 第一个错误的版本\"></a>278. 第一个错误的版本</h4><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>\n<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>\n<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：n &#x3D; 5, bad &#x3D; 4\n输出：4\n解释：\n调用 isBadVersion(3) -&gt; false \n调用 isBadVersion(5) -&gt; true \n调用 isBadVersion(4) -&gt; true\n所以，4 是第一个错误的版本。</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：n &#x3D; 1, bad &#x3D; 1\n输出：1</code></pre>\n\n<p>题目来源：<a href=\"https://leetcode.cn/problems/first-bad-version/\">https://leetcode.cn/problems/first-bad-version/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\n&#x2F;&#x2F;左闭右闭区间，循环结束时left&gt;right，则此时最后一次得到的mid（即最后一次查找到的版本是没有保存的，所以需要ret变量进行保存）\n&#x2F;* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); *&#x2F;\n\npublic class Solution extends VersionControl &#123;\n    public int firstBadVersion(int n) &#123;\n        int left&#x3D;0;\n        int right&#x3D;n;\n        int ret&#x3D;-1;\n        while(left&lt;&#x3D;right)&#123;\n            int mid&#x3D;left+(right-left)&#x2F;2;\n            &#x2F;&#x2F;当前版本如果是错误版本，则当前版本可能是第一个出现错误的版本，需要暂存\n            if(isBadVersion(mid))&#123;\n                ret&#x3D;mid;\n                right&#x3D;mid-1;\n            &#125;else&#123;\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return ret;\n\n        \n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); *&#x2F;\n\npublic class Solution extends VersionControl &#123;\n    public int firstBadVersion(int n) &#123;\n        int left&#x3D;0;\n        int right&#x3D;n;\n        int ret&#x3D;-1;\n        &#x2F;&#x2F;循环的结束条件是left&#x3D;right，并且right&#x3D;最后一个mid，所以返回值也是最后一个mid&#x3D;right&#x3D;left\n        while(left&lt;right)&#123;\n            int mid&#x3D;left+(right-left)&#x2F;2;\n            &#x2F;&#x2F;左闭右开区间，循环结束条件是left&lt;right,下一轮循环是从left~right-1，右边是开区间\n            if(isBadVersion(mid))&#123;\n                &#x2F;&#x2F; ret&#x3D;mid;\n                right&#x3D;mid;\n            &#125;else&#123;\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return right;\n\n        \n    &#125;\n&#125;</code></pre>\n\n","text":"278.第一个错误版本题目描述：278. 第一个错误的版本你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":59,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":62,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":58,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">278.第一个错误版本</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">278. 第一个错误的版本</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"寻找峰值","uid":"d84518667e657cd3814bae0fb73c941b","slug":"寻找峰值","date":"2022-08-08T03:00:38.000Z","updated":"2022-08-08T03:03:05.770Z","comments":true,"path":"api/articles/寻找峰值.json","keywords":null,"cover":null,"text":"162. 寻找峰值题目描述：162. 寻找峰值峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞ 。 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":59,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":62,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":58,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"搜索旋转排序数组","uid":"ea76d2e3b8ba7df05f2a9007a5c4d57e","slug":"搜索旋转排序数组","date":"2022-08-07T02:54:15.000Z","updated":"2022-08-07T02:57:32.605Z","comments":true,"path":"api/articles/搜索旋转排序数组.json","keywords":null,"cover":null,"text":"33. 搜索旋转排序数组题目描述：33. 搜索旋转排序数组整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":59,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":62,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":58,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}