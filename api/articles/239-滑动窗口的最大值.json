{"title":"239.滑动窗口的最大值","uid":"9087aaa078842eff85ab79f796fcf5f3","slug":"239-滑动窗口的最大值","date":"2022-09-18T05:03:58.000Z","updated":"2022-09-18T05:06:02.341Z","comments":true,"path":"api/articles/239-滑动窗口的最大值.json","keywords":null,"cover":null,"content":"<h1 id=\"239-滑动窗口的最大值\"><a href=\"#239-滑动窗口的最大值\" class=\"headerlink\" title=\"239.滑动窗口的最大值\"></a>239.滑动窗口的最大值</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"239\">\n<li>滑动窗口最大值</li>\n</ol>\n<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>\n<p>返回 <em>滑动窗口中的最大值</em> 。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/sliding-window-maximum\">https://leetcode.cn/problems/sliding-window-maximum</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;自定义数组\nclass MyQueue &#123;\n    Deque&lt;Integer&gt; deque &#x3D; new LinkedList&lt;&gt;();\n    &#x2F;&#x2F;弹出元素时，比较当前要弹出的数值是否等于队列出口的数值；\n    &#x2F;&#x2F;仅有两种可能，1.要弹出的元素等于队列出口元素，那么就弹出，因为表示该元素是上一个滑动窗口的最大值，下一个滑动窗口中不包含该元素，需要新的最大值\n    &#x2F;&#x2F;2.需要弹出的元素小于队列出口元素，则不进行处理，因为对下一个滑动窗口的最大值选取没有影响\n    &#x2F;&#x2F;同时判断队列当前是否为空\n    void poll(int val) &#123;\n        if (!deque.isEmpty() &amp;&amp; val &#x3D;&#x3D; deque.peek()) &#123;\n            deque.poll();\n        &#125;\n    &#125;\n    &#x2F;&#x2F;添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出\n    &#x2F;&#x2F;保证队列元素单调递减\n    &#x2F;&#x2F;比如此时队列元素【4,2,1】，3将要入队，比1大，所以1弹出，此时队列：【4,2】，循环再次判断，3和2进行比较，3大于2，所以2弹出，此时队列【4】，再次和4比较，3小于4，跳出循环，将3加入队尾，此时队列变为【4,3】\n    void add(int val) &#123;\n        while (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123;\n            deque.removeLast();\n        &#125;\n        deque.add(val);\n    &#125;\n    &#x2F;&#x2F;队列队顶元素始终为最大值[获取队头元素，因为队列是有序的，因此队头元素是最大值，即当前滑动窗口的最大值]\n    int peek() &#123;\n        return deque.peek();\n    &#125;\n&#125;\n\nclass Solution &#123;\n    public int[] maxSlidingWindow(int[] nums, int k) &#123;\n        if (nums.length &#x3D;&#x3D; 1) &#123;\n            return nums;\n        &#125;\n        int len &#x3D; nums.length - k + 1;\n        &#x2F;&#x2F;存放结果元素的数组\n        int[] res &#x3D; new int[len];\n        int num &#x3D; 0;\n        &#x2F;&#x2F;自定义队列\n        MyQueue myQueue &#x3D; new MyQueue();\n        &#x2F;&#x2F;先将前k的元素放入队列，也就是第一个滑动窗口中的所有元素放入队列中\n        for (int i &#x3D; 0; i &lt; k; i++) &#123;\n            myQueue.add(nums[i]);\n        &#125;\n        &#x2F;&#x2F;由于add方法是自动会对插入元素进行排序的，因此当将第一个滑动窗口的元素放入队列中后，队头元素就已经是最大元素了，即第一滑动窗口的元素\n        res[num++] &#x3D; myQueue.peek();\n        &#x2F;&#x2F;开始将窗口进行滑动，即再次从第二个滑动窗口进行遍历\n        for (int i &#x3D; k; i &lt; nums.length; i++) &#123;\n            &#x2F;&#x2F;弹出上一个滑动窗口的元素，加入该滑动窗口的新元素，然后获取该滑动窗口的最大值\n            &#x2F;&#x2F;滑动窗口移除最前面的元素，移除是判断该元素是否放入队列\n            myQueue.poll(nums[i - k]);\n            &#x2F;&#x2F;滑动窗口加入最后面的元素\n            myQueue.add(nums[i]);\n            &#x2F;&#x2F;记录对应的最大值\n            res[num++] &#x3D; myQueue.peek();\n        &#125;\n        return res;\n    &#125;\n&#125;</code></pre>\n\n\n\n","text":"239.滑动窗口的最大值题目描述： 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 example 1: 输入：nums ...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":110,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":118,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":112,"path":"api/tags/leetcode.json"},{"name":"栈和队列","slug":"栈和队列","count":6,"path":"api/tags/栈和队列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC\"><span class=\"toc-text\">239.滑动窗口的最大值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"94&145&144.二叉树的中后前序遍历","uid":"ed6d09f7c666a266cc6ff445e8452d5b","slug":"94-145-144-二叉树的中后前序遍历","date":"2022-09-19T11:44:26.000Z","updated":"2022-09-19T11:51:12.740Z","comments":true,"path":"api/articles/94-145-144-二叉树的中后前序遍历.json","keywords":null,"cover":null,"text":"94&amp;145&amp;144.二叉树的中后前序遍历题目描述[中]： 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 example 1: 输入：root &#x3D; [1,null,2,3] 输出：[1,3,2] example 2: ...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":110,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":118,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":112,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"150. 逆波兰表达式求值","uid":"b64a14a9b898433644724b2c4c472c30","slug":"150-逆波兰表达式求值","date":"2022-09-17T00:27:04.000Z","updated":"2022-09-17T00:29:56.625Z","comments":true,"path":"api/articles/150-逆波兰表达式求值.json","keywords":null,"cover":null,"text":"150.逆波兰表达式求值题目描述： 逆波兰表达式求值 根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 注意 两个整数之间的除法只保留整数部分。 可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":110,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":118,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":112,"path":"api/tags/leetcode.json"},{"name":"栈和队列","slug":"栈和队列","count":6,"path":"api/tags/栈和队列.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}