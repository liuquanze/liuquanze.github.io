{"title":"01背包理论基础","uid":"685d8df2e9e2cce46d66a453158153dc","slug":"01背包理论基础","date":"2023-01-30T04:38:37.000Z","updated":"2023-01-30T05:00:39.546Z","comments":true,"path":"api/articles/01背包理论基础.json","keywords":null,"cover":null,"content":"<h1 id=\"01背包理论基础\"><a href=\"#01背包理论基础\" class=\"headerlink\" title=\"01背包理论基础\"></a>01背包理论基础</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>\n<ol>\n<li>确定dp数组以及下标的含义</li>\n</ol>\n<p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>\n<ol start=\"2\">\n<li>确定递推公式</li>\n</ol>\n<p>再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>\n<p>那么可以有两个方向推出来dp[i][j]，</p>\n<ul>\n<li><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li>\n<li><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li>\n</ul>\n<p>所以递归公式： dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>\n<ol start=\"3\">\n<li>dp数组如何初始化</li>\n</ol>\n<p>状态转移方程 dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p>\n<p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>\n<p>那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p>\n<p>当j &gt;&#x3D; weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。</p>\n<ol start=\"4\">\n<li>确定遍历顺序</li>\n</ol>\n<p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？</strong></p>\n<p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p>\n<p>那么我先给出先遍历物品，然后遍历背包重量的代码。</p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int 01bag(int[] weight,int[] value,int bagsize)&#123;\n    &#x2F;&#x2F;创建dp数组\n    int goods&#x3D;weight.length;&#x2F;&#x2F;获取物品的数量\n    int[][] dp&#x3D;new int[goods][bagSize+1];\n    &#x2F;&#x2F;初始化dp数组\n    &#x2F;&#x2F;创建数组后，初始值均为0，dp[0][j]&#x3D;value[0],其中j&gt;&#x3D;weight[0]\n    for(int j&#x3D;weight[0];j&lt;&#x3D;bagSize;j++)&#123;\n        dp[0][j]&#x3D;value[0];\n    &#125;\n    &#x2F;&#x2F;填充dp数组,先遍历物品再遍历背包容量\n    for(int i&#x3D;0;i&lt;weight.length;i++)&#123;\n        for(int j&#x3D;1;j&lt;&#x3D;bagSize;j++)&#123;\n            &#x2F;&#x2F;如果当前遍历的背包容量小于当前物品重量，表示根本放不下物品i，则前i-1个物品能放下的最大价值就是当前情况下的最大价值\n            if(j&lt;weight[i])&#123;\n                dp[i][j]&#x3D;dp[i-1][j];\n            &#125;else&#123;\n                &#x2F;&#x2F;如果可以放下，则在两种情况下取最大值\n                dp[j][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]);\n            &#125;\n        &#125;\n    &#125;\n    return dp[goods-1][bagSize];\n&#125;</code></pre>\n\n","feature":true,"text":"01背包理论基础题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 确定dp数组以及下标的含义 对于背包问题，有一种写法， 是使用二维数组，即dp...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":113,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":122,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":13,"path":"api/tags/动态规划.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">01背包理论基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"84.柱状图中最大的矩形","uid":"5ddbb467241068095a0f1672c50c32fb","slug":"84-柱状图中最大的矩形","date":"2023-01-26T03:16:19.000Z","updated":"2023-01-26T03:18:31.822Z","comments":true,"path":"api/articles/84-柱状图中最大的矩形.json","keywords":null,"cover":null,"text":"84.柱状图中最大的矩形题目描述： 柱状图中最大的矩形 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 example 1: 输入：heights &#x3D; [2,1,5,6,2,3] ...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":113,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":122,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":13,"path":"api/tags/动态规划.json"},{"name":"leetcode","slug":"leetcode","count":115,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true}}