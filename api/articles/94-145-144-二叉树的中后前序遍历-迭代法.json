{"title":"94-145-144-二叉树的中后前序遍历-迭代法","uid":"c8b3d710ba9b825096c6638c8fc52d7d","slug":"94-145-144-二叉树的中后前序遍历-迭代法","date":"2022-09-20T12:40:17.000Z","updated":"2022-09-20T12:43:37.992Z","comments":true,"path":"api/articles/94-145-144-二叉树的中后前序遍历-迭代法.json","keywords":null,"cover":null,"content":"<h1 id=\"94-amp-145-amp-144-二叉树的中后前序遍历\"><a href=\"#94-amp-145-amp-144-二叉树的中后前序遍历\" class=\"headerlink\" title=\"94&amp;145&amp;144.二叉树的中后前序遍历\"></a>94&amp;145&amp;144.二叉树的中后前序遍历</h1><h2 id=\"题目描述-中-：\"><a href=\"#题目描述-中-：\" class=\"headerlink\" title=\"题目描述[中]：\"></a>题目描述[中]：</h2><ol start=\"94\">\n<li>二叉树的中序遍历</li>\n</ol>\n<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1,null,2,3]\n输出：[1,3,2]</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1]\n输出：[1]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/\">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p>\n<h2 id=\"题解-中-：\"><a href=\"#题解-中-：\" class=\"headerlink\" title=\"题解[中]：\"></a>题解[中]：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n\n    &#x2F;** \n    中序遍历为，左中右，所以和前序遍历不同，需要先从根节点开始，一直向左下遍历，遍历到最后一个左下结点，边遍历边入栈，当没有左孩子了，就将栈顶元素出栈，访问节点的value，并指向该节点的右孩子。\n    *&#x2F;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();\n        if(root&#x3D;&#x3D;null)\n            return result;\n        TreeNode p&#x3D;root;\n        while(p!&#x3D;null||!stack.isEmpty())&#123;\n            if(p!&#x3D;null)&#123;\n                stack.push(p);\n                p&#x3D;p.left;\n            &#125;else&#123;\n                p&#x3D;stack.pop();\n                result.add(p.val);\n                p&#x3D;p.right;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"题目描述-后-：\"><a href=\"#题目描述-后-：\" class=\"headerlink\" title=\"题目描述[后]：\"></a>题目描述[后]：</h2><ol start=\"145\">\n<li>二叉树的后序遍历</li>\n</ol>\n<p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1,null,2,3]\n输出：[3,2,1]</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1]\n输出：[1]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/binary-tree-postorder-traversal/\">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p>\n<h2 id=\"题解-后-：\"><a href=\"#题解-后-：\" class=\"headerlink\" title=\"题解[后]：\"></a>题解[后]：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;**\n    只要在先序遍历迭代法的基础上进行修改即可，先入左孩子，再入右孩子。最后遍历完成后，对得到的列表元素进行反转，即可得到后序遍历序列\n     *&#x2F;\n   public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        if(root&#x3D;&#x3D;null)\n            return result;\n        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();\n        stack.push(root);\n        while(!stack.isEmpty())&#123;\n            TreeNode node&#x3D;stack.pop();\n            result.add(node.val);\n            if(node.left!&#x3D;null) stack.push(node.left);\n            if(node.right!&#x3D;null) stack.push(node.right);\n        &#125;\n        Collections.reverse(result);\n        return result;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"题目描述-前-：\"><a href=\"#题目描述-前-：\" class=\"headerlink\" title=\"题目描述[前]：\"></a>题目描述[前]：</h2><ol start=\"144\">\n<li>二叉树的前序遍历</li>\n</ol>\n<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1,null,2,3]\n输出：[1,2,3]</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; []\n输出：[]</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1]\n输出：[1]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/binary-tree-preorder-traversal/\">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p>\n<h2 id=\"题解-前-：\"><a href=\"#题解-前-：\" class=\"headerlink\" title=\"题解[前]：\"></a>题解[前]：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;**\n    使用栈实现前序遍历，首先根节点入栈，开始循环，先出栈，访问出栈节点value，然后右孩子入栈，然后左孩子入栈，开始下一轮循环。之所以先右如，后左如，是为了保证出栈时先访问左孩子，后访问右孩子。\n     *&#x2F;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();\n        if(root&#x3D;&#x3D;null)\n            return result;\n        stack.push(root);\n        while(!stack.isEmpty())&#123;\n            TreeNode node&#x3D;stack.pop();\n            result.add(node.val);\n            if(node.right!&#x3D;null) stack.push(node.right);\n            if(node.left!&#x3D;null) stack.push(node.left);\n        &#125;\n    \n        return result;\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n","text":"94&amp;145&amp;144.二叉树的中后前序遍历题目描述[中]： 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 example 1: 输入：root &#x3D; [1,null,2,3] 输出：[1,3,2] example 2: ...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#94-amp-145-amp-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%90%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">94&amp;145&amp;144.二叉树的中后前序遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-%E4%B8%AD-%EF%BC%9A\"><span class=\"toc-text\">题目描述[中]：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-%E4%B8%AD-%EF%BC%9A\"><span class=\"toc-text\">题解[中]：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-%E5%90%8E-%EF%BC%9A\"><span class=\"toc-text\">题目描述[后]：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-%E5%90%8E-%EF%BC%9A\"><span class=\"toc-text\">题解[后]：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-%E5%89%8D-%EF%BC%9A\"><span class=\"toc-text\">题目描述[前]：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-%E5%89%8D-%EF%BC%9A\"><span class=\"toc-text\">题解[前]：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"102二叉树的层次遍历","uid":"833c2507cf941e2d538bb205a797d8ee","slug":"102二叉树的层次遍历","date":"2022-09-21T13:56:20.000Z","updated":"2022-09-21T13:58:43.623Z","comments":true,"path":"api/articles/102二叉树的层次遍历.json","keywords":null,"cover":null,"text":"102.二叉树的层次遍历题目描述： 二叉树的层序遍历 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 example 1: 输入：root &#x3D; [3,9,20,null,null,15,7] 输出：[[3],[9,20...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":110,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":118,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":112,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"94&145&144.二叉树的中后前序遍历","uid":"ed6d09f7c666a266cc6ff445e8452d5b","slug":"94-145-144-二叉树的中后前序遍历","date":"2022-09-19T11:44:26.000Z","updated":"2022-09-19T11:51:12.740Z","comments":true,"path":"api/articles/94-145-144-二叉树的中后前序遍历.json","keywords":null,"cover":null,"text":"94&amp;145&amp;144.二叉树的中后前序遍历题目描述[中]： 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 example 1: 输入：root &#x3D; [1,null,2,3] 输出：[1,3,2] example 2: ...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":110,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":118,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":112,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}