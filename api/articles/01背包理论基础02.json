{"title":"01背包理论基础02","uid":"a684fe7136f12073d2c44da23dc49f83","slug":"01背包理论基础02","date":"2023-01-31T06:31:17.000Z","updated":"2023-01-31T06:42:27.179Z","comments":true,"path":"api/articles/01背包理论基础02.json","keywords":null,"cover":null,"content":"<h1 id=\"01背包理论基础02\"><a href=\"#01背包理论基础02\" class=\"headerlink\" title=\"01背包理论基础02\"></a>01背包理论基础02</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>\n<h3 id=\"背包问题（一维数组d实现，滚动数组）\"><a href=\"#背包问题（一维数组d实现，滚动数组）\" class=\"headerlink\" title=\"背包问题（一维数组d实现，滚动数组）\"></a>背包问题（一维数组d实现，<strong>滚动数组</strong>）</h3><p>对于背包问题其实状态都是可以压缩的。</p>\n<p>在使用二维数组的时候，递推公式：dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>\n<p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] &#x3D; max(dp[i][j], dp[i][j - weight[i]] + value[i]);</strong></p>\n<p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p>\n<p>这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p>\n<p>读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。</p>\n<p><strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>\n<ol>\n<li>确定dp数组的定义</li>\n</ol>\n<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>\n<ol start=\"2\">\n<li>一维dp数组的递推公式</li>\n</ol>\n<p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p>\n<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>\n<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>\n<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>\n<p>所以递归公式为：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</code></pre>\n\n<p>可以看出相对于二维dp数组的写法，就是把dp[i] [j]中i的维度去掉了。</p>\n<ol start=\"3\">\n<li>一维dp数组如何初始化</li>\n</ol>\n<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>\n<p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>\n<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>\n<p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>\n<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>\n<ol start=\"4\">\n<li>一维dp数组遍历顺序</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">for(int i&#x3D;0;i&lt;weight.size();i++)&#123;\n    for(int j&#x3D;bagWeight;j&gt;&#x3D;weight[i];j--)&#123;\n        dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i]);\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"注意两点：\"><a href=\"#注意两点：\" class=\"headerlink\" title=\"注意两点：\"></a>注意两点：</h3><ol>\n<li>背包容量从大到小遍历：因为如果是从小到大遍历，则一件物品会被放入多次，从大到小遍历可以避免这个问题。</li>\n<li>先遍历物品再遍历背包：如果先遍历背包再遍历物品，则会导致背包最多只能放入一个物品，先遍历物品再遍历背包可以避免这个问题</li>\n</ol>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int test(int[] weight,int[] value,int bagSize)&#123;\n    int length&#x3D;weight.length;\n    &#x2F;&#x2F;定义dp数组，采用滚动数组实现，其中dp[i]表示背包容量为i时放入物品的最大价值\n    int[] dp&#x3D;new int[bagSize+1];\n    for(int i&#x3D;0;i&lt;length;i++)&#123;\n        for(int j&#x3D;bagSize;j&gt;&#x3D;weight[i];j--)&#123;\n            dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i]);\n        &#125;\n    &#125;\n    return dp[bagSize];\n    \n&#125;</code></pre>\n\n","feature":true,"text":"01背包理论基础02题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 背包问题（一维数组d实现，滚动数组）对于背包问题其实状态都是可以压缩的。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":114,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":123,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":14,"path":"api/tags/动态规划.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8002\"><span class=\"toc-text\">01背包理论基础02</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84d%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%89\"><span class=\"toc-text\">背包问题（一维数组d实现，滚动数组）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%B8%A4%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">注意两点：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LSTNet代码","uid":"21f0fb1c21f5c84a95aeb0eb674c5fc8","slug":"LSTNet代码","date":"2023-02-01T12:55:05.000Z","updated":"2023-02-01T12:59:16.178Z","comments":true,"path":"api/articles/LSTNet代码.json","keywords":null,"cover":null,"text":" tensorflow ####################################################################################################################### # End AR...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"01背包理论基础01","uid":"3a52c682a4c8facad241eff5c291da03","slug":"01背包理论基础01","date":"2023-01-30T04:38:37.000Z","updated":"2023-01-31T06:31:40.023Z","comments":true,"path":"api/articles/01背包理论基础01.json","keywords":null,"cover":null,"text":"01背包理论基础01题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 确定dp数组以及下标的含义 对于背包问题，有一种写法， 是使用二维数组，即...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":114,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":123,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":14,"path":"api/tags/动态规划.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true}}