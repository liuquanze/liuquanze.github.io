{"title":"96.不同的二叉搜索树","uid":"eea51d59bc355db9bbe09ae2654e00b2","slug":"96-不同的二叉搜索树","date":"2022-08-16T03:04:40.000Z","updated":"2022-08-16T03:06:47.875Z","comments":true,"path":"api/articles/96-不同的二叉搜索树.json","keywords":null,"cover":null,"content":"<h1 id=\"96-不同的二叉搜索树\"><a href=\"#96-不同的二叉搜索树\" class=\"headerlink\" title=\"96.不同的二叉搜索树\"></a>96.不同的二叉搜索树</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"96\">\n<li>不同的二叉搜索树</li>\n</ol>\n<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：n &#x3D; 3\n输出：5</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：n &#x3D; 1\n输出：1</code></pre>\n\n\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= n &lt;= 19</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/unique-binary-search-trees/\">https://leetcode.cn/problems/unique-binary-search-trees/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int numTrees(int n) &#123;\n        &#x2F;&#x2F;定义dp数组\n        int[] dp&#x3D;new int[n+1];\n        &#x2F;&#x2F;dp的初始值：当有0个节点时，看作一个空的二叉树，dp[0]&#x3D;1；当有一个节点时，dp[1]&#x3D;1;\n        dp[0]&#x3D;1;\n        dp[1]&#x3D;1;\n        &#x2F;&#x2F;状态公式：dp[i]+&#x3D;dp[j-1]*dp[i-j];\n        &#x2F;&#x2F;j表示当前二叉搜索树的头节点，dp[j-1]和dp[i-j]分别表示其左右子树的二叉搜索树个数\n        &#x2F;&#x2F;详情见https:&#x2F;&#x2F;gitee.com&#x2F;programmercarl&#x2F;leetcode-master&#x2F;blob&#x2F;master&#x2F;problems&#x2F;0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md\n        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;i;j++)&#123;\n                dp[i]+&#x3D;dp[j-1]*dp[i-j];\n            &#125;\n        &#125;\n        return dp[n];\n\n\n    &#125;\n&#125;</code></pre>\n\n","text":"96.不同的二叉搜索树题目描述： 不同的二叉搜索树 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 example 1: 输入：n &#x3D; 3 输出：5 example 2: 输入：n &...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":39,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":41,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":6,"path":"api/tags/动态规划.json"},{"name":"leetcode","slug":"leetcode","count":37,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\"><span class=\"toc-text\">96.不同的二叉搜索树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"01 bag","uid":"dcd5a30d05960c310201068cc050e1d7","slug":"01-bag","date":"2022-08-17T03:09:15.000Z","updated":"2022-08-17T03:11:51.217Z","comments":true,"path":"api/articles/01-bag.json","keywords":null,"cover":null,"text":"01背包问题题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":39,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":41,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":6,"path":"api/tags/动态规划.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"343.整数拆分","uid":"6d961b2ba2212b262ffda24ad1b8896a","slug":"343-整数拆分","date":"2022-08-15T02:23:02.000Z","updated":"2022-08-15T02:25:11.605Z","comments":true,"path":"api/articles/343-整数拆分.json","keywords":null,"cover":null,"text":"343.整数拆分题目描述： 整数拆分 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。 example 1: 输入: n &#x3D; 2 输出: 1 解释: 2 &#x3D; 1 + 1...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":39,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":41,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":37,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}