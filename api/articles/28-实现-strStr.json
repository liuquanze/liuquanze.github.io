{"title":"28.实现 strStr()","uid":"92bbfd2514ed32aedece3fa7e7cce0b7","slug":"28-实现-strStr","date":"2022-09-11T14:34:12.000Z","updated":"2022-09-11T14:37:46.446Z","comments":true,"path":"api/articles/28-实现-strStr.json","keywords":null,"cover":null,"content":"<h1 id=\"28-实现-strStr\"><a href=\"#28-实现-strStr\" class=\"headerlink\" title=\"28.实现 strStr()\"></a>28.实现 strStr()</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"28\">\n<li>实现 strStr()</li>\n</ol>\n<p>实现 <a href=\"https://baike.baidu.com/item/strstr/811469\">strStr()</a> 函数。</p>\n<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 <code>-1</code> 。</p>\n<p><strong>说明：</strong></p>\n<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>\n<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的 <a href=\"https://baike.baidu.com/item/strstr/811469\">strstr()</a> 以及 Java 的 <a href=\"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)\">indexOf()</a> 定义相符。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;\n输出：2</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;\n输出：-1</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li>\n<li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/\">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 方法一\nclass Solution &#123;\n    &#x2F;&#x2F;求出next数组\n    public void getNext(int[] next,String s)&#123;\n        int j&#x3D;-1;\n        next[0]&#x3D;j;\n        &#x2F;&#x2F;j指向前缀的末尾，i指向后缀的末尾\n        for(int i&#x3D;1;i&lt;next.length;i++)&#123;\n            &#x2F;&#x2F;若前缀的末尾和后缀的末尾不匹配，则将前缀的末尾进行回退\n            while(j&gt;&#x3D;0&amp;&amp;s.charAt(i)!&#x3D;s.charAt(j+1))&#123;\n                j&#x3D;next[j];\n            &#125;\n            &#x2F;&#x2F;若匹配成功，则i和j都向后移动\n            if(s.charAt(i)&#x3D;&#x3D;s.charAt(j+1))&#123;\n                j++;\n            &#125;\n            &#x2F;&#x2F;求得最大前后缀长度\n            next[i]&#x3D;j;\n        &#125;\n        \n    &#125;\n    \n    public int strStr(String haystack, String needle) &#123;\n        int[] next&#x3D;new int[needle.length()];\n        &#x2F;&#x2F;j为模式串指针\n        int j&#x3D;-1;\n        &#x2F;&#x2F;求next数组\n        getNext(next,needle);\n        &#x2F;&#x2F;i为匹配串指针\n        for(int i&#x3D;0;i&lt;haystack.length();i++)&#123;\n            &#x2F;&#x2F;若匹配失败，则模式串指针回退\n            while(j&gt;&#x3D;0&amp;&amp;haystack.charAt(i)!&#x3D;needle.charAt(j+1))&#123;\n                j&#x3D;next[j];\n            &#125;\n            &#x2F;&#x2F;匹配成功继续向后匹配\n            if(needle.charAt(j+1)&#x3D;&#x3D;haystack.charAt(i))&#123;\n                j++;\n            &#125;\n            &#x2F;&#x2F;判断模式串是否匹配成功，若j到达模式串末尾，则返回匹配成功位置\n            if(j&#x3D;&#x3D;needle.length()-1)&#123;\n                return i-needle.length()+1;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;匹配失败\n        return -1;\n    &#125;\n&#125;</code></pre>\n\n","text":"28.实现 strStr()题目描述： 实现 strStr() 实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":112,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":121,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":115,"path":"api/tags/leetcode.json"},{"name":"字符串","slug":"字符串","count":7,"path":"api/tags/字符串.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#28-%E5%AE%9E%E7%8E%B0-strStr\"><span class=\"toc-text\">28.实现 strStr()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"232.用栈实现队列","uid":"d91274a3d01b11b2d199e36958cb424f","slug":"232-用栈实现队列","date":"2022-09-12T11:50:50.000Z","updated":"2022-09-12T11:53:41.606Z","comments":true,"path":"api/articles/232-用栈实现队列.json","keywords":null,"cover":null,"text":"232.用栈实现队列题目描述： 用栈实现队列 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":112,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":121,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":115,"path":"api/tags/leetcode.json"},{"name":"栈和队列","slug":"栈和队列","count":6,"path":"api/tags/栈和队列.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"459.重复的子字符串","uid":"d3c414b58259addf0d47c58705b851eb","slug":"459-重复的子字符串","date":"2022-09-10T12:17:28.000Z","updated":"2022-09-10T12:27:25.726Z","comments":true,"path":"api/articles/459-重复的子字符串.json","keywords":null,"cover":null,"text":"459.重复的子字符串题目描述： 重复的子字符串 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 example 1: 输入: s &#x3D; &quot;abab&quot; 输出: true 解释: 可由子串 &quot;ab&quot; 重复两次...","link":"","photos":[],"count_time":{"symbolsCount":805,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":112,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":121,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":115,"path":"api/tags/leetcode.json"},{"name":"字符串","slug":"字符串","count":7,"path":"api/tags/字符串.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}