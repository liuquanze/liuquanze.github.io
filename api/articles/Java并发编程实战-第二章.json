{"title":"Java并发编程实战-第二章","uid":"d9d4098d77d12fc0df1e3b0cd1199653","slug":"Java并发编程实战-第二章","date":"2022-11-16T13:04:07.000Z","updated":"2022-11-16T13:31:45.963Z","comments":true,"path":"api/articles/Java并发编程实战-第二章.json","keywords":null,"cover":null,"content":"<h1 id=\"Java并发编程实战——第二章【线程安全性】\"><a href=\"#Java并发编程实战——第二章【线程安全性】\" class=\"headerlink\" title=\"Java并发编程实战——第二章【线程安全性】\"></a>Java并发编程实战——第二章【线程安全性】</h1><ul>\n<li>判断一个对象是否是线程安全的，取决于它是否被多个线程访问<ul>\n<li>要使得对象是线程安全的，需要采用同步机制来协同对对象的可变状态的访问。</li>\n</ul>\n</li>\n<li>当多个线程访问同一个可变的状态变量时，若没有使用合适的同步，程序可能出现错误，可使用以下三种方式修复这个问题：<ul>\n<li>不在线程之间共享该状态变量</li>\n<li>将状态变量修改为不可变的变量</li>\n<li>在访问状态变量时使用同步</li>\n</ul>\n</li>\n<li>线程安全的程序是否完全由线程安全类构成？<ul>\n<li>答案是否定的，完全由线程安全类构成的程序并不一定是线程安全的，并且在线程安全的类中也同样可以包含非线程安全的类。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-什么是线程安全性？\"><a href=\"#1-什么是线程安全性？\" class=\"headerlink\" title=\"1.什么是线程安全性？\"></a>1.什么是线程安全性？</h2><ul>\n<li>定义：<ul>\n<li>当有多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要额外的同步或协同，这个类始终都能表现出正确的行为，那么称这个类是线程安全的。</li>\n</ul>\n</li>\n<li>线程安全类中封装了必要的同步机制，因此客户端无须进一步采用同步机制</li>\n</ul>\n<h3 id=\"example-1：\"><a href=\"#example-1：\" class=\"headerlink\" title=\"example 1：\"></a>example 1：</h3><ul>\n<li>一个无状态的servlet</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ThreadSafe\npublic class StatelessFactorizer implements Servlet&#123;\n    public void service(ServletRequest req,ServletResponse resp)&#123;\n        BigInteger i&#x3D;extractFromRequest(req);\n        BigInteger[] factors&#x3D;factor(i);\n        encodeIntoResponse(resp,factors);\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li><p>上面代码块中的StatelessFactorizer是无状态的，既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。访问StatelessFactorizer的线程不会影响另一个访问同一个StatelessFactorizer的线程的计算结果，<strong>因为这两个线程并没有共享状态</strong>。就像他们在访问不同的实例。</p>\n</li>\n<li><pre><code class=\"java\">无状态的对象一定是线程安全的\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n\n\n## 2.原子性\n\n### example 2：\n\n+ 在没有同步的情况下统计已处理请求数量的Servlet\n\n&#96;&#96;&#96;java\n@NotThreadSafe\npublic class UnsafeCountingFactorizer implements Servlet&#123;\n    private long count&#x3D;0;\n    public long getCount()&#123;return count;&#125;\n    public void service(ServletRequest req,ServletResponse resp)&#123;\n        BigInteger i&#x3D;extractFromRequest(req);\n        BigInteger[] factors&#x3D;factor(i);\n        ++count;\n        encodeIntoResponse(resp,factors);\n    &#125;\n&#125;</code></pre>\n</code></pre>\n</li>\n<li><p>上面代码块中的代码是线程不安全的，在单线程环境中可以正确运行，但在多线程环境中可能会丢失更新，该错误是<strong>由于不恰当的执行时序而出现的不正确结果</strong>【也叫做：<strong>竞态条件（Race Condition）</strong>】。</p>\n</li>\n<li><p>当某个计算结果的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。【结果正确与否取决运气】</p>\n<ul>\n<li>竞态条件的本质&#x3D;&#x3D;&gt;【观察到的结果失效】</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"example-3：\"><a href=\"#example-3：\" class=\"headerlink\" title=\"example 3：\"></a>example 3：</h3><ul>\n<li>延迟初始化中的竞态条件</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@NotThreadSafe\npublic class LazyInitRace&#123;\n    private ExpensiveObject instance&#x3D;null;\n    public ExpensiveObject getInstance()&#123;\n        if(instance&#x3D;&#x3D;null)&#123;\n\t\t\tinstance&#x3D;new ExpensiveObject();\n            \n        &#125;\n        return instance;\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>和大多数的并发错误一样，竞态条件并不总是会产生错误，<strong>还需要某种不恰当的执行时序</strong>。</li>\n</ul>\n<h3 id=\"example-4：\"><a href=\"#example-4：\" class=\"headerlink\" title=\"example 4：\"></a>example 4：</h3>","text":"Java并发编程实战——第二章【线程安全性】 判断一个对象是否是线程安全的，取决于它是否被多个线程访问 要使得对象是线程安全的，需要采用同步机制来协同对对象的可变状态的访问。 当多个线程访问同一个可变的状态变量时，若没有使用合适的同步，程序可能出现错误，可使用以下三种方式修复这个...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"阅读笔记","slug":"阅读笔记","count":2,"path":"api/categories/阅读笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":107,"path":"api/tags/Java.json"},{"name":"Java并发编程实战","slug":"Java并发编程实战","count":2,"path":"api/tags/Java并发编程实战.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%90%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%91\"><span class=\"toc-text\">Java并发编程实战——第二章【线程安全性】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">1.什么是线程安全性？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-1%EF%BC%9A\"><span class=\"toc-text\">example 1：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-3%EF%BC%9A\"><span class=\"toc-text\">example 3：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#example-4%EF%BC%9A\"><span class=\"toc-text\">example 4：</span></a></li></ol></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"376.摆动序列","uid":"872b236e099a38439f77f6b1b2e6e4dd","slug":"376-摆动序列","date":"2022-12-01T15:06:49.000Z","updated":"2022-12-01T15:12:14.867Z","comments":true,"path":"api/articles/376-摆动序列.json","keywords":null,"cover":null,"text":"376.摆动序列题目描述： 摆动序列 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":102,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":107,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":101,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":7,"path":"api/tags/贪心算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"Java并发编程实战_第一章","uid":"b4ca66fa8cf36946a93ed492ada823ba","slug":"Java并发编程实战-第一章","date":"2022-11-09T15:25:33.000Z","updated":"2022-11-16T13:06:17.293Z","comments":true,"path":"api/articles/Java并发编程实战-第一章.json","keywords":null,"cover":null,"text":"Java并发编程实战——第一章【简介】1.并发简史 早期的计算机仅仅包含一个操作系统，从头到尾仅执行一个程序，并且该程序可访问计算机中所有资源 操作系统的出现使得计算机每次可以运行多个程序 不同的程序在不同的进程中运行 操作系统为每个独立运行的进程分配各种资源：内存、文件句柄、安...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"阅读笔记","slug":"阅读笔记","count":2,"path":"api/categories/阅读笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":107,"path":"api/tags/Java.json"},{"name":"Java并发编程实战","slug":"Java并发编程实战","count":2,"path":"api/tags/Java并发编程实战.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}