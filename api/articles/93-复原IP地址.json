{"title":"93.复原IP地址","uid":"2aa2b4cd6cd10ccd2f6292d5d41a250c","slug":"93-复原IP地址","date":"2022-11-05T13:47:14.000Z","updated":"2022-11-05T13:49:44.476Z","comments":true,"path":"api/articles/93-复原IP地址.json","keywords":null,"cover":null,"content":"<h1 id=\"93-复原IP地址\"><a href=\"#93-复原IP地址\" class=\"headerlink\" title=\"93.复原IP地址\"></a>93.复原IP地址</h1><h2 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h2><ol start=\"93\">\n<li>复原 IP 地址</li>\n</ol>\n<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p>\n<ul>\n<li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li>\n</ul>\n<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>\n<p>example 1：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：s &#x3D; &quot;25525511135&quot;\n输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：s &#x3D; &quot;0000&quot;\n输出：[&quot;0.0.0.0&quot;]</code></pre>\n\n<p>example 3：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：s &#x3D; &quot;101023&quot;\n输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 20</code></li>\n<li><code>s</code> 仅由数字组成</li>\n</ul>\n<p>问题来源：<a href=\"https://leetcode.cn/problems/restore-ip-addresses/description/\">https://leetcode.cn/problems/restore-ip-addresses/description/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    List&lt;String&gt; result &#x3D; new ArrayList&lt;&gt;();\n\n    public List&lt;String&gt; restoreIpAddresses(String s) &#123;\n        if (s.length() &gt; 12) return result; &#x2F;&#x2F; 算是剪枝了\n        backTrack(s, 0, 0);\n        return result;\n    &#125;\n\n    &#x2F;&#x2F; startIndex: 搜索的起始位置， pointNum:添加逗点的数量\n    private void backTrack(String s, int startIndex, int pointNum) &#123;\n        if (pointNum &#x3D;&#x3D; 3) &#123;&#x2F;&#x2F; 逗点数量为3时，分隔结束\n            &#x2F;&#x2F; 判断第四段⼦字符串是否合法，如果合法就放进result中\n            if (isValid(s,startIndex,s.length()-1)) &#123;\n                result.add(s);\n            &#125;\n            return;\n        &#125;\n        for (int i &#x3D; startIndex; i &lt; s.length(); i++) &#123;\n            if (isValid(s, startIndex, i)) &#123;\n                s &#x3D; s.substring(0, i + 1) + &quot;.&quot; + s.substring(i + 1);    &#x2F;&#x2F;在str的后⾯插⼊⼀个逗点\n                pointNum++;\n                backTrack(s, i + 2, pointNum);&#x2F;&#x2F; 插⼊逗点之后下⼀个⼦串的起始位置为i+2\n                pointNum--;&#x2F;&#x2F; 回溯\n                s &#x3D; s.substring(0, i + 1) + s.substring(i + 2);&#x2F;&#x2F; 回溯删掉逗点\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 判断字符串s在左闭⼜闭区间[start, end]所组成的数字是否合法\n    private Boolean isValid(String s, int start, int end) &#123;\n        if (start &gt; end) &#123;\n            return false;\n        &#125;\n        if (s.charAt(start) &#x3D;&#x3D; &#39;0&#39; &amp;&amp; start !&#x3D; end) &#123; &#x2F;&#x2F; 0开头的数字不合法\n            return false;\n        &#125;\n        int num &#x3D; 0;\n        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;\n            if (s.charAt(i) &gt; &#39;9&#39; || s.charAt(i) &lt; &#39;0&#39;) &#123; &#x2F;&#x2F; 遇到⾮数字字符不合法\n                return false;\n            &#125;\n            num &#x3D; num * 10 + (s.charAt(i) - &#39;0&#39;);\n            if (num &gt; 255) &#123; &#x2F;&#x2F; 如果⼤于255了不合法\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n</code></pre>\n\n\n\n","feature":true,"text":"93.复原IP地址问题描述： 复原 IP 地址 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &#39;.&#39; 分隔。 例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&q...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":95,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":98,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":94,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":8,"path":"api/tags/回溯算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">93.复原IP地址</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">问题描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"78.子集","uid":"73e62cf89f554b3cf0c0c9da24853098","slug":"78-子集","date":"2022-11-07T13:36:20.000Z","updated":"2022-11-07T13:41:29.109Z","comments":true,"path":"api/articles/78-子集.json","keywords":null,"cover":null,"text":"78.子集问题描述：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 example 1: 输入：nums &#x3D; [1,2,3] 输出：[[],[1],[2],[1,2]...","link":"","photos":[],"count_time":{"symbolsCount":961,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":95,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":98,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":94,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":8,"path":"api/tags/回溯算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"131.分割回文串","uid":"db70d191ef5306eb761eb483c7e9bb07","slug":"131-分割回文串","date":"2022-11-02T15:20:26.000Z","updated":"2022-11-02T15:25:51.208Z","comments":true,"path":"api/articles/131-分割回文串.json","keywords":null,"cover":null,"text":"131.分割回文串题目描述： 分割回文串 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 example 1： 输入：s &#x3D; &quot;aab&quot; 输出：[[&...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":95,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":98,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":94,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":8,"path":"api/tags/回溯算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true}}