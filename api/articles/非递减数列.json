{"title":"非递减数列","uid":"ec406ffdb14348b593a8eaccf18d5ae3","slug":"非递减数列","date":"2022-08-01T02:10:59.000Z","updated":"2022-08-01T02:13:53.891Z","comments":true,"path":"api/articles/非递减数列.json","keywords":null,"cover":null,"content":"<h1 id=\"非递减数列\"><a href=\"#非递减数列\" class=\"headerlink\" title=\"非递减数列\"></a>非递减数列</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><h4 id=\"665-非递减数列\"><a href=\"#665-非递减数列\" class=\"headerlink\" title=\"665. 非递减数列\"></a>665. 非递减数列</h4><p>难度中等681收藏分享切换为英文接收动态反馈</p>\n<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，请你判断在 <strong>最多</strong> 改变 <code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p>\n<p>我们是这样定义一个非递减数列的： 对于数组中任意的 <code>i</code> <code>(0 &lt;= i &lt;= n-2)</code>，总满足 <code>nums[i] &lt;= nums[i + 1]</code></p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: nums &#x3D; [4,2,3]\n输出: true\n解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: nums &#x3D; [4,2,1]\n输出: false\n解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</code></pre>\n\n\n\n<p>题目来源：<a href=\"https://leetcode.cn/problems/non-decreasing-array/\">https://leetcode.cn/problems/non-decreasing-array/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public boolean checkPossibility(int[] nums) &#123;\n        &#x2F;**\n        贪心算法：三种逆序情况\n        1.当i&#x3D;1时，与前一个元素发生逆序，则改变前一个元素的值，【4，2，5】，当遍历至2时发生逆序，将4改为2；\n        2.当i&gt;1,并且与i-1元素发生逆序时，需要查看i-2位置的元素，若i-2位置小于或者等于i位置元素，则依旧改变i-2位置元素，eg【1, 4, 2, 5】遍历至2时发生逆序，由于1&lt;2依旧是有序的，只需要改变4即可，将4改为2；\n        3.当i&gt;1,并且与i-1元素发生逆序时，需要查看i-2位置的元素，若i-2位置大于i位置元素，则此时仅改变i-1位置的元素依旧是无法实现递增的，此时只能将i位置的元素修改为i-1位置的元素。eg【3, 4, 2, 5】，此时2与4发生逆序，若仅仅修改4的值是无法实现递增的，因为3依旧是大于2的，所以只能将2修改为4实现递增。\n        总结：\n        当 nums[i] 破坏了数组的单调递增时，即 nums[i] &lt; nums[i - 1]  时，为了让数组有序，我们发现一个规律（在上面三个例子中， nums[i] 都为 2， nums[i -1] 都为 4）：\n\n如例①的情况，当 i &#x3D; 1 ，那么修改 num[i- 1] ，不要动 nums[i] ，因为nums[i]后面的元素是啥我们还不知道呢，少动它为妙。\n如例②的情况，当 i &gt; 1 时，我们应该优先考虑把 nums[i - 1] 调小到 &gt;&#x3D; nums[i - 2] 并且 &lt;&#x3D; nums[i]。同样尽量不去修改 nums[i] ，理由同上。\n如例③的情况，当 i &gt; 1 且 nums[i] &lt; nums[i - 2] 时，我们无法调整 nums[i - 1] ，我们只能调整 nums[i] 到 nums[i - 1] 。\n         *&#x2F;\n\n\n\n        &#x2F;&#x2F;用于记录改变元素的数量\n        int count&#x3D;0;\n        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;\n            &#x2F;&#x2F;发生逆序，即不是递增\n            if(nums[i]&lt;nums[i-1])&#123;\n                &#x2F;&#x2F;当逆序发生在1位置,改变前一个元素的位置\n                if(i&#x3D;&#x3D;1)&#123;\n                    nums[i-1]&#x3D;nums[i];\n                &#125;else if(nums[i]&lt;nums[i-2])&#123;    &#x2F;&#x2F;i位置元素小于i-2位置，则改变i的值\n                    nums[i]&#x3D;nums[i-1];\n                &#125;else if(nums[i]&gt;&#x3D;nums[i-2])&#123;   &#x2F;&#x2F;i位置元素大于等于i-2位置，改变i-1位置\n                    nums[i-1]&#x3D;nums[i];\n                &#125;\n                if(++count&gt;1)&#123;\n                    return false;\n                &#125;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>参考资料：<a href=\"https://leetcode.cn/problems/non-decreasing-array/solution/3-zhang-dong-tu-bang-zhu-ni-li-jie-zhe-d-06gi/\">https://leetcode.cn/problems/non-decreasing-array/solution/3-zhang-dong-tu-bang-zhu-ni-li-jie-zhe-d-06gi/</a></li>\n</ul>\n","text":"非递减数列题目描述：665. 非递减数列难度中等681收藏分享切换为英文接收动态反馈 给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &lt;= ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":110,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":116,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":110,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97\"><span class=\"toc-text\">非递减数列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97\"><span class=\"toc-text\">665. 非递减数列</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"最大子数组和","uid":"f6c56b941ed067956656bab8c3d0bb61","slug":"最大子数组和","date":"2022-08-02T01:22:15.000Z","updated":"2022-08-02T01:26:05.471Z","comments":true,"path":"api/articles/最大子数组和.json","keywords":null,"cover":null,"text":"最大子数组和题目描述： 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 example 1: 输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4] ...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":110,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":116,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":110,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"判断子序列","uid":"82a606d2417be24205d07d3a23121174","slug":"判断子序列","date":"2022-07-31T03:01:34.000Z","updated":"2022-07-31T03:03:49.790Z","comments":true,"path":"api/articles/判断子序列.json","keywords":null,"cover":null,"text":"392.判断子序列题目描述：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 example 1: 输...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":110,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":116,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":110,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}