{"title":"01 bag","uid":"dcd5a30d05960c310201068cc050e1d7","slug":"01-bag","date":"2022-08-17T03:09:15.000Z","updated":"2022-08-17T03:11:51.217Z","comments":true,"path":"api/articles/01-bag.json","keywords":null,"cover":null,"content":"<h1 id=\"01背包问题\"><a href=\"#01背包问题\" class=\"headerlink\" title=\"01背包问题\"></a>01背包问题</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>\n<p>这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？</p>\n<p>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。</p>\n<p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class bag01 &#123;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;物品重量\n        int[] weight &#x3D; &#123;1, 3, 4&#125;;\n        &#x2F;&#x2F;物品价值\n        int[] value &#x3D; &#123;15, 20, 30&#125;;\n        &#x2F;&#x2F;背包大小\n        int bagsize &#x3D; 4;\n        testweightbagproblem(weight, value, bagsize);\n    &#125;\n\n    public static void testweightbagproblem(int[] weight, int[] value, int bagsize)&#123;\n        &#x2F;&#x2F;创建dp数组\n        int[][] dp&#x3D;new int[weight.length][bagsize+1];\n        &#x2F;&#x2F;对dp数组进行初始化\n        &#x2F;*\n        * 对dp数组的第一行进行初始化，dp[i][j]表示的是容量为j的背包，前i个物品能获得的最大价值\n        * 第一行是指将第0个物品放入不同的容量0~bagsize的背包的最大价值，其实也就是看第0个物品可不可以放入背包中，如果可以则将dp[0][j]设置为value[0]即可\n        * ，若j&lt;weight[0]则表示第0个物品放不进容量为j的背包，则容量为j的背包的价值只能是0，所以下方的j从weight[0]开始遍历，因为j&lt;weight[0]时，dp[0][j]&#x3D;0\n        * *&#x2F;\n        for(int j&#x3D;weight[0];j&lt;&#x3D;bagsize;j++)&#123;\n            dp[0][j]&#x3D;value[0];\n        &#125;\n\n        &#x2F;&#x2F;状态转换公式\n        &#x2F;*\n        * 先遍历物品i&#x3D;1;i&lt;&#x3D;weight.length，再遍历背包容量j&#x3D;1;j&lt;&#x3D;bagsize\n        * 1.当背包容量小于当前的物品的重量j&lt;weight[i]时,表示物品i无法放进此时容量为j的背包，所以dp[i][j]：容量为j的背包在i个物品中所能获得的最大价值等于容量为j的背包\n        * 在i-1个物品中所能获得的最大价值；也就是不放入第i个物品的最大价值（因为背包容量不够嘛）\n        * 2.当背包容量大于等于当前物品的重量j&gt;&#x3D;weight[i]时，表示物品可以放进此时容量为j的背包，因此出现两种选择：\n        *   （1）将物品i放进背包\n        *   （2）不将物品i放进背包，\n        * 至于选择放还是不放，就需要分别计算放入物品i和不放入物品i的背包的价值并选择能使背包价值最大化的方式（通俗的说，放入i和不放入i，谁能使背包的价值大，就选谁）\n        * 所以dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i]+value[i]])\n        * 注：这里的dp[i-1][j-weight[i]表示的是容量为j-weight[j]的背包在0~i-1所能获得最大价值，之所以j-weight[j]就是要预留出物品i的空间，所以p[i-1][j-weight[i]也可以说是为物品i\n        * 预留出背包空间后的最大可以获得的价值，再然后加上value[i]就可以得到放入物品i后，容量为j的背包所能获得的最大价值。\n        *\n        * 重新梳理：\n        * （1）如果物品i可以放入背包（背包容量允许），则分别比较物品放入前后的背包价值，选取最大值\n        * （2）若物品i不可以放入背包（背包容量不允许），则选择不放入i时的最大价值。\n        * *&#x2F;\n        for(int i&#x3D;1;i&lt;weight.length;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;bagsize;j++)&#123;\n                if(j&lt;weight[i-1])&#123;\n                    dp[i][j]&#x3D;dp[i-1][j];\n                &#125;else&#123;\n                    dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i-1]]+value[i-1]);\n                &#125;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;输出dp数组查看运行结果\n        for (int i&#x3D;0;i&lt;weight.length;i++)&#123;\n            for(int j&#x3D;0;j&lt;&#x3D;bagsize;j++)&#123;\n                System.out.printf(dp[i][j]+&quot; &quot;);\n            &#125;\n            System.out.printf(&quot;\\n&quot;);\n        &#125;\n\n\n    &#125;\n&#125;\n</code></pre>\n\n","text":"01背包问题题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":102,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":108,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":7,"path":"api/tags/动态规划.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">01背包问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"977.有序数组的平方","uid":"15073fb27fca9b3ab97a6db7836c4a4d","slug":"977-有序数组的平方","date":"2022-08-17T22:41:02.000Z","updated":"2022-08-17T22:46:02.610Z","comments":true,"path":"api/articles/977-有序数组的平方.json","keywords":null,"cover":null,"text":"977.有序数组的平方题目描述： 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 example 1: 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":102,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":108,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":102,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"96.不同的二叉搜索树","uid":"eea51d59bc355db9bbe09ae2654e00b2","slug":"96-不同的二叉搜索树","date":"2022-08-16T03:04:40.000Z","updated":"2022-08-16T03:06:47.875Z","comments":true,"path":"api/articles/96-不同的二叉搜索树.json","keywords":null,"cover":null,"text":"96.不同的二叉搜索树题目描述： 不同的二叉搜索树 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 example 1: 输入：n &#x3D; 3 输出：5 example 2: 输入：n &...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":102,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":108,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":7,"path":"api/tags/动态规划.json"},{"name":"leetcode","slug":"leetcode","count":102,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}