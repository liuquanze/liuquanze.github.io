{"title":"找到第k大的元素——快速排序","uid":"124012fd83870b9daa284761d75f9454","slug":"FindKthLargest","date":"2022-07-21T00:24:42.000Z","updated":"2022-07-21T00:56:06.830Z","comments":true,"path":"api/articles/FindKthLargest.json","keywords":null,"cover":null,"content":"<h4 id=\"Kth-Largest-Element-in-an-Array——快速排序\"><a href=\"#Kth-Largest-Element-in-an-Array——快速排序\" class=\"headerlink\" title=\"Kth Largest Element in an Array——快速排序\"></a>Kth Largest Element in an Array——快速排序</h4><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><p>Given an integer array nums and an integer k, return the kth largest element in the array.</p>\n<p>Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>\n<p>You must solve it in O(n) time complexity.</p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int findKthLargest(int[] nums, int k) &#123;\n        return fastSelection(nums,0,nums.length-1,k-1);\t&#x2F;&#x2F;注意，传入的参数是nums.length-1和k-1\n    &#125;\n\t&#x2F;&#x2F;快速排序，递归\n    public int fastSelection(int[] nums,int start,int end,int kth)&#123;\n        &#x2F;&#x2F;划分并确定一个元素的位置\n        int cur&#x3D;partition(nums,start,end);\n        &#x2F;&#x2F;若为第k个元素，则直接返回\n        if(cur&#x3D;&#x3D;kth)&#123;\n            return nums[cur];\n        &#125;else if(cur&lt;kth)&#123;\t\t&#x2F;&#x2F;否则对右边区域进行划分\n            return fastSelection(nums,cur+1,end,kth);\n        &#125;else&#123;\t\t\t\t&#x2F;&#x2F;对左边区域进行划分\n            return fastSelection(nums,start,cur-1,kth);\n        &#125;\n    &#125;\n\t&#x2F;&#x2F;划分区间\n    public int partition(int[] nums,int start,int end)&#123;\n       \t &#x2F;&#x2F;随机选择枢轴元素\n        int pivot&#x3D;start+(int)(Math.random()*(end-start+1));\n        &#x2F;&#x2F;将枢轴元素调换至右边界\n        swap(nums,pivot,end);\n        &#x2F;&#x2F;双指针index和i用于进行划分，确定枢轴元素的最终位置\n        int index&#x3D;start-1;\n        for(int i&#x3D;start;i&lt;end;i++)&#123;\n            if(nums[i]&gt;nums[end])&#123;\n                swap(nums,i,++index);\n            &#125;\n        &#125;\n        swap(nums,++index,end);\n        return index;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n\n&#125;</code></pre>\n\n\n\n","text":"Kth Largest Element in an Array——快速排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array. Note th...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":34,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":36,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":33,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Kth-Largest-Element-in-an-Array%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">Kth Largest Element in an Array——快速排序</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Kth Largest Element in an Array——堆排序","uid":"b11e16d08ad1418b22f0f4722489b2fa","slug":"FindKthLargest01","date":"2022-07-21T00:45:06.000Z","updated":"2022-07-21T00:56:37.025Z","comments":true,"path":"api/articles/FindKthLargest01.json","keywords":null,"cover":null,"text":"Kth Largest Element in an Array——堆排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array. Note tha...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":34,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":36,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":33,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"PriorityQueue的简单使用","uid":"2233f52546249f8733475a932932ac4d","slug":"PriorityQueue_SimpleUse","date":"2022-07-20T03:10:24.000Z","updated":"2022-07-20T03:58:46.939Z","comments":true,"path":"api/articles/PriorityQueue_SimpleUse.json","keywords":null,"cover":null,"text":"Java中的优先队列Java中的PriorityQueue默认是小顶堆，逻辑上是堆，物理上是数组，每次取出的元素是最小的。【可以通过比较器的方式传入不同的比较规则】 特点： 实现了Queue接口 不允许放入null元素 插入方法： add()和offer(),前者插入失败抛出异常...","link":"","photos":[],"count_time":{"symbolsCount":640,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":36,"path":"api/tags/Java.json"},{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}