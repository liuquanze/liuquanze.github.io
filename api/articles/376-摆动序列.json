{"title":"376.摆动序列","uid":"872b236e099a38439f77f6b1b2e6e4dd","slug":"376-摆动序列","date":"2022-12-01T15:06:49.000Z","updated":"2022-12-01T15:12:14.867Z","comments":true,"path":"api/articles/376-摆动序列.json","keywords":null,"cover":null,"content":"<h1 id=\"376-摆动序列\"><a href=\"#376-摆动序列\" class=\"headerlink\" title=\"376.摆动序列\"></a>376.摆动序列</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"376\">\n<li>摆动序列</li>\n</ol>\n<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>\n<ul>\n<li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li>\n<li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>\n</ul>\n<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>\n<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [1,7,4,9,2,5]\n输出：6\n解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [1,17,5,10,13,15,10,5,16,8]\n输出：7\n解释：这个序列包含几个长度为 7 摆动序列。\n其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [1,2,3,4,5,6,7,8,9]\n输出：2</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/wiggle-subsequence/description/\">https://leetcode.cn/problems/wiggle-subsequence/description/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int wiggleMaxLength(int[] nums) &#123;\n        if(nums.length&lt;&#x3D;1)&#123;\n            return nums.length;\n        &#125;\n        &#x2F;&#x2F;当前差值\n        int cur&#x3D;0;\n        &#x2F;&#x2F;上一个差值\n        int pre&#x3D;0;\n        &#x2F;&#x2F;默认最右侧元素即为一个序列\n        int top&#x3D;1;\n        for(int i&#x3D;0;i&lt;nums.length-1;i++)&#123;\n            cur&#x3D;nums[i+1]-nums[i];\n            &#x2F;&#x2F;仅当cur为峰值或者cur为峰值的后一个元素时，才记录top并更新pre，略过了中间的连续递增或者递减的过程\n            if((cur&lt;0&amp;&amp;pre&gt;&#x3D;0)||(pre&lt;&#x3D;0&amp;&amp;cur&gt;0))&#123;\n                top++;\n                pre&#x3D;cur;\n            &#125;\n        &#125;\n        return top;\n\n    &#125;\n&#125;</code></pre>\n\n","feature":true,"text":"376.摆动序列题目描述： 摆动序列 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":97,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":102,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":96,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":2,"path":"api/tags/贪心算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">376.摆动序列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Java并发编程实战-第二章","uid":"d9d4098d77d12fc0df1e3b0cd1199653","slug":"Java并发编程实战-第二章","date":"2022-11-16T13:04:07.000Z","updated":"2022-11-16T13:31:45.963Z","comments":true,"path":"api/articles/Java并发编程实战-第二章.json","keywords":null,"cover":null,"text":"Java并发编程实战——第二章【线程安全性】 判断一个对象是否是线程安全的，取决于它是否被多个线程访问 要使得对象是线程安全的，需要采用同步机制来协同对对象的可变状态的访问。 当多个线程访问同一个可变的状态变量时，若没有使用合适的同步，程序可能出现错误，可使用以下三种方式修复这个...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"阅读笔记","slug":"阅读笔记","count":2,"path":"api/categories/阅读笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":102,"path":"api/tags/Java.json"},{"name":"Java并发编程实战","slug":"Java并发编程实战","count":2,"path":"api/tags/Java并发编程实战.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true}}