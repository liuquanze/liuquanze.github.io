{"title":"40.组合总和Ⅱ","uid":"4363deb7c8d6dd57ce4b7c0757c5e038","slug":"40-组合总和Ⅱ","date":"2022-10-31T15:16:14.000Z","updated":"2022-10-31T15:19:28.101Z","comments":true,"path":"api/articles/40-组合总和Ⅱ.json","keywords":null,"cover":null,"content":"<h1 id=\"40-组合总和Ⅱ\"><a href=\"#40-组合总和Ⅱ\" class=\"headerlink\" title=\"40.组合总和Ⅱ\"></a>40.组合总和Ⅱ</h1><h1 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h1><ol start=\"40\">\n<li>组合总和 II</li>\n</ol>\n<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>\n<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>\n<p><strong>注意：</strong>解集不能包含重复的组合。 </p>\n<p>【注】：和组合总和Ⅲ的区别在于，三中的元素是不重复的，而二中的元素是重复的，并且都要求组合不能重复，因此解法具有差异</p>\n<p>example 1：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,\n输出:\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]</code></pre>\n\n<p>example 2：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,\n输出:\n[\n[1,2,2],\n[5]\n]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= candidates.length &lt;= 100</code></li>\n<li><code>1 &lt;= candidates[i] &lt;= 50</code></li>\n<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/combination-sum-ii/description/\">https://leetcode.cn/problems/combination-sum-ii/description/</a></p>\n<h1 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h1><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n  LinkedList&lt;Integer&gt; path &#x3D; new LinkedList&lt;&gt;();\n  List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n  boolean[] used;\n  int sum &#x3D; 0;\n\n  public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;\n    used &#x3D; new boolean[candidates.length];\n    &#x2F;&#x2F; 加标志数组，用来辅助判断同层节点是否已经遍历\n    Arrays.fill(used, false);\n    &#x2F;&#x2F; 为了将重复的数字都放到一起，所以先进行排序\n    Arrays.sort(candidates);\n    backTracking(candidates, target, 0);\n    return ans;\n  &#125;\n\n  private void backTracking(int[] candidates, int target, int startIndex) &#123;\n    if (sum &#x3D;&#x3D; target) &#123;\n      ans.add(new ArrayList(path));\n    &#125;\n    for (int i &#x3D; startIndex; i &lt; candidates.length; i++) &#123;\n      if (sum + candidates[i] &gt; target) &#123;\n        break;\n      &#125;\n      &#x2F;&#x2F; 出现重复节点，同层的第一个节点已经被访问过，所以直接跳过\n      if (i &gt; 0 &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1] &amp;&amp; !used[i - 1]) &#123;\n        continue;\n      &#125;\n      used[i] &#x3D; true;\n      sum +&#x3D; candidates[i];\n      path.add(candidates[i]);\n      &#x2F;&#x2F; 每个节点仅能选择一次，所以从下一位开始\n      backTracking(candidates, target, i + 1);\n      used[i] &#x3D; false;\n      sum -&#x3D; candidates[i];\n      path.removeLast();\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n\n\n\n","text":"40.组合总和Ⅱ题目描述： 组合总和 II 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":108,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":114,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":108,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":9,"path":"api/tags/回溯算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1\"><span class=\"toc-text\">40.组合总和Ⅱ</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"131.分割回文串","uid":"db70d191ef5306eb761eb483c7e9bb07","slug":"131-分割回文串","date":"2022-11-02T15:20:26.000Z","updated":"2022-11-02T15:25:51.208Z","comments":true,"path":"api/articles/131-分割回文串.json","keywords":null,"cover":null,"text":"131.分割回文串题目描述： 分割回文串 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 example 1： 输入：s &#x3D; &quot;aab&quot; 输出：[[&...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":108,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":114,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":108,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":9,"path":"api/tags/回溯算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"39.组合总和","uid":"053358390c8f453129938125fef59c98","slug":"39-组合总和","date":"2022-10-29T13:43:12.000Z","updated":"2022-10-29T13:45:36.737Z","comments":true,"path":"api/articles/39-组合总和.json","keywords":null,"cover":null,"text":"39.组合总和题目描述： 组合总和 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candida...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":108,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":114,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":108,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":9,"path":"api/tags/回溯算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}