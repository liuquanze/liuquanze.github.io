{"title":"450.删除二叉搜索树中的节点","uid":"4ddc27e8ab5fa8f62bf22aca925f034e","slug":"450-删除二叉搜索树中的节点","date":"2022-10-15T03:25:12.000Z","updated":"2022-10-15T03:28:21.883Z","comments":true,"path":"api/articles/450-删除二叉搜索树中的节点.json","keywords":null,"cover":null,"content":"<h1 id=\"450-删除二叉搜索树中的节点\"><a href=\"#450-删除二叉搜索树中的节点\" class=\"headerlink\" title=\"450.删除二叉搜索树中的节点\"></a>450.删除二叉搜索树中的节点</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"450\">\n<li>删除二叉搜索树中的节点</li>\n</ol>\n<p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>\n<p>一般来说，删除节点可分为两个步骤：</p>\n<ol>\n<li>首先找到需要删除的节点；</li>\n<li>如果找到了，删除它。</li>\n</ol>\n<p>example 1：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3\n输出：[5,4,6,2,null,null,7]\n解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n另一个正确答案是 [5,2,6,null,4,null,7]。</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0\n输出: [5,3,6,2,4,null,7]\n解释: 二叉树不包含值为 0 的节点</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: root &#x3D; [], key &#x3D; 0\n输出: []</code></pre>\n\n\n\n<p>提示：</p>\n<ul>\n<li>节点数的范围 <code>[0, 104]</code>.</li>\n<li><code>-105 &lt;= Node.val &lt;= 105</code></li>\n<li>节点值唯一</li>\n<li><code>root</code> 是合法的二叉搜索树</li>\n<li><code>-105 &lt;= key &lt;= 105</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/delete-node-in-a-bst/description/\">https://leetcode.cn/problems/delete-node-in-a-bst/description/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public TreeNode deleteNode(TreeNode root, int key) &#123;\n        &#x2F;&#x2F;节点为空\n        if(root&#x3D;&#x3D;null)\n            return null;\n        &#x2F;&#x2F;若节点大于待删除节点，则更新左子树\n        if(root.val&gt;key)\n            root.left&#x3D;deleteNode(root.left,key);\n        &#x2F;&#x2F;若节点小于待删除节点，则更新右子树\n        else if(root.val&lt;key)\n            root.right&#x3D;deleteNode(root.right,key);\n        &#x2F;&#x2F;当前节点就是待删除节点\n        else&#123;\n            &#x2F;&#x2F;待删除节点为叶子节点，则直接返回null\n            if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)\n                return null;\n            &#x2F;&#x2F;左孩子为空，右孩子不空，则右孩子覆盖待删除节点\n            else if(root.left&#x3D;&#x3D;null&amp;&amp;root.right!&#x3D;null)&#123;\n                root&#x3D;root.right;\n            &#x2F;&#x2F;右孩子为空，左孩子不空，则左孩子覆盖待删除节点\n            &#125;else if(root.right&#x3D;&#x3D;null&amp;&amp;root.left!&#x3D;null)&#123;\n                root&#x3D;root.left;\n            &#x2F;&#x2F;左孩子不空，右孩子不空，则将左孩子放到右子树的最左下位置，然后将待删除节点替换为右孩子\n            &#125;else&#123;\n                TreeNode temp&#x3D;root.right;\n                while(temp.left!&#x3D;null)&#123;\n                    temp&#x3D;temp.left;\n                &#125;\n                temp.left&#x3D;root.left;\n                root&#x3D;root.right;\n            &#125;\n\n        &#125;\n        return root;\n    &#125;\n\n\n&#125;</code></pre>\n\n","text":"450.删除二叉搜索树中的节点题目描述： 删除二叉搜索树中的节点 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":119,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":113,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">450.删除二叉搜索树中的节点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"669.修剪二叉搜索树","uid":"c848947e0d06736e666ae1e637df0270","slug":"669-修剪二叉搜索树","date":"2022-10-16T03:19:25.000Z","updated":"2022-10-16T03:24:18.886Z","comments":true,"path":"api/articles/669-修剪二叉搜索树.json","keywords":null,"cover":null,"text":"669.修剪二叉搜索树题目描述： 修剪二叉搜索树 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":119,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":113,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"701.二叉搜索树中的插入操作","uid":"de679446ce90a96213f1c24b7dcd05cc","slug":"701-二叉搜索树中的插入操作","date":"2022-10-12T02:51:28.000Z","updated":"2022-10-12T02:55:13.376Z","comments":true,"path":"api/articles/701-二叉搜索树中的插入操作.json","keywords":null,"cover":null,"text":"701.二叉搜索树中的插入操作题目描述： 二叉搜索树中的插入操作 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":119,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":113,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}