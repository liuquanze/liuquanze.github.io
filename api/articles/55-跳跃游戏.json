{"title":"55.跳跃游戏","uid":"533fd882f71315e5bf31b51d128773b6","slug":"55-跳跃游戏","date":"2022-12-05T13:16:58.000Z","updated":"2022-12-05T13:20:09.987Z","comments":true,"path":"api/articles/55-跳跃游戏.json","keywords":null,"cover":null,"content":"<h1 id=\"55-跳跃游戏\"><a href=\"#55-跳跃游戏\" class=\"headerlink\" title=\"55.跳跃游戏\"></a>55.跳跃游戏</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"55\">\n<li>跳跃游戏</li>\n</ol>\n<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>判断你是否能够到达最后一个下标。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [2,3,1,1,4]\n输出：true\n解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [3,2,1,0,4]\n输出：false\n解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 105</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/jump-game/description/\">https://leetcode.cn/problems/jump-game/description/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public boolean canJump(int[] nums) &#123;\n        &#x2F;&#x2F;当前可到达的最远距离\n        int cover&#x3D;0;\n        if(nums.length&#x3D;&#x3D;1)\n            return true;\n        &#x2F;&#x2F;从0到可覆盖的最远位置，这里的最远位置是根据数组元素不断更新的\n        for(int i&#x3D;0;i&lt;&#x3D;cover;i++)&#123;\n            cover&#x3D;Math.max(i+nums[i],cover);\n            if(cover&gt;&#x3D;nums.length-1)\n                return true;\n        &#125;\n        return false;\n    &#125;\n&#125;</code></pre>\n\n\n\n","feature":true,"text":"55.跳跃游戏题目描述： 跳跃游戏 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 example 1: 输入：nums &#x3D; [2,3,1,1,4] 输出：true...","link":"","photos":[],"count_time":{"symbolsCount":897,"symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":99,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":104,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":98,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":4,"path":"api/tags/贪心算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F\"><span class=\"toc-text\">55.跳跃游戏</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"53.最大子数组和","uid":"616c86b7fd44020d5709f34410a56e33","slug":"53-最大子数组和","date":"2022-12-03T14:21:26.000Z","updated":"2022-12-03T14:24:22.249Z","comments":true,"path":"api/articles/53-最大子数组和.json","keywords":null,"cover":null,"text":"53.最大子数组和题目描述： 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 example 1: 输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":99,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":104,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":98,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":4,"path":"api/tags/贪心算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true}}