{"title":"496.下一个更大元素Ⅰ","uid":"815fb5e337edfb9e9850c316ed81cdac","slug":"496-下一个更大元素Ⅰ","date":"2023-01-23T04:22:44.000Z","updated":"2023-01-23T04:25:12.781Z","comments":true,"path":"api/articles/496-下一个更大元素Ⅰ.json","keywords":null,"cover":null,"content":"<h1 id=\"496-下一个更大元素Ⅰ\"><a href=\"#496-下一个更大元素Ⅰ\" class=\"headerlink\" title=\"496.下一个更大元素Ⅰ\"></a>496.下一个更大元素Ⅰ</h1><h2 id=\"问题描述：\"><a href=\"#问题描述：\" class=\"headerlink\" title=\"问题描述：\"></a>问题描述：</h2><ol start=\"496\">\n<li>下一个更大元素 I</li>\n</ol>\n<p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p>\n<p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>\n<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>\n<p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].\n输出：[-1,3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].\n输出：[3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 2 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。下一个更大元素是 3 。\n- 4 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。</code></pre>\n\n\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>\n<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>\n<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>\n<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>\n</ul>\n<p>题目来源：</p>\n<p><a href=\"https://leetcode.cn/problems/next-greater-element-i/description/\">https://leetcode.cn/problems/next-greater-element-i/description/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;\n\n        &#x2F;&#x2F;先构造单调栈，再构造nums2对应的每个元素下一个最大元素数组，temp_nums2\n        &#x2F;&#x2F;存放的是nums2中元素的下标\n        Deque&lt;Integer&gt; stack&#x3D;new LinkedList&lt;&gt;();\n        \n        int[] temp_nums2&#x3D;new int[nums2.length];\n        for(int i&#x3D;0;i&lt;nums2.length;i++)&#123;\n            \n            while(!stack.isEmpty()&amp;&amp;nums2[i]&gt;nums2[stack.peek()])&#123;\n                temp_nums2[stack.peek()]&#x3D;nums2[i];\n                stack.pop();\n            &#125;\n            stack.push(i);\n\n        &#125;\n        &#x2F;&#x2F;根据nums1和temp_nums2构造结果数组，存放nums1中每一个元素的下一个更大元素\n        int[] res&#x3D;new int[nums1.length];\n        for(int m&#x3D;0;m&lt;nums1.length;m++)&#123;\n            for(int n&#x3D;0;n&lt;nums2.length;n++)&#123;\n                if(nums1[m]&#x3D;&#x3D;nums2[n])&#123;\n                    res[m]&#x3D;temp_nums2[n];\n                &#125;\n            &#125;\n        &#125;\n        for(int j&#x3D;0;j&lt;res.length;j++)&#123;\n            if(res[j]&#x3D;&#x3D;0)&#123;\n                res[j]&#x3D;-1;\n            &#125;\n        &#125;\n        return res;\n\n\n\n    &#125;\n&#125;</code></pre>\n\n","feature":true,"text":"496.下一个更大元素Ⅰ问题描述： 下一个更大元素 I nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。 给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":120,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":114,"path":"api/tags/leetcode.json"},{"name":"单调栈","slug":"单调栈","count":2,"path":"api/tags/单调栈.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%E2%85%A0\"><span class=\"toc-text\">496.下一个更大元素Ⅰ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">问题描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"42.接雨水","uid":"dd718835733ef3d35103f48df96ec332","slug":"42-接雨水","date":"2023-01-25T03:29:06.000Z","updated":"2023-01-25T03:33:01.335Z","comments":true,"path":"api/articles/42-接雨水.json","keywords":null,"cover":null,"text":"题目描述： 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水 example1: 输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构和算法","slug":"数据结构和算法","count":3,"path":"api/categories/数据结构和算法.json"}],"tags":[{"name":"Java","slug":"Java","count":120,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":11,"path":"api/tags/动态规划.json"},{"name":"leetcode","slug":"leetcode","count":114,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"739.每日温度","uid":"6355be0900ada8ac56a8e9489858559d","slug":"739-每日温度","date":"2023-01-22T14:05:44.000Z","updated":"2023-01-22T14:09:21.400Z","comments":true,"path":"api/articles/739-每日温度.json","keywords":null,"cover":null,"text":"739.每日温度问题描述： 每日温度 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。 example 1:...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构和算法","slug":"数据结构和算法","count":3,"path":"api/categories/数据结构和算法.json"}],"tags":[{"name":"Java","slug":"Java","count":120,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":114,"path":"api/tags/leetcode.json"},{"name":"单调栈","slug":"单调栈","count":2,"path":"api/tags/单调栈.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true}}