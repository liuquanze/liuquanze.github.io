{"title":"131.分割回文串","uid":"db70d191ef5306eb761eb483c7e9bb07","slug":"131-分割回文串","date":"2022-11-02T15:20:26.000Z","updated":"2022-11-02T15:25:51.208Z","comments":true,"path":"api/articles/131-分割回文串.json","keywords":null,"cover":null,"content":"<h1 id=\"131-分割回文串\"><a href=\"#131-分割回文串\" class=\"headerlink\" title=\"131.分割回文串\"></a>131.分割回文串</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"131\">\n<li>分割回文串</li>\n</ol>\n<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>\n<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>\n<p>example 1：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：s &#x3D; &quot;aab&quot;\n输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：s &#x3D; &quot;a&quot;\n输出：[[&quot;a&quot;]]</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 16</code></li>\n<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n<p>题目来源：</p>\n<p><a href=\"https://leetcode.cn/problems/palindrome-partitioning/description/\">https://leetcode.cn/problems/palindrome-partitioning/description/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    List&lt;List&lt;String&gt;&gt; result&#x3D;new ArrayList&lt;&gt;();\n    LinkedList&lt;String&gt; combination&#x3D;new LinkedList&lt;&gt;();\n\n    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;\n        getCombination(s,0);\n        return result;\n    &#125;\n\n    &#x2F;&#x2F;切割问题转化为组合问题\n    public void getCombination(String s,int startIndex)&#123;\n        &#x2F;&#x2F;当前元素下标超过字符串长度时，表示一次切割已经完成，将本次切割结果进行存储\n        if(startIndex&gt;&#x3D;s.length())&#123;\n            result.add(new ArrayList(combination));\n            return;\n        &#125;\n        &#x2F;&#x2F;从startIndex的位置开始切割，也就是水平位置\n        for(int i&#x3D;startIndex;i&lt;s.length();i++)&#123;\n            &#x2F;&#x2F;若当前切割子串是回文串，则进行切割，并加入组合集合，若切割下来的不是回文串，则进行下一次切割【因为每次切割必须保证是回文串】\n            if(isHuiWen(s,startIndex,i))&#123;\n                combination.add(s.substring(startIndex,i+1));\n            &#125;else&#123;\n                continue;\n            &#125;\n            &#x2F;&#x2F;对剩余子串继续切割\n            getCombination(s,i+1);\n            &#x2F;&#x2F;回溯完成，准备更换切割位置\n            combination.removeLast();\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;判断是否为回文串\n    public boolean isHuiWen(String s,int startIndex,int endIndex)&#123;\n        int i&#x3D;startIndex;\n        int j&#x3D;endIndex;\n        while(i&lt;j)&#123;\n            if(s.charAt(i)!&#x3D;s.charAt(j))&#123;\n                return false;\n            &#125;\n            i++;\n            j--;\n        &#125;\n        return true;\n    &#125;\n&#125;</code></pre>\n\n\n\n","text":"131.分割回文串题目描述： 分割回文串 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 example 1： 输入：s &#x3D; &quot;aab&quot; 输出：[[&...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":96,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":99,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":95,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":9,"path":"api/tags/回溯算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2\"><span class=\"toc-text\">131.分割回文串</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"93.复原IP地址","uid":"2aa2b4cd6cd10ccd2f6292d5d41a250c","slug":"93-复原IP地址","date":"2022-11-05T13:47:14.000Z","updated":"2022-11-05T13:49:44.476Z","comments":true,"path":"api/articles/93-复原IP地址.json","keywords":null,"cover":null,"text":"93.复原IP地址问题描述： 复原 IP 地址 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &#39;.&#39; 分隔。 例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&q...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":96,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":99,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":95,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":9,"path":"api/tags/回溯算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"40.组合总和Ⅱ","uid":"4363deb7c8d6dd57ce4b7c0757c5e038","slug":"40-组合总和Ⅱ","date":"2022-10-31T15:16:14.000Z","updated":"2022-10-31T15:19:28.101Z","comments":true,"path":"api/articles/40-组合总和Ⅱ.json","keywords":null,"cover":null,"text":"40.组合总和Ⅱ题目描述： 组合总和 II 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":96,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":99,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":95,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":9,"path":"api/tags/回溯算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}