{"title":"1005.K次取反后最大化的数组和","uid":"684490a86ab5f156b0b9d2e5dc331300","slug":"1005-K次取反后最大化的数组和","date":"2022-12-11T13:26:50.000Z","updated":"2022-12-11T13:29:08.669Z","comments":true,"path":"api/articles/1005-K次取反后最大化的数组和.json","keywords":null,"cover":null,"content":"<h1 id=\"1005-K次取反后最大化的数组和\"><a href=\"#1005-K次取反后最大化的数组和\" class=\"headerlink\" title=\"1005.K次取反后最大化的数组和\"></a>1005.K次取反后最大化的数组和</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"1005\">\n<li>K 次取反后最大化的数组和</li>\n</ol>\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p>\n<ul>\n<li>选择某个下标 <code>i</code> 并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li>\n</ul>\n<p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p>\n<p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p>\n<p>example 1：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [4,2,3], k &#x3D; 1\n输出：5\n解释：选择下标 1 ，nums 变为 [4,-2,3] 。</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [3,-1,0,2], k &#x3D; 3\n输出：6\n解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [2,-3,-1,5,-4], k &#x3D; 2\n输出：13\n解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n<li><code>1 &lt;= k &lt;= 104</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/\">https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int largestSumAfterKNegations(int[] nums, int K) &#123;\n        &#x2F;&#x2F;首先将最小的负数转为正数，即可实现数据组之和最大，若所有的数已经变为正数后，k依旧大于0，则将最小的正数变为负数，此时可以获得数组之和的最大值\n    \t&#x2F;&#x2F; 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小\n\tnums &#x3D; IntStream.of(nums)\n\t\t     .boxed()\n\t\t     .sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1))\n\t\t     .mapToInt(Integer::intValue).toArray();\n\tint len &#x3D; nums.length;\t    \n\tfor (int i &#x3D; 0; i &lt; len; i++) &#123;\n\t    &#x2F;&#x2F;从前向后遍历，遇到负数将其变为正数，同时K--\n\t    if (nums[i] &lt; 0 &amp;&amp; K &gt; 0) &#123;\n\t    \tnums[i] &#x3D; -nums[i];\n\t    \tK--;\n\t    &#125;\n\t&#125;\n\t&#x2F;&#x2F; 如果K还大于0，那么反复转变数值最小的元素，将K用完\n\n\tif (K % 2 &#x3D;&#x3D; 1) nums[len - 1] &#x3D; -nums[len - 1];\n\treturn Arrays.stream(nums).sum();\n\n    &#125;\n&#125;</code></pre>\n\n","text":"1005.K次取反后最大化的数组和题目描述： K 次取反后最大化的数组和 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组： 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。 以这种方...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":119,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":113,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":15,"path":"api/tags/贪心算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1005-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C\"><span class=\"toc-text\">1005.K次取反后最大化的数组和</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"134.加油站","uid":"d6d0de907a6cde5432aeecaa7255f84f","slug":"134-加油站","date":"2022-12-16T14:02:43.000Z","updated":"2022-12-16T14:05:41.723Z","comments":true,"path":"api/articles/134-加油站.json","keywords":null,"cover":null,"text":"134.加油站题目描述： 加油站 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 ...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":119,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":113,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":15,"path":"api/tags/贪心算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"45.跳跃游戏Ⅱ","uid":"ba77919bcc2d7461bb50d4a40ab33900","slug":"45-跳跃游戏Ⅱ","date":"2022-12-07T13:21:22.000Z","updated":"2022-12-07T13:23:20.934Z","comments":true,"path":"api/articles/45-跳跃游戏Ⅱ.json","keywords":null,"cover":null,"text":"45.跳跃游戏Ⅱ题目描述： 跳跃游戏 II 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 假设你总是可以到达数组的最后一个位置。 example1 ： 输入...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":119,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":113,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":15,"path":"api/tags/贪心算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}