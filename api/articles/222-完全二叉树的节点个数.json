{"title":"222.完全二叉树的节点个数","uid":"576c683ca9399adeb9bce96faa97dac2","slug":"222-完全二叉树的节点个数","date":"2022-09-25T14:17:21.000Z","updated":"2022-09-25T14:21:06.711Z","comments":true,"path":"api/articles/222-完全二叉树的节点个数.json","keywords":null,"cover":null,"content":"<h1 id=\"222-完全二叉树的节点个数\"><a href=\"#222-完全二叉树的节点个数\" class=\"headerlink\" title=\"222.完全二叉树的节点个数\"></a>222.完全二叉树的节点个数</h1><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"222\">\n<li>完全二叉树的节点个数</li>\n</ol>\n<p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>\n<p><a href=\"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin\">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1,2,3,4,5,6]\n输出：6</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; []\n输出：0</code></pre>\n\n<p>example 3:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [1]\n输出：1</code></pre>\n\n<p>提示：</p>\n<ul>\n<li>树中节点的数目范围是<code>[0, 5 * 104]</code></li>\n<li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li>\n<li>题目数据保证输入的树是 <strong>完全二叉树</strong></li>\n</ul>\n<p>题目来源：</p>\n<p><a href=\"https://leetcode.cn/problems/count-complete-tree-nodes/\">https://leetcode.cn/problems/count-complete-tree-nodes/</a></p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;解法1：层序遍历，记录节点个数\nclass Solution &#123;\n    &#x2F;&#x2F;迭代法\n    public int countNodes(TreeNode root) &#123;\n        if(root&#x3D;&#x3D;null)\n            return 0;\n        int node_count&#x3D;0;\n        Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();\n        queue.offer(root);\n        while(!queue.isEmpty())&#123;\n            TreeNode temp&#x3D;queue.poll();\n            node_count++;\n            if(temp.left!&#x3D;null) queue.offer(temp.left);\n            if(temp.right!&#x3D;null) queue.offer(temp.right);\n        &#125;\n        return node_count;\n\n    &#125;\n&#125;\n\n&#x2F;&#x2F;解法2：利用二叉树性质\nclass Solution &#123;\n    &#x2F;&#x2F;利用完全二叉树的性质，使用递归，查看左遍历深度left_depth，和右深度right_depth,若左右深度相同，则该二叉树为完全二叉树，返回节点个数2^depth-1\n    &#x2F;&#x2F;若左右深度不同，则递归左孩子，求出左子树的节点个数，递归右子树，求出右子树的节点个数，再加上1为根节点。\n    public int countNodes(TreeNode root) &#123;\n        if(root&#x3D;&#x3D;null)\n            return 0;\n        TreeNode left_child&#x3D;root.left;\n        TreeNode right_child&#x3D;root.right;\n        int left_depth&#x3D;0;\n        int right_depth&#x3D;0;\n        while(left_child!&#x3D;null)&#123;\n            left_child&#x3D;left_child.left;\n            left_depth++;\n        &#125;\n        \n        System.out.println(left_depth);\n        while(right_child!&#x3D;null)&#123;\n            right_child&#x3D;right_child.right;\n            right_depth++;\n        &#125;\n        System.out.println(right_depth);\n        &#x2F;&#x2F; 若左右深度相同，则该二叉树为完全二叉树，返回节点个数2^depth-1\n        if(right_depth&#x3D;&#x3D;left_depth)&#123;\n            return (2&lt;&lt;right_depth)-1;\n        &#125;\n        else&#123;\n            &#x2F;&#x2F; 若左右深度不同，则递归左孩子，求出左子树的节点个数，递归右子树，求出右子树的节点个数，再加上1为根节点。\n            return countNodes(root.right)+countNodes(root.left)+1;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n","text":"222.完全二叉树的节点个数题目描述： 完全二叉树的节点个数 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":72,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":75,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":71,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":11,"path":"api/tags/二叉树.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0\"><span class=\"toc-text\">222.完全二叉树的节点个数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"110.平衡二叉树","uid":"21a7b5849c8515778a333234cc58b5b6","slug":"110-平衡二叉树","date":"2022-09-27T14:53:38.000Z","updated":"2022-09-27T14:56:16.541Z","comments":true,"path":"api/articles/110-平衡二叉树.json","keywords":null,"cover":null,"text":"110.平衡二叉树题目描述： 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 example 1: 输入：root &#x3D; [3,9,20,null,null,...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":72,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":75,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":71,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":11,"path":"api/tags/二叉树.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"111.二叉树的最小深度","uid":"5e70057312954f6211ec72bb65eb479c","slug":"111-二叉树的最小深度","date":"2022-09-24T14:45:07.000Z","updated":"2022-09-24T14:55:20.004Z","comments":true,"path":"api/articles/111-二叉树的最小深度.json","keywords":null,"cover":null,"text":"111.二叉树的最小深度问题描述： 二叉树的最小深度 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 example 1: 输入：root &#x3D; [3,9,20,null,null,15,7...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":72,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":75,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":71,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":11,"path":"api/tags/二叉树.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}