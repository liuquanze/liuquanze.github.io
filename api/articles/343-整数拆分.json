{"title":"343.整数拆分","uid":"6d961b2ba2212b262ffda24ad1b8896a","slug":"343-整数拆分","date":"2022-08-15T02:23:02.000Z","updated":"2022-08-15T02:25:11.605Z","comments":true,"path":"api/articles/343-整数拆分.json","keywords":null,"cover":null,"content":"<h2 id=\"343-整数拆分\"><a href=\"#343-整数拆分\" class=\"headerlink\" title=\"343.整数拆分\"></a>343.整数拆分</h2><h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><ol start=\"343\">\n<li>整数拆分</li>\n</ol>\n<p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>\n<p>返回 <em>你可以获得的最大乘积</em> 。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: n &#x3D; 2\n输出: 1\n解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: n &#x3D; 10\n输出: 36\n解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</code></pre>\n\n<p>提示：</p>\n<ul>\n<li><code>2 &lt;= n &lt;= 58</code></li>\n</ul>\n<p>题目来源：<a href=\"https://leetcode.cn/problems/integer-break/\">https://leetcode.cn/problems/integer-break/</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解:\"></a>题解:</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int integerBreak(int n) &#123;\n        &#x2F;&#x2F;参数是否合法，当n&#x3D;0 or 1的时候无法进行拆分\n        if(n&#x3D;&#x3D;0||n&#x3D;&#x3D;1)&#123;\n           return 0;\n        &#125;\n        &#x2F;&#x2F;定义dp数组，dp[i]表示的是给定i时可以获得的最大化乘积\n        int[] dp&#x3D;new int[n+1];\n        &#x2F;&#x2F;dp数组初始化，直接从dp[2]开始初始化，因为i&#x3D;1和0是没有意义的\n        dp[2]&#x3D;1;\n        &#x2F;&#x2F;对dp数组进行遍历，确定状态转换公式：\n        &#x2F;*\n            dp[i]可以通过两个公式得到，其中j从1到i-1\n                1.j*(i-j)\n                2.j*dp[i-j]\n                j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。\n                如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。\n                所以递推公式：dp[i] &#x3D; max(&#123;dp[i], (i - j) * j, dp[i - j] * j&#125;);\n            那么在取最大值的时候，为什么还要比较dp[i]呢？\n                因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。\n        *&#x2F;\n        for(int i&#x3D;3;i&lt;&#x3D;n;i++)&#123;\n            for(int j&#x3D;1;j&lt;i-1;j++)&#123;\n                dp[i]&#x3D;Math.max(dp[i],Math.max((j*(i-j)),j*dp[i-j]));\n            &#125;\n        &#125;\n        return dp[n];\n\n\n\n    &#125;\n&#125;</code></pre>\n\n","text":"343.整数拆分题目描述： 整数拆分 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。 example 1: 输入: n &#x3D; 2 输出: 1 解释: 2 &#x3D; 1 + 1...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":69,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":72,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":68,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86\"><span class=\"toc-text\">343.整数拆分</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3\"><span class=\"toc-text\">题解:</span></a></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"96.不同的二叉搜索树","uid":"eea51d59bc355db9bbe09ae2654e00b2","slug":"96-不同的二叉搜索树","date":"2022-08-16T03:04:40.000Z","updated":"2022-08-16T03:06:47.875Z","comments":true,"path":"api/articles/96-不同的二叉搜索树.json","keywords":null,"cover":null,"text":"96.不同的二叉搜索树题目描述： 不同的二叉搜索树 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 example 1: 输入：n &#x3D; 3 输出：5 example 2: 输入：n &...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":69,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":72,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":7,"path":"api/tags/动态规划.json"},{"name":"leetcode","slug":"leetcode","count":68,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"63.不同路径Ⅱ","uid":"4c356b6b38bff815cbd4488ea4093633","slug":"63-不同路径Ⅱ","date":"2022-08-14T02:53:19.000Z","updated":"2022-08-14T02:55:56.829Z","comments":true,"path":"api/articles/63-不同路径Ⅱ.json","keywords":null,"cover":null,"text":"63.不同路径Ⅱ题目描述： 不同路径 II 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":69,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":72,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":68,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}