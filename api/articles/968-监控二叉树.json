{"title":"968.监控二叉树","uid":"5898b23515666bc1eaf955d4bf31da9d","slug":"968-监控二叉树","date":"2022-12-27T13:07:30.000Z","updated":"2022-12-27T13:10:31.240Z","comments":true,"path":"api/articles/968-监控二叉树.json","keywords":null,"cover":null,"content":"<h1 id=\"968-监控二叉树\"><a href=\"#968-监控二叉树\" class=\"headerlink\" title=\"968.监控二叉树\"></a>968.监控二叉树</h1><h2 id=\"1-问题描述：\"><a href=\"#1-问题描述：\" class=\"headerlink\" title=\"1.问题描述：\"></a>1.问题描述：</h2><ol start=\"968\">\n<li>监控二叉树</li>\n</ol>\n<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>\n<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>\n<p>计算监控树的所有节点所需的最小摄像头数量。</p>\n<p>example 1:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：[0,0,null,0,0]\n输出：1\n解释：如图所示，一台摄像头足以监控所有节点。</code></pre>\n\n<p>example 2:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：[0,0,null,0,null,0,null,null,0]\n输出：2\n解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</code></pre>\n\n<p>提示：</p>\n<ol>\n<li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li>\n<li>每个节点的值都是 0。</li>\n</ol>\n<p>题目来源：</p>\n<p><a href=\"https://leetcode.cn/problems/binary-tree-cameras/\">https://leetcode.cn/problems/binary-tree-cameras/</a></p>\n<h2 id=\"2-题解：\"><a href=\"#2-题解：\" class=\"headerlink\" title=\"2.题解：\"></a>2.题解：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    int res&#x3D;0;\n    public int minCameraCover(TreeNode root) &#123;\n        &#x2F;&#x2F;根节点不一定被覆盖，需要检查一下\n        if(minCamera(root)&#x3D;&#x3D;0)&#123;\n            res++;\n        &#125;\n        return res;\n    &#125;\n\n    &#x2F;**\n        若未覆盖，return 0\n        若有相机，return 1\n        若已覆盖，return 2\n     *&#x2F;\n    public int minCamera(TreeNode root)&#123;\n        if(root&#x3D;&#x3D;null)&#123;\n            return 2;\n        &#125;\n        int left&#x3D;minCamera(root.left);\n        int right&#x3D;minCamera(root.right);\n\n        if(left&#x3D;&#x3D;2&amp;&amp;right&#x3D;&#x3D;2)&#123;\n            return 0;\n        &#125;else if(left&#x3D;&#x3D;0||right&#x3D;&#x3D;0)&#123;\n            res++;\n            return 1;\n        &#125;else&#123;\n            return 2;\n        &#125;\n        \n\n    &#125;\n&#125;</code></pre>\n\n","text":"968.监控二叉树1.问题描述： 监控二叉树 给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。 example 1: 输入：[0,0,null,0,0] 输出：1 解释：如图所示，...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":119,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":113,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":15,"path":"api/tags/贪心算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">968.监控二叉树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">1.问题描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E9%A2%98%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">2.题解：</span></a></li></ol></li></ol>","author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"509.斐波那契数列","uid":"084b6d4a3eb1719c740e694cde17f8e9","slug":"509-斐波那契数列","date":"2023-01-06T09:13:18.000Z","updated":"2023-01-06T09:16:03.037Z","comments":true,"path":"api/articles/509-斐波那契数列.json","keywords":null,"cover":null,"text":"509.斐波那契数列题目描述： 斐波那契数 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) &#x3D; 0，F(1) &#x3D; 1 F(n) &#x3D; F(n -...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":119,"path":"api/tags/Java.json"},{"name":"动态规划","slug":"动态规划","count":10,"path":"api/tags/动态规划.json"},{"name":"leetcode","slug":"leetcode","count":113,"path":"api/tags/leetcode.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}},"next_post":{"title":"714.买卖股票的最佳时机含手续费","uid":"4d703d6dd28c31c1b1d5c0868f9f4887","slug":"714-买卖股票的最佳时机含手续费","date":"2022-12-25T13:42:08.000Z","updated":"2022-12-25T13:44:28.059Z","comments":true,"path":"api/articles/714-买卖股票的最佳时机含手续费.json","keywords":null,"cover":null,"text":"714.买卖股票的最佳时机含手续费问题描述： 买卖股票的最佳时机含手续费 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":111,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":119,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":113,"path":"api/tags/leetcode.json"},{"name":"贪心算法","slug":"贪心算法","count":15,"path":"api/tags/贪心算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}}}}