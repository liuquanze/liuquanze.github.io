[{"title":"216.组合总和Ⅲ","uid":"16a3361e9df66c3302f57a7e8e439d54","slug":"216-组合总和Ⅲ","date":"2022-10-27T15:01:56.000Z","updated":"2022-10-27T15:04:35.192Z","comments":true,"path":"api/articles/216-组合总和Ⅲ.json","cover":null,"text":"216.组合总和Ⅲ题目描述： 组合总和 III 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 example 1: 输入: k &#...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":89,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":92,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":88,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":2,"path":"api/tags/回溯算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true},{"title":"77.组合","uid":"1b150da79eed14110a1dc1998320aec7","slug":"77-组合","date":"2022-10-24T15:30:39.000Z","updated":"2022-10-24T15:32:53.207Z","comments":true,"path":"api/articles/77-组合.json","cover":null,"text":"77.组合题目描述： 组合 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 example 1： 输入：n &#x3D; 4, k &#x3D; 2 输出： [ [2,4], [3,4], [2,3], [1,2]...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":89,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":92,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":88,"path":"api/tags/leetcode.json"},{"name":"回溯算法","slug":"回溯算法","count":2,"path":"api/tags/回溯算法.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true},{"title":"538. 把二叉搜索树转换为累加树","uid":"02ff0e8752a89b69920bc0868292de56","slug":"538-把二叉搜索树转换为累加树","date":"2022-10-19T14:48:37.000Z","updated":"2022-10-19T14:51:27.465Z","comments":true,"path":"api/articles/538-把二叉搜索树转换为累加树.json","cover":null,"text":"题目描述： 把二叉搜索树转换为累加树 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":89,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"Java","slug":"Java","count":92,"path":"api/tags/Java.json"},{"name":"leetcode","slug":"leetcode","count":88,"path":"api/tags/leetcode.json"},{"name":"二叉树","slug":"二叉树","count":26,"path":"api/tags/二叉树.json"}],"author":{"name":"LiuQuanZe","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"a good guy!","socials":{"github":"https://github.com/liuquanze","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_45895853","juejin":"","customs":{}}},"feature":true}]