[{"id":"c37588bd65d4c5745225faacbe87ed1b","title":"平台开发所使用的前端组件工具","content":"平台开发中所使用到的Vue工具和组件vue-prism-editor1. 实现效果\n可输入代码，并且代码语法高亮\n支持编辑模式与不可编辑模式\n\n2. 使用步骤\n安装依赖\n\nnpm install vue-prism-editor\n\n\n由于vue-prism-editor需要prismjs依赖，所以需要导入prismjs依赖\n\nnpm install prismjs\n\n\n在需要使用的页面导入组件\n\nimport &#123; PrismEditor &#125; from &quot;vue-prism-editor&quot;;\nimport &quot;vue-prism-editor&#x2F;dist&#x2F;prismeditor.min.css&quot;;\nimport &#123; highlight, languages &#125; from &quot;prismjs&#x2F;components&#x2F;prism-core&quot;;\nimport &quot;prismjs&#x2F;components&#x2F;prism-clike&quot;;\nimport &quot;prismjs&#x2F;components&#x2F;prism-javascript&quot;;\nimport &quot;prismjs&#x2F;themes&#x2F;prism-tomorrow.css&quot;; \n\n\nhtml\n\n&lt;prism-editor\n   class&#x3D;&quot;my-editor height-300&quot;\n    v-model&#x3D;&quot;code&quot;\n    aria-disabled\n    :highlight&#x3D;&quot;highlighter&quot;\n    line-numbers\n    :readonly&#x3D;&quot;false&quot;\n    :tabSize&#x3D;&quot;4&quot;\n    &gt;&lt;&#x2F;prism-editor&gt;\n\n\njavascript\n\nexport default &#123;\n\t components: &#123;\n\t \t\tPrismEditor\n\t &#125;,\n\t data: () &#x3D;&gt; (&#123;\n\t \t\tcode: &#39; &#39;,\n\t &#125;),\n\t methods: &#123;\n\t\t \thighlighter(code) &#123;\n\t\t \t\treturn highlight(code, languages.js); &#x2F;&#x2F;returns html\n\t\t \t&#125;\n\t &#125;\n&#125;;\n\n\nCSS\n\n&lt;style lang&#x3D;&quot;scss&quot;&gt;\n\t.my-editor &#123;\n\t background: #2d2d2d;\n\t color: #ccc;\n\t font-family: Fira code, Fira Mono, Consolas, Menlo, Courier, monospace;\n\t font-size: 14px;\n\t line-height: 1.5;\n\t padding: 5px;\n\t&#125;\n\t\n\t.prism-editor__textarea:focus &#123;\n\t outline: none;\n\t&#125;\n\t\n\t&#x2F;* 非必须 *&#x2F;\n\t.height-300 &#123;\n\t \theight: 300px;\n\t&#125;\n&lt;&#x2F;style&gt;\n\n参考资料：https://blog.csdn.net/c_qianxia5040/article/details/124008768\nfile-saver1. 实现效果\n可以将一段字符串保存为一个文件\n\n2. 使用步骤\n安装依赖\n\nnpm install file-saver --save\n\n\n在需要使用文件保存的页面导入依赖\n\nimport &#123; saveAs &#125; from &#39;file-saver&#39;;\n\n\n保存文件demo\n\ndownloadTxt() &#123;\n    let str_file &#x3D; &#39;文件内的字符串内容&#39;\n    let strData &#x3D; new Blob([str_file], &#123; type: &#39;text&#x2F;plain;charset&#x3D;utf-8&#39; &#125;);\n    saveAs(strData, &quot;文件.py&quot;);\n&#125;,\n\n参考资料：https://wjw1014.blog.csdn.net/article/details/124320511\n","slug":"toolsInVue","date":"2022-07-22T13:14:49.000Z","categories_index":"Web前端","tags_index":"Vue,模块","author_index":"LiuQuanZe"},{"id":"7543ffbb46b57fc1881ab7a5290f7749","title":"75.颜色排序--单指针","content":"75. 颜色排序–单指针题目描述：Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library’s sort function.\nexample 1:\nInput: nums &#x3D; [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n\nexample 2:\nInput: nums &#x3D; [2,0,1]\nOutput: [0,1,2]\n\n\n\n题解：class Solution &#123;\n    public void sortColors(int[] nums) &#123;\n        int index&#x3D;0;\n        &#x2F;&#x2F;确定0的位置\n        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;\n            if(nums[i]&#x3D;&#x3D;0)&#123;\n                swap(nums,i,index++);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;确定1的位置\n        for(int j&#x3D;index;j&lt;nums.length;j++)&#123;\n            if(nums[j]&#x3D;&#x3D;1)&#123;\n                swap(nums,j,index++);\n            &#125;\n        &#125;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n&#125;\n\n","slug":"75SortColors01","date":"2022-07-22T01:58:53.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"c4515973a08e01e147ab3e57422101e1","title":"Vue中localStorage的简单使用","content":"Vue中localStorage的简单使用localStorage主要作为本地存储来使用。下面记录三个主要用法：\n\n存储数据\n\nlocalStorage.setItem(&#39;key&#39;,&#39;value&#39;)\n\n\n取出数据\n\nlocalStorage.getItem(&#39;key&#39;)\n\n\n删除本地存储数据\n\nlocalStorage.removeItem(&#39;key&#39;)\n\n\n当存储的是json格式时，需要使用JSON.stringify()转化为字符串\n\n","slug":"localStorage","date":"2022-07-21T12:09:11.000Z","categories_index":"WEB前端","tags_index":"Vue","author_index":"LiuQuanZe"},{"id":"28e06c560ccb367ab8fe61d12d122120","title":"Sort Characters By Frequency_桶排序","content":"Sort Characters By Frequency——桶排序题目描述：Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.\nReturn the sorted string. If there are multiple answers, return any of them.\nexample 1:\nInput: s &#x3D; &quot;tree&quot;\nOutput: &quot;eert&quot;\nExplanation: &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.\nSo &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.\n\n\n\nexample 2:\nInput: s &#x3D; &quot;cccaaa&quot;\nOutput: &quot;aaaccc&quot;\nExplanation: Both &#39;c&#39; and &#39;a&#39; appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers.\nNote that &quot;cacaca&quot; is incorrect, as the same characters must be together.\n\n\n\n\n\n题解：class Solution &#123;\n    public String frequencySort(String s) &#123;\n        &#x2F;&#x2F;创建map存储字符及其出现次数\n        Map&lt;Character,Integer&gt; map&#x3D;new HashMap&lt;&gt;();\n        int max_frequency&#x3D;0;\n        int frequency&#x3D;0;\n        char ch&#x3D;&#39; &#39;;\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            ch&#x3D;s.charAt(i);\n            map.put(ch,map.getOrDefault(ch,0)+1);\n            max_frequency&#x3D;Math.max(max_frequency,map.get(ch));\n        &#125;\n\n        &#x2F;&#x2F;创建buckets，并初始化buckets\n        StringBuffer[] buckets&#x3D;new StringBuffer[max_frequency+1];\n        for(int i&#x3D;0;i&lt;max_frequency+1;i++)&#123;\n            buckets[i]&#x3D;new StringBuffer();\n        &#125;\n        for(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet())&#123;\n            ch&#x3D;entry.getKey();\n            frequency&#x3D;entry.getValue();\n            buckets[frequency].append(ch);\n        &#125;\n        &#x2F;&#x2F;创建返回值\n        StringBuffer ret&#x3D;new StringBuffer();\n        &#x2F;&#x2F;添加返回值\n        for(int i&#x3D;max_frequency;i&gt;&#x3D;1;i--)&#123;\n            StringBuffer bucket&#x3D;buckets[i];\n            for(int j&#x3D;0;j&lt;bucket.length();j++)&#123;\n                for(int k&#x3D;0;k&lt;i;k++)&#123;\n                    ret.append(bucket.charAt(j));\n                &#125;\n            &#125;\n\n        &#125;\n        return ret.toString();\n\n\n    &#125;\n&#125;\n\n","slug":"SortCharactersByFrequency-BucketSort","date":"2022-07-21T03:08:16.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"47c6968c5ee85e81112866938362b070","title":"Bucket Sort","content":"桶排序介绍：&#x2F;*\n桶排序是一个排序算法，工作原理是将数组分到有限数量的桶中。\n每个桶内再进行个别排序（可以使用其他不同的排序算法实现）。\n*&#x2F;\n\n基本步骤：\n设定一个基准，将待排序的数据按照一定的范围，从小到大平均分搭配N个桶中，此时，桶与桶之间已经排好序了，但是桶内是无序的。\n将桶内的元素进行排序\n将每个桶按照从小到大的编号，一次取出桶内元素，排序完成。\n\n","slug":"BucketSort","date":"2022-07-21T02:51:39.000Z","categories_index":"数据结构与算法","tags_index":"Java","author_index":"LiuQuanZe"},{"id":"95fb99a87b0934d93a7b934555997ee9","title":"Sort Characters By Frequency","content":"Sort Characters By Frequency题目描述：Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.\nReturn the sorted string. If there are multiple answers, return any of them.\nexample 1:\nInput: s &#x3D; &quot;tree&quot;\nOutput: &quot;eert&quot;\nExplanation: &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.\nSo &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.\n\n\n\nexample 2:\nInput: s &#x3D; &quot;cccaaa&quot;\nOutput: &quot;aaaccc&quot;\nExplanation: Both &#39;c&#39; and &#39;a&#39; appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers.\nNote that &quot;cacaca&quot; is incorrect, as the same characters must be together.\n\n\n\n\n\n题解：class Solution &#123;\n    public String frequencySort(String s) &#123;\n        &#x2F;&#x2F;创建map存储字符及其出现次数\n        Map&lt;Character,Integer&gt; map&#x3D;new HashMap&lt;&gt;();\n        char ch&#x3D;&#39; &#39;;\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            ch&#x3D;s.charAt(i);\n            map.put(ch,map.getOrDefault(ch,0)+1);\n        &#125;\n\n        &#x2F;&#x2F;创建list列表存储字符\n        List&lt;Character&gt; list&#x3D;new ArrayList&lt;&gt;(map.keySet());\n        &#x2F;&#x2F;对list进行降序排序，根据出现次数\n        Collections.sort(list,(m,n)-&gt;map.get(n)-map.get(m));\n        &#x2F;&#x2F;创建返回值\n        StringBuffer ret&#x3D;new StringBuffer();\n        &#x2F;&#x2F;将结果存储返回值\n        for(int k&#x3D;0;k&lt;list.size();k++)&#123;\n            ch&#x3D;list.get(k);\n            int frequency&#x3D;map.get(ch);\n            for(int j&#x3D;0;j&lt;frequency;j++)&#123;\n                ret.append(ch);\n            &#125;\n        &#125;\n        return ret.toString();\n\n    &#125;\n&#125;\n\n","slug":"SortCharactersByFrequency","date":"2022-07-21T02:12:13.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"457fe231ac1330559343c50bbf83f171","title":"Top K Frequent Elements","content":"Top K Frequent Elements题目描述：Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\nexample 1:\nInput: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2\nOutput: [1,2]\n\nexample 2:\nInput: nums &#x3D; [1], k &#x3D; 1\nOutput: [1]\n\n\n\n题解：class Solution &#123;\n    public int[] topKFrequent(int[] nums, int k) &#123;\n        &#x2F;&#x2F;创建map，记录元素及其出现次数\n       Map&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;Integer,Integer&gt;();\n       for(int num:nums)&#123;\n           map.put(num,map.getOrDefault(num,0)+1);\n       &#125;\n       &#x2F;&#x2F;创建结构为小根堆的优先队列，队列元素为一个大小为2的数组，[0]表示元素，[1]表示出现次数\n       &#x2F;&#x2F;这里创建优先队列时，由于队列中的元素类型并非整型，所以需要传入比较器，规定比较规则\n       PriorityQueue&lt;int[]&gt; queue&#x3D;new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;()&#123;\n           public int compare(int[] m,int[] n)&#123;\n               return m[1]-n[1];\n           &#125;\n       &#125;);\n        &#x2F;&#x2F;将map中的键值对存入优先队列\n       for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;\n           int key&#x3D;entry.getKey();\n           int value&#x3D;entry.getValue();\n           &#x2F;&#x2F;若队列已满，则需要判断是否需要替换\n           if(k&#x3D;&#x3D;queue.size())&#123;\n               &#x2F;&#x2F;若当前元素出现次数小于堆顶元素，则表示堆内元素出现次数均大于key，则无需替换，否则需要替换堆顶元素\n               if(value&gt;queue.peek()[1])&#123;\n                   queue.poll();\n                   queue.offer(new int[]&#123;key,value&#125;);\n               &#125;\n           &#125;else&#123;   &#x2F;&#x2F;若队列元素个数小于k，则直接加入队列中\n               \n               queue.offer(new int[]&#123;key,value&#125;);\n           &#125;\n       &#125;\n       &#x2F;&#x2F;将队列中维护的元素存入ret数组并返回\n        int[] ret&#x3D;new int[k];\n       for(int i&#x3D;0;i&lt;k;i++)&#123;\n           ret[i]&#x3D;queue.poll()[0];\n       &#125;\n       return ret;\n       \n\n    &#125;\n\n\n   \n&#125;\n\n\n\n\n\n","slug":"TopKFrequentElements","date":"2022-07-21T01:11:44.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"b11e16d08ad1418b22f0f4722489b2fa","title":"Kth Largest Element in an Array——堆排序","content":"Kth Largest Element in an Array——堆排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nYou must solve it in O(n) time complexity.\n题解：class Solution &#123;\n    public int findKthLargest(int[] nums, int k) &#123;\n        &#x2F;&#x2F;堆的大小\n        int heapSize&#x3D;nums.length;\n        &#x2F;&#x2F;初始建立大根堆\n        buildMaxHeap(nums,heapSize);\n        &#x2F;&#x2F;取出堆顶元素，置换到堆底，再对置换完成的堆进行调整\n        for(int i&#x3D;nums.length-1;i&gt;&#x3D;nums.length-k+1;i--)&#123;\n            swap(nums,0,i);\n            adjustHeap(nums,0,--heapSize);\n        &#125;\n        &#x2F;&#x2F;返回第k次调整的堆顶元素\n        return nums[0];\n    &#125;\n    &#x2F;&#x2F;初始建堆\n    public void buildMaxHeap(int[] nums,int heapSize)&#123;\n        &#x2F;&#x2F;找到第一个非叶节点，不断下坠\n        for(int i&#x3D;heapSize&#x2F;2;i&gt;&#x3D;0;i--)&#123;\n            adjustHeap(nums,i,heapSize);\n        &#125;\n    &#125;\n\t&#x2F;&#x2F;堆调整\n    public void adjustHeap(int[] nums,int i,int heapSize)&#123;\n        &#x2F;&#x2F;创建指针分别指向i节点的左右孩子节点\n        int left&#x3D;i*2+1;\n        int right&#x3D;i*2+2;\n        int largest&#x3D;i;\n        &#x2F;&#x2F;通过两次判断，将largest指针指向最大节点\n        if(left&lt;heapSize&amp;&amp;nums[left]&gt;nums[largest])&#123;\n            largest&#x3D;left;\n        &#125;\n        if(right&lt;heapSize&amp;&amp;nums[right]&gt;nums[largest])&#123;\n            largest&#x3D;right;\n        &#125;\n        &#x2F;&#x2F;若不符合大根堆要求，则进行调整\n        if(largest!&#x3D;i)&#123;\n            swap(nums,largest,i);\n            adjustHeap(nums,largest,heapSize);\n        &#125;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n\n&#125;\n\n\n\n","slug":"FindKthLargest01","date":"2022-07-21T00:45:06.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"124012fd83870b9daa284761d75f9454","title":"找到第k大的元素——快速排序","content":"Kth Largest Element in an Array——快速排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nYou must solve it in O(n) time complexity.\n题解：class Solution &#123;\n    public int findKthLargest(int[] nums, int k) &#123;\n        return fastSelection(nums,0,nums.length-1,k-1);\t&#x2F;&#x2F;注意，传入的参数是nums.length-1和k-1\n    &#125;\n\t&#x2F;&#x2F;快速排序，递归\n    public int fastSelection(int[] nums,int start,int end,int kth)&#123;\n        &#x2F;&#x2F;划分并确定一个元素的位置\n        int cur&#x3D;partition(nums,start,end);\n        &#x2F;&#x2F;若为第k个元素，则直接返回\n        if(cur&#x3D;&#x3D;kth)&#123;\n            return nums[cur];\n        &#125;else if(cur&lt;kth)&#123;\t\t&#x2F;&#x2F;否则对右边区域进行划分\n            return fastSelection(nums,cur+1,end,kth);\n        &#125;else&#123;\t\t\t\t&#x2F;&#x2F;对左边区域进行划分\n            return fastSelection(nums,start,cur-1,kth);\n        &#125;\n    &#125;\n\t&#x2F;&#x2F;划分区间\n    public int partition(int[] nums,int start,int end)&#123;\n       \t &#x2F;&#x2F;随机选择枢轴元素\n        int pivot&#x3D;start+(int)(Math.random()*(end-start+1));\n        &#x2F;&#x2F;将枢轴元素调换至右边界\n        swap(nums,pivot,end);\n        &#x2F;&#x2F;双指针index和i用于进行划分，确定枢轴元素的最终位置\n        int index&#x3D;start-1;\n        for(int i&#x3D;start;i&lt;end;i++)&#123;\n            if(nums[i]&gt;nums[end])&#123;\n                swap(nums,i,++index);\n            &#125;\n        &#125;\n        swap(nums,++index,end);\n        return index;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n\n&#125;\n\n\n\n","slug":"FindKthLargest","date":"2022-07-21T00:24:42.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"2233f52546249f8733475a932932ac4d","title":"PriorityQueue的简单使用","content":"Java中的优先队列Java中的PriorityQueue默认是小顶堆，逻辑上是堆，物理上是数组，每次取出的元素是最小的。【可以通过比较器的方式传入不同的比较规则】\n特点：\n实现了Queue接口\n不允许放入null元素\n插入方法：\nadd()和offer(),前者插入失败抛出异常，后者插入失败返回false。\n\n\n获取堆顶元素：\nelement()和peek():都是获取堆顶元素，前者获取失败抛出异常，后者返回null\n\n\n获取并删除队首元素：\nremove()和poll()都是获取并删除队首元素，前者失败抛出异常，后者失败返回null。\n\n\n\n构造：\n构造小顶堆\n\nPriorityQueue small&#x3D;new PriorityQueue&lt;&gt;();\n\n\n构造大顶堆\n\nPriorityQueue big&#x3D;new PriorityQueue&lt;&gt;(Collections.reverseOrder());\n&#x2F;&#x2F;使用比较器构造大顶堆\nPriorityQueue&lt;int[]&gt; queue&#x3D;new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123;\n\tpublic int compare(int[] m, int[] n) &#123;\n\t\treturn m[1] - n[1];\n\t&#125;\n&#125;);\n   \n","slug":"PriorityQueue_SimpleUse","date":"2022-07-20T03:10:24.000Z","categories_index":"","tags_index":"Java,数据结构","author_index":"LiuQuanZe"},{"id":"0147aaa7b5bc889d40916e1f2d1d947a","title":"Hexo添加标签和分类","content":"如何在Hexo中添加分类和标签？分类：\n创建分类选项：\n生成【分类页】，并添加type属性\n\n\n\nhexo new page categories\n\n\n执行成功：\n\nINFO  Created: H:\\blog\\source\\categories\\index.md\n\n\n根据上述路径，找到index.md,添加type和layout：\n\ntitle: categories\ndate: 2022-07-19 16:16:46\ntype: &quot;categories&quot;\nlayout: &quot;categories&quot;\n\n\n保存并关闭index.md\n使用categories：\n\ntitle: Console失效\ndate: 2022-07-19 16:02:42\ncategories: \n- web前端\ntags:\n- Vue\n- 报错\n\n\n\n标签：\n创建标签选项：\n生成【标签页】，并添加type属性\n\n\n\nhexo new page tags\n\n\n执行成功：\n\nINFO  Created: H:\\blog\\source\\tags\\index.md\n\n\n根据上述路径，找到index.md,添加type和layout：\n\ntitle: 文章分类\ndate: 2022-01-07 22:53:43\ntype: &quot;tags&quot;\nlayout: &quot;tags&quot;\n\n\n保存并关闭index.md\n使用tags：\n\ntitle: Console失效\ndate: 2022-07-19 16:02:42\ncategories: \n- web前端\ntags:\n- Vue\n- 报错\n\n\n\n\n\n\n\n","slug":"HexoTagsAndCategories","date":"2022-07-19T08:18:19.000Z","categories_index":"个人博客","tags_index":"Hexo,使用说明","author_index":"LiuQuanZe"},{"id":"85d7f0ee0105da9c47f8cfa58c2659ee","title":"Console失效","content":"console.log()失效问题描述：当使用console.log()想要打印到控制台时，发现idea出现下滑红线，并且num run serve也通不过。\n错误信息：ESLint: Unexpected console statement.(no-console)\n\n\n\n解决办法：进行简单的配置即可：\n在package.json的eslintConfig:{}中的”rules”:{}，增加一行代码【”no-console”: “off”】\n&quot;rules&quot;: &#123;\n  &quot;no-console&quot;:&quot;off&quot;\n&#125;,\n\n","slug":"CannotUseConsole","date":"2022-07-19T08:02:42.000Z","categories_index":"web前端","tags_index":"Vue,报错","author_index":"LiuQuanZe"},{"id":"ea91dec26a5ee2422c404ab47e32c3f7","title":"Ryu的Rest API初体验","content":"ryu.app.ofctl_restryu.app.ofctl_rest provides REST APIs for retrieving the switch stats and Updating the switch stats. This application helps you debug your application and get various statistics.\n【其实就是ryu自己提供的一个应用程序，提供了获取交换机状态以及更新交换机状态的REST APIs。该应用可以帮助我们debug自己创建的应用并获取各种统计数据】\n \n\n\n\n\nThis application supports OpenFlow version 1.0, 1.2, 1.3, 1.4 and 1.5.\n【支持OpenFlow版本 1.0 1.2 1.3 1.4和1.5】\n使用\n将ofctl_rest和simple_switch_13.py一起启动\n\n\n\n启动拓扑\n\n\n\n另起一个终端，进行请求发送，测试接口\n\n\n\n其余接口尚未测试，该接口响应成功，响应结果是否正确要看具体实验情况。\n\n【注】使用的是python3，则需要修改ofctl_rest源码：\n\n第133行：\n\n#原本\nbody&#x3D;json.dumps(dps)\n#改为\nbody &#x3D; json.dumps(list(dps)).encode(&quot;utf-8&quot;)\n\n\n若是python2，则应该不需要修改，运行时不会报错\n\n","slug":"ofctlrest","date":"2022-07-18T03:52:22.000Z","categories_index":"SDN","tags_index":"使用方法,科研","author_index":"LiuQuanZe"},{"id":"03e1cda0baa3a649921c8af01fed4d68","title":"我的第一篇博客","content":"第一篇博客哈哈，我有自己的博客啦！\n","slug":"demo01","date":"2022-07-17T11:25:30.216Z","categories_index":"个人","tags_index":"记录,日常","author_index":"LiuQuanZe"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-07-17T09:52:14.472Z","categories_index":"","tags_index":"","author_index":"LiuQuanZe"}]