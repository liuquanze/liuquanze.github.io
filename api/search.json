[{"id":"8c8ee24da1a163a01cda5376a75169b1","title":"452.Minimum Number of Arrows to Burst Balloons","content":"452.Minimum Number of Arrows to Burst Balloons题目描述：There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] &#x3D; [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;&#x3D; x &lt;&#x3D; xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\n有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。\n一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。\n给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。\nexample 1:\n输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]\n输出：2\n解释：气球可以用2支箭来爆破:\n-在x &#x3D; 6处射出箭，击破气球[2,8]和[1,6]。\n-在x &#x3D; 11处发射箭，击破气球[10,16]和[7,12]。\n\nexample 2:\n输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]\n输出：4\n解释：每个气球需要射出一支箭，总共需要4支箭。\n\nexample 3:\n输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]\n输出：2\n解释：气球可以用2支箭来爆破:\n- 在x &#x3D; 2处发射箭，击破气球[1,2]和[2,3]。\n- 在x &#x3D; 4处射出箭，击破气球[3,4]和[4,5]。\n\n题目链接：https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/\n题解：&#x2F;*排序+贪心*&#x2F;\nclass Solution &#123;\n    public int findMinArrowShots(int[][] points) &#123;\n        &#x2F;&#x2F;检查数组是否合法\n        if(points.length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;依据右边界的大小进行升序排序\n        Arrays.sort(points,new Comparator&lt;&gt;()&#123;\n            public int compare(int[] m,int[] n)&#123;\n                &#x2F;&#x2F;m小n大则不用交换位置，因为我们要的就是升序排序\n                if(m[1]&lt;n[1])&#123;\n                    return -1;\n                    &#x2F;&#x2F;m大n小，则需要交换位置，保证升序\n                &#125;else if(m[1]&gt;n[1])&#123;\n                    return 1;\n                    &#x2F;&#x2F;若m&#x3D;n则不需要交换位置，【当返回值小于等于0时，不进行元素交换，仅当返回值大于0时才需要进行交换！】\n                &#125;else&#123;\n\n                    return 0;\n                &#125;\n            &#125;\n        &#125;);\n        &#x2F;&#x2F;获取第一个元素的右边界作为初始右边界\n        long right&#x3D;points[0][1];\n        &#x2F;&#x2F;用于箭矢计数，初始值为1\n        int num&#x3D;1;\n        &#x2F;&#x2F;对元素进行遍历，如果需要遇到了不重叠的气球（即左边界大于right），则需要增加箭矢的数量，并更新右边界的值\n        for(int[] b:points)&#123;\n            if(b[0]&gt;right)&#123;\n                num++;\n                right&#x3D;b[1];\n            &#125;\n        &#125;\n        &#x2F;&#x2F;返回箭矢的数量\n        return num;\n\n    &#125;\n&#125;\n\n","slug":"MinimumNumberofArrowstoBurstBalloons","date":"2022-07-27T02:11:15.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"0b469cb01192ec369bac9950f85cb59d","title":"Non—overlapping Intervals","content":"435. Non-overlapping Intervals题目描述：Given an array of intervals intervals where intervals[i] &#x3D; [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nexample 1:\nInput: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n\n\n\n\nexample 2:\nInput: intervals &#x3D; [[1,2],[1,2],[1,2]]\nOutput: 2\nExplanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n\nexample 3:\nInput: intervals &#x3D; [[1,2],[2,3]]\nOutput: 0\nExplanation: You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.\n\n来源：力扣（LeetCode）链接：https://leetcode.cn/problems/non-overlapping-intervals\n题解：&#x2F;*\n\t贪心法：\n\t1.首先对数组参数interval中的各个区间元素进行排序，下面是按照右边界升序排序的。\n\t2.选出排序后的第一个区间的右边界作为初始右边界，并初始化未重叠区间的数量。\n\t3.依次遍历数组中其他的区间元素，若遍历到的区间元素的左边界并未超过初始右边界，则表示两个区间不重叠，\n\t  则：可以将该区间加入到非重叠区间集合中，更新未重叠区间数量，更新初始右边界。\n\t4.最后遍历完成即可得到未重叠区间数量，最后获得需要删减的区间的数量作为返回值返回即可。\n*&#x2F;\nclass Solution &#123;\n    public int eraseOverlapIntervals(int[][] intervals) &#123;\n        &#x2F;&#x2F;检查参数是否合法,长度为0，则无需移除任何元素\n        if(intervals.length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;对间隔数组进行排序，对右边界进行排序，进行升序排序，排序完成后，最靠左的元素的右边界最小\n        Arrays.sort(intervals,new Comparator&lt;int[]&gt;()&#123;\n            public int compare(int[] m,int[] n)&#123;\n                return m[1]-n[1];\n            &#125;\n        &#125;);\n        &#x2F;&#x2F;获取间隔数组的长度\n        int length&#x3D;intervals.length;\n        &#x2F;&#x2F;获取初始右边界，即具有最小右边界的元素\n        int right_bound&#x3D;intervals[0][1];\n        &#x2F;&#x2F;non_overlapping_num记录的是不重叠的间隔的数量,因为至少存在一个元素，所以初始化ans为1.\n        int non_overlapping_num&#x3D;1;\n        &#x2F;&#x2F;若找到不重叠的下一个间隔【因为这里的数组已经按照右边界进行排序了，替换的右边界是逐渐增加的】\n        for(int i&#x3D;1;i&lt;length;i++)&#123;\n            &#x2F;&#x2F;若当前间隔元素不重叠\n            if(intervals[i][0]&gt;&#x3D;right_bound)&#123;\n                non_overlapping_num++;\n                right_bound&#x3D;intervals[i][1];\n            &#125;\n        &#125;\n        &#x2F;&#x2F;数组长度减去ans（当前不重叠元素个数），得到的就是需要移除的元素的个数\n        return length-non_overlapping_num;\n\n    &#125;\n&#125;\n\n\n","slug":"NonoverlappingIntervals","date":"2022-07-25T07:05:31.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"db0cb7674f2527793ee34b531f627ef0","title":"Assign Cookies","content":"Assign Cookies题目描述：Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;&#x3D; g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\nexample1:\nInput: g &#x3D; [1,2,3], s &#x3D; [1,1]\nOutput: 1\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\nexample2:\nInput: g &#x3D; [1,2], s &#x3D; [1,2,3]\nOutput: 2\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n\n来源：力扣（LeetCode）链接：https://leetcode.cn/problems/assign-cookies\n题解：&#x2F;*排序+贪心*&#x2F;\nclass Solution &#123;\n    public int findContentChildren(int[] g, int[] s) &#123;\n        &#x2F;&#x2F;g是每个孩子需要的饼干尺寸\n        &#x2F;&#x2F;s是你有的饼干的尺寸\n        &#x2F;&#x2F;使用贪心算法，以孩子的胃口为基准，按照胃口大小从小到大进行满足。\n        Arrays.sort(s);\n        Arrays.sort(g);\n        int numberOfChildren&#x3D;g.length;\n        int numberOfCookie&#x3D;s.length;\n        int i&#x3D;0;\n        int j&#x3D;0;\n        int ret&#x3D;0;\n        \n        while(i&lt;numberOfChildren&amp;&amp;j&lt;numberOfCookie)&#123;\n            while(j&lt;numberOfCookie&amp;&amp;g[i]&gt;s[j])&#123;\n                j++;\n            &#125;\n            if(j&lt;numberOfCookie)&#123;\n                ret++;\n            &#125;\n            i++;\n            j++;\n        &#125;\n        return ret;\n    &#125;\n&#125;\n\n","slug":"Assign-Cookies","date":"2022-07-24T00:59:12.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"c37588bd65d4c5745225faacbe87ed1b","title":"平台开发所使用的前端组件工具","content":"平台开发中所使用到的Vue工具和组件vue-prism-editor1. 实现效果\n可输入代码，并且代码语法高亮\n支持编辑模式与不可编辑模式\n\n2. 使用步骤\n安装依赖\n\nnpm install vue-prism-editor\n\n\n由于vue-prism-editor需要prismjs依赖，所以需要导入prismjs依赖\n\nnpm install prismjs\n\n\n在需要使用的页面导入组件\n\nimport &#123; PrismEditor &#125; from &quot;vue-prism-editor&quot;;\nimport &quot;vue-prism-editor&#x2F;dist&#x2F;prismeditor.min.css&quot;;\nimport &#123; highlight, languages &#125; from &quot;prismjs&#x2F;components&#x2F;prism-core&quot;;\nimport &quot;prismjs&#x2F;components&#x2F;prism-clike&quot;;\nimport &quot;prismjs&#x2F;components&#x2F;prism-javascript&quot;;\nimport &quot;prismjs&#x2F;themes&#x2F;prism-tomorrow.css&quot;; \n\n\nhtml\n\n&lt;prism-editor\n   class&#x3D;&quot;my-editor height-300&quot;\n    v-model&#x3D;&quot;code&quot;\n    aria-disabled\n    :highlight&#x3D;&quot;highlighter&quot;\n    line-numbers\n    :readonly&#x3D;&quot;false&quot;\n    :tabSize&#x3D;&quot;4&quot;\n    &gt;&lt;&#x2F;prism-editor&gt;\n\n\njavascript\n\nexport default &#123;\n\t components: &#123;\n\t \t\tPrismEditor\n\t &#125;,\n\t data: () &#x3D;&gt; (&#123;\n\t \t\tcode: &#39; &#39;,\n\t &#125;),\n\t methods: &#123;\n\t\t \thighlighter(code) &#123;\n\t\t \t\treturn highlight(code, languages.js); &#x2F;&#x2F;returns html\n\t\t \t&#125;\n\t &#125;\n&#125;;\n\n\nCSS\n\n&lt;style lang&#x3D;&quot;scss&quot;&gt;\n\t.my-editor &#123;\n\t background: #2d2d2d;\n\t color: #ccc;\n\t font-family: Fira code, Fira Mono, Consolas, Menlo, Courier, monospace;\n\t font-size: 14px;\n\t line-height: 1.5;\n\t padding: 5px;\n\t&#125;\n\t\n\t.prism-editor__textarea:focus &#123;\n\t outline: none;\n\t&#125;\n\t\n\t&#x2F;* 非必须 *&#x2F;\n\t.height-300 &#123;\n\t \theight: 300px;\n\t&#125;\n&lt;&#x2F;style&gt;\n\n参考资料：https://blog.csdn.net/c_qianxia5040/article/details/124008768\nfile-saver1. 实现效果\n可以将一段字符串保存为一个文件\n\n2. 使用步骤\n安装依赖\n\nnpm install file-saver --save\n\n\n在需要使用文件保存的页面导入依赖\n\nimport &#123; saveAs &#125; from &#39;file-saver&#39;;\n\n\n保存文件demo\n\ndownloadTxt() &#123;\n    let str_file &#x3D; &#39;文件内的字符串内容&#39;\n    let strData &#x3D; new Blob([str_file], &#123; type: &#39;text&#x2F;plain;charset&#x3D;utf-8&#39; &#125;);\n    saveAs(strData, &quot;文件.py&quot;);\n&#125;,\n\n参考资料：https://wjw1014.blog.csdn.net/article/details/124320511\n","slug":"toolsInVue","date":"2022-07-22T13:14:49.000Z","categories_index":"Web前端","tags_index":"Vue,模块","author_index":"LiuQuanZe"},{"id":"7543ffbb46b57fc1881ab7a5290f7749","title":"75.颜色排序--单指针","content":"75. 颜色排序–单指针题目描述：Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library’s sort function.\nexample 1:\nInput: nums &#x3D; [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n\nexample 2:\nInput: nums &#x3D; [2,0,1]\nOutput: [0,1,2]\n\n\n\n题解：class Solution &#123;\n    public void sortColors(int[] nums) &#123;\n        int index&#x3D;0;\n        &#x2F;&#x2F;确定0的位置\n        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;\n            if(nums[i]&#x3D;&#x3D;0)&#123;\n                swap(nums,i,index++);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;确定1的位置\n        for(int j&#x3D;index;j&lt;nums.length;j++)&#123;\n            if(nums[j]&#x3D;&#x3D;1)&#123;\n                swap(nums,j,index++);\n            &#125;\n        &#125;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n&#125;\n\n","slug":"75SortColors01","date":"2022-07-22T01:58:53.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"c4515973a08e01e147ab3e57422101e1","title":"Vue中localStorage的简单使用","content":"Vue中localStorage的简单使用localStorage主要作为本地存储来使用。下面记录三个主要用法：\n\n存储数据\n\nlocalStorage.setItem(&#39;key&#39;,&#39;value&#39;)\n\n\n取出数据\n\nlocalStorage.getItem(&#39;key&#39;)\n\n\n删除本地存储数据\n\nlocalStorage.removeItem(&#39;key&#39;)\n\n\n当存储的是json格式时，需要使用JSON.stringify()转化为字符串\n\n","slug":"localStorage","date":"2022-07-21T12:09:11.000Z","categories_index":"WEB前端","tags_index":"Vue","author_index":"LiuQuanZe"},{"id":"28e06c560ccb367ab8fe61d12d122120","title":"Sort Characters By Frequency_桶排序","content":"Sort Characters By Frequency——桶排序题目描述：Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.\nReturn the sorted string. If there are multiple answers, return any of them.\nexample 1:\nInput: s &#x3D; &quot;tree&quot;\nOutput: &quot;eert&quot;\nExplanation: &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.\nSo &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.\n\n\n\nexample 2:\nInput: s &#x3D; &quot;cccaaa&quot;\nOutput: &quot;aaaccc&quot;\nExplanation: Both &#39;c&#39; and &#39;a&#39; appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers.\nNote that &quot;cacaca&quot; is incorrect, as the same characters must be together.\n\n\n\n\n\n题解：class Solution &#123;\n    public String frequencySort(String s) &#123;\n        &#x2F;&#x2F;创建map存储字符及其出现次数\n        Map&lt;Character,Integer&gt; map&#x3D;new HashMap&lt;&gt;();\n        int max_frequency&#x3D;0;\n        int frequency&#x3D;0;\n        char ch&#x3D;&#39; &#39;;\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            ch&#x3D;s.charAt(i);\n            map.put(ch,map.getOrDefault(ch,0)+1);\n            max_frequency&#x3D;Math.max(max_frequency,map.get(ch));\n        &#125;\n\n        &#x2F;&#x2F;创建buckets，并初始化buckets\n        StringBuffer[] buckets&#x3D;new StringBuffer[max_frequency+1];\n        for(int i&#x3D;0;i&lt;max_frequency+1;i++)&#123;\n            buckets[i]&#x3D;new StringBuffer();\n        &#125;\n        for(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet())&#123;\n            ch&#x3D;entry.getKey();\n            frequency&#x3D;entry.getValue();\n            buckets[frequency].append(ch);\n        &#125;\n        &#x2F;&#x2F;创建返回值\n        StringBuffer ret&#x3D;new StringBuffer();\n        &#x2F;&#x2F;添加返回值\n        for(int i&#x3D;max_frequency;i&gt;&#x3D;1;i--)&#123;\n            StringBuffer bucket&#x3D;buckets[i];\n            for(int j&#x3D;0;j&lt;bucket.length();j++)&#123;\n                for(int k&#x3D;0;k&lt;i;k++)&#123;\n                    ret.append(bucket.charAt(j));\n                &#125;\n            &#125;\n\n        &#125;\n        return ret.toString();\n\n\n    &#125;\n&#125;\n\n","slug":"SortCharactersByFrequency-BucketSort","date":"2022-07-21T03:08:16.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"47c6968c5ee85e81112866938362b070","title":"Bucket Sort","content":"桶排序介绍：&#x2F;*\n桶排序是一个排序算法，工作原理是将数组分到有限数量的桶中。\n每个桶内再进行个别排序（可以使用其他不同的排序算法实现）。\n*&#x2F;\n\n基本步骤：\n设定一个基准，将待排序的数据按照一定的范围，从小到大平均分搭配N个桶中，此时，桶与桶之间已经排好序了，但是桶内是无序的。\n将桶内的元素进行排序\n将每个桶按照从小到大的编号，一次取出桶内元素，排序完成。\n\n","slug":"BucketSort","date":"2022-07-21T02:51:39.000Z","categories_index":"数据结构与算法","tags_index":"Java","author_index":"LiuQuanZe"},{"id":"95fb99a87b0934d93a7b934555997ee9","title":"Sort Characters By Frequency","content":"Sort Characters By Frequency题目描述：Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.\nReturn the sorted string. If there are multiple answers, return any of them.\nexample 1:\nInput: s &#x3D; &quot;tree&quot;\nOutput: &quot;eert&quot;\nExplanation: &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.\nSo &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.\n\n\n\nexample 2:\nInput: s &#x3D; &quot;cccaaa&quot;\nOutput: &quot;aaaccc&quot;\nExplanation: Both &#39;c&#39; and &#39;a&#39; appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers.\nNote that &quot;cacaca&quot; is incorrect, as the same characters must be together.\n\n\n\n\n\n题解：class Solution &#123;\n    public String frequencySort(String s) &#123;\n        &#x2F;&#x2F;创建map存储字符及其出现次数\n        Map&lt;Character,Integer&gt; map&#x3D;new HashMap&lt;&gt;();\n        char ch&#x3D;&#39; &#39;;\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            ch&#x3D;s.charAt(i);\n            map.put(ch,map.getOrDefault(ch,0)+1);\n        &#125;\n\n        &#x2F;&#x2F;创建list列表存储字符\n        List&lt;Character&gt; list&#x3D;new ArrayList&lt;&gt;(map.keySet());\n        &#x2F;&#x2F;对list进行降序排序，根据出现次数\n        Collections.sort(list,(m,n)-&gt;map.get(n)-map.get(m));\n        &#x2F;&#x2F;创建返回值\n        StringBuffer ret&#x3D;new StringBuffer();\n        &#x2F;&#x2F;将结果存储返回值\n        for(int k&#x3D;0;k&lt;list.size();k++)&#123;\n            ch&#x3D;list.get(k);\n            int frequency&#x3D;map.get(ch);\n            for(int j&#x3D;0;j&lt;frequency;j++)&#123;\n                ret.append(ch);\n            &#125;\n        &#125;\n        return ret.toString();\n\n    &#125;\n&#125;\n\n","slug":"SortCharactersByFrequency","date":"2022-07-21T02:12:13.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"457fe231ac1330559343c50bbf83f171","title":"Top K Frequent Elements","content":"Top K Frequent Elements题目描述：Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\nexample 1:\nInput: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2\nOutput: [1,2]\n\nexample 2:\nInput: nums &#x3D; [1], k &#x3D; 1\nOutput: [1]\n\n\n\n题解：class Solution &#123;\n    public int[] topKFrequent(int[] nums, int k) &#123;\n        &#x2F;&#x2F;创建map，记录元素及其出现次数\n       Map&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;Integer,Integer&gt;();\n       for(int num:nums)&#123;\n           map.put(num,map.getOrDefault(num,0)+1);\n       &#125;\n       &#x2F;&#x2F;创建结构为小根堆的优先队列，队列元素为一个大小为2的数组，[0]表示元素，[1]表示出现次数\n       &#x2F;&#x2F;这里创建优先队列时，由于队列中的元素类型并非整型，所以需要传入比较器，规定比较规则\n       PriorityQueue&lt;int[]&gt; queue&#x3D;new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;()&#123;\n           public int compare(int[] m,int[] n)&#123;\n               return m[1]-n[1];\n           &#125;\n       &#125;);\n        &#x2F;&#x2F;将map中的键值对存入优先队列\n       for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;\n           int key&#x3D;entry.getKey();\n           int value&#x3D;entry.getValue();\n           &#x2F;&#x2F;若队列已满，则需要判断是否需要替换\n           if(k&#x3D;&#x3D;queue.size())&#123;\n               &#x2F;&#x2F;若当前元素出现次数小于堆顶元素，则表示堆内元素出现次数均大于key，则无需替换，否则需要替换堆顶元素\n               if(value&gt;queue.peek()[1])&#123;\n                   queue.poll();\n                   queue.offer(new int[]&#123;key,value&#125;);\n               &#125;\n           &#125;else&#123;   &#x2F;&#x2F;若队列元素个数小于k，则直接加入队列中\n               \n               queue.offer(new int[]&#123;key,value&#125;);\n           &#125;\n       &#125;\n       &#x2F;&#x2F;将队列中维护的元素存入ret数组并返回\n        int[] ret&#x3D;new int[k];\n       for(int i&#x3D;0;i&lt;k;i++)&#123;\n           ret[i]&#x3D;queue.poll()[0];\n       &#125;\n       return ret;\n       \n\n    &#125;\n\n\n   \n&#125;\n\n\n\n\n\n","slug":"TopKFrequentElements","date":"2022-07-21T01:11:44.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"b11e16d08ad1418b22f0f4722489b2fa","title":"Kth Largest Element in an Array——堆排序","content":"Kth Largest Element in an Array——堆排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nYou must solve it in O(n) time complexity.\n题解：class Solution &#123;\n    public int findKthLargest(int[] nums, int k) &#123;\n        &#x2F;&#x2F;堆的大小\n        int heapSize&#x3D;nums.length;\n        &#x2F;&#x2F;初始建立大根堆\n        buildMaxHeap(nums,heapSize);\n        &#x2F;&#x2F;取出堆顶元素，置换到堆底，再对置换完成的堆进行调整\n        for(int i&#x3D;nums.length-1;i&gt;&#x3D;nums.length-k+1;i--)&#123;\n            swap(nums,0,i);\n            adjustHeap(nums,0,--heapSize);\n        &#125;\n        &#x2F;&#x2F;返回第k次调整的堆顶元素\n        return nums[0];\n    &#125;\n    &#x2F;&#x2F;初始建堆\n    public void buildMaxHeap(int[] nums,int heapSize)&#123;\n        &#x2F;&#x2F;找到第一个非叶节点，不断下坠\n        for(int i&#x3D;heapSize&#x2F;2;i&gt;&#x3D;0;i--)&#123;\n            adjustHeap(nums,i,heapSize);\n        &#125;\n    &#125;\n\t&#x2F;&#x2F;堆调整\n    public void adjustHeap(int[] nums,int i,int heapSize)&#123;\n        &#x2F;&#x2F;创建指针分别指向i节点的左右孩子节点\n        int left&#x3D;i*2+1;\n        int right&#x3D;i*2+2;\n        int largest&#x3D;i;\n        &#x2F;&#x2F;通过两次判断，将largest指针指向最大节点\n        if(left&lt;heapSize&amp;&amp;nums[left]&gt;nums[largest])&#123;\n            largest&#x3D;left;\n        &#125;\n        if(right&lt;heapSize&amp;&amp;nums[right]&gt;nums[largest])&#123;\n            largest&#x3D;right;\n        &#125;\n        &#x2F;&#x2F;若不符合大根堆要求，则进行调整\n        if(largest!&#x3D;i)&#123;\n            swap(nums,largest,i);\n            adjustHeap(nums,largest,heapSize);\n        &#125;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n\n&#125;\n\n\n\n","slug":"FindKthLargest01","date":"2022-07-21T00:45:06.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"124012fd83870b9daa284761d75f9454","title":"找到第k大的元素——快速排序","content":"Kth Largest Element in an Array——快速排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nYou must solve it in O(n) time complexity.\n题解：class Solution &#123;\n    public int findKthLargest(int[] nums, int k) &#123;\n        return fastSelection(nums,0,nums.length-1,k-1);\t&#x2F;&#x2F;注意，传入的参数是nums.length-1和k-1\n    &#125;\n\t&#x2F;&#x2F;快速排序，递归\n    public int fastSelection(int[] nums,int start,int end,int kth)&#123;\n        &#x2F;&#x2F;划分并确定一个元素的位置\n        int cur&#x3D;partition(nums,start,end);\n        &#x2F;&#x2F;若为第k个元素，则直接返回\n        if(cur&#x3D;&#x3D;kth)&#123;\n            return nums[cur];\n        &#125;else if(cur&lt;kth)&#123;\t\t&#x2F;&#x2F;否则对右边区域进行划分\n            return fastSelection(nums,cur+1,end,kth);\n        &#125;else&#123;\t\t\t\t&#x2F;&#x2F;对左边区域进行划分\n            return fastSelection(nums,start,cur-1,kth);\n        &#125;\n    &#125;\n\t&#x2F;&#x2F;划分区间\n    public int partition(int[] nums,int start,int end)&#123;\n       \t &#x2F;&#x2F;随机选择枢轴元素\n        int pivot&#x3D;start+(int)(Math.random()*(end-start+1));\n        &#x2F;&#x2F;将枢轴元素调换至右边界\n        swap(nums,pivot,end);\n        &#x2F;&#x2F;双指针index和i用于进行划分，确定枢轴元素的最终位置\n        int index&#x3D;start-1;\n        for(int i&#x3D;start;i&lt;end;i++)&#123;\n            if(nums[i]&gt;nums[end])&#123;\n                swap(nums,i,++index);\n            &#125;\n        &#125;\n        swap(nums,++index,end);\n        return index;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n\n&#125;\n\n\n\n","slug":"FindKthLargest","date":"2022-07-21T00:24:42.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"2233f52546249f8733475a932932ac4d","title":"PriorityQueue的简单使用","content":"Java中的优先队列Java中的PriorityQueue默认是小顶堆，逻辑上是堆，物理上是数组，每次取出的元素是最小的。【可以通过比较器的方式传入不同的比较规则】\n特点：\n实现了Queue接口\n不允许放入null元素\n插入方法：\nadd()和offer(),前者插入失败抛出异常，后者插入失败返回false。\n\n\n获取堆顶元素：\nelement()和peek():都是获取堆顶元素，前者获取失败抛出异常，后者返回null\n\n\n获取并删除队首元素：\nremove()和poll()都是获取并删除队首元素，前者失败抛出异常，后者失败返回null。\n\n\n\n构造：\n构造小顶堆\n\nPriorityQueue small&#x3D;new PriorityQueue&lt;&gt;();\n\n\n构造大顶堆\n\nPriorityQueue big&#x3D;new PriorityQueue&lt;&gt;(Collections.reverseOrder());\n&#x2F;&#x2F;使用比较器构造大顶堆\nPriorityQueue&lt;int[]&gt; queue&#x3D;new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123;\n\tpublic int compare(int[] m, int[] n) &#123;\n\t\treturn m[1] - n[1];\n\t&#125;\n&#125;);\n   \n","slug":"PriorityQueue_SimpleUse","date":"2022-07-20T03:10:24.000Z","categories_index":"","tags_index":"Java,数据结构","author_index":"LiuQuanZe"},{"id":"0147aaa7b5bc889d40916e1f2d1d947a","title":"Hexo添加标签和分类","content":"如何在Hexo中添加分类和标签？分类：\n创建分类选项：\n生成【分类页】，并添加type属性\n\n\n\nhexo new page categories\n\n\n执行成功：\n\nINFO  Created: H:\\blog\\source\\categories\\index.md\n\n\n根据上述路径，找到index.md,添加type和layout：\n\ntitle: categories\ndate: 2022-07-19 16:16:46\ntype: &quot;categories&quot;\nlayout: &quot;categories&quot;\n\n\n保存并关闭index.md\n使用categories：\n\ntitle: Console失效\ndate: 2022-07-19 16:02:42\ncategories: \n- web前端\ntags:\n- Vue\n- 报错\n\n\n\n标签：\n创建标签选项：\n生成【标签页】，并添加type属性\n\n\n\nhexo new page tags\n\n\n执行成功：\n\nINFO  Created: H:\\blog\\source\\tags\\index.md\n\n\n根据上述路径，找到index.md,添加type和layout：\n\ntitle: 文章分类\ndate: 2022-01-07 22:53:43\ntype: &quot;tags&quot;\nlayout: &quot;tags&quot;\n\n\n保存并关闭index.md\n使用tags：\n\ntitle: Console失效\ndate: 2022-07-19 16:02:42\ncategories: \n- web前端\ntags:\n- Vue\n- 报错\n\n\n\n\n\n\n\n","slug":"HexoTagsAndCategories","date":"2022-07-19T08:18:19.000Z","categories_index":"个人博客","tags_index":"Hexo,使用说明","author_index":"LiuQuanZe"},{"id":"85d7f0ee0105da9c47f8cfa58c2659ee","title":"Console失效","content":"console.log()失效问题描述：当使用console.log()想要打印到控制台时，发现idea出现下滑红线，并且num run serve也通不过。\n错误信息：ESLint: Unexpected console statement.(no-console)\n\n\n\n解决办法：进行简单的配置即可：\n在package.json的eslintConfig:{}中的”rules”:{}，增加一行代码【”no-console”: “off”】\n&quot;rules&quot;: &#123;\n  &quot;no-console&quot;:&quot;off&quot;\n&#125;,\n\n","slug":"CannotUseConsole","date":"2022-07-19T08:02:42.000Z","categories_index":"web前端","tags_index":"Vue,报错","author_index":"LiuQuanZe"},{"id":"ea91dec26a5ee2422c404ab47e32c3f7","title":"Ryu的Rest API初体验","content":"ryu.app.ofctl_restryu.app.ofctl_rest provides REST APIs for retrieving the switch stats and Updating the switch stats. This application helps you debug your application and get various statistics.\n【其实就是ryu自己提供的一个应用程序，提供了获取交换机状态以及更新交换机状态的REST APIs。该应用可以帮助我们debug自己创建的应用并获取各种统计数据】\n \n\n\n\n\nThis application supports OpenFlow version 1.0, 1.2, 1.3, 1.4 and 1.5.\n【支持OpenFlow版本 1.0 1.2 1.3 1.4和1.5】\n使用\n将ofctl_rest和simple_switch_13.py一起启动\n\n\n\n启动拓扑\n\n\n\n另起一个终端，进行请求发送，测试接口\n\n\n\n其余接口尚未测试，该接口响应成功，响应结果是否正确要看具体实验情况。\n\n【注】使用的是python3，则需要修改ofctl_rest源码：\n\n第133行：\n\n#原本\nbody&#x3D;json.dumps(dps)\n#改为\nbody &#x3D; json.dumps(list(dps)).encode(&quot;utf-8&quot;)\n\n\n若是python2，则应该不需要修改，运行时不会报错\n\n","slug":"ofctlrest","date":"2022-07-18T03:52:22.000Z","categories_index":"SDN","tags_index":"使用方法,科研","author_index":"LiuQuanZe"},{"id":"03e1cda0baa3a649921c8af01fed4d68","title":"我的第一篇博客","content":"第一篇博客哈哈，我有自己的博客啦！\n","slug":"demo01","date":"2022-07-17T11:25:30.216Z","categories_index":"个人","tags_index":"记录,日常","author_index":"LiuQuanZe"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-07-17T09:52:14.472Z","categories_index":"","tags_index":"","author_index":"LiuQuanZe"}]