[{"id":"3775c9e904a11de6ad41f14528d2779f","title":"142.环形链表Ⅱ","content":"142.环形链表Ⅱ题目描述：\n环形链表 II\n\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\nexample 1：\n输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\nexample 2:\n输入：head &#x3D; [1,2], pos &#x3D; 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n\nexample 3:\n输入：head &#x3D; [1], pos &#x3D; -1\n输出：返回 null\n解释：链表中没有环。\n\n提示：\n\n链表中节点的数目范围在范围 [0, 104] 内\n-105 &lt;= Node.val &lt;= 105\npos 的值为 -1 或者链表中的一个有效索引\n\n题目来源：https://leetcode.cn/problems/linked-list-cycle-ii/submissions/\n题解：&#x2F;*\n判断是否有环：可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。\n此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。\n首先判断是否有环，如果有环，则记录相遇节点，然后下一步寻找环的入口节点：从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。\n*&#x2F;\n&#x2F;**\n * Definition for singly-linked list.\n * class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123;\n *         val &#x3D; x;\n *         next &#x3D; null;\n *     &#125;\n * &#125;\n *&#x2F;\npublic class Solution &#123;\n    public ListNode detectCycle(ListNode head) &#123;\n        ListNode slow &#x3D; head;\n        ListNode fast &#x3D; head;\n        while (fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null) &#123;\n            slow &#x3D; slow.next;\n            fast &#x3D; fast.next.next;\n            if (slow &#x3D;&#x3D; fast) &#123;&#x2F;&#x2F; 有环\n                ListNode index1 &#x3D; fast;\n                ListNode index2 &#x3D; head;\n                &#x2F;&#x2F; 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口\n                while (index1 !&#x3D; index2) &#123;\n                    index1 &#x3D; index1.next;\n                    index2 &#x3D; index2.next;\n                &#125;\n                return index1;\n            &#125;\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n","slug":"142-环形链表Ⅱ","date":"2022-08-27T12:12:23.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,链表","author_index":"LiuQuanZe"},{"id":"997023f756e83c602ad393bfa331d66a","title":"24.两两交换链表中的节点","content":"24.两两交换链表中的节点题目描述：\n两两交换链表中的节点\n\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\nexample1:\n输入：head &#x3D; [1,2,3,4]\n输出：[2,1,4,3]\n\nexample 2:\n输入：head &#x3D; []\n输出：[]\n\nexample 3:\n输入：head &#x3D; [1]\n输出：[1]\n\n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 &lt;= Node.val &lt;= 100\n\n题目来源：https://leetcode.cn/problems/swap-nodes-in-pairs/\n题解：https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E6%80%9D%E8%B7%AF\n题解：&#x2F;**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val &#x3D; val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public ListNode swapPairs(ListNode head) &#123;\n        ListNode head_node&#x3D;new ListNode();\n        head_node.next&#x3D;head;\n        &#x2F;&#x2F;活动指针，指向的是当前需要交换的节点的前一个节点，方便交换，这里之所以采用虚拟头节点，是为了统一化处理\n        ListNode p&#x3D;head_node;\n        while(p.next!&#x3D;null&amp;&amp;p.next.next!&#x3D;null)&#123;\n            &#x2F;&#x2F;指向需要交换的第一个节点\n            ListNode temp&#x3D;p.next;\n            &#x2F;&#x2F;指向需要交换的第二个节点\n            ListNode temp_next&#x3D;p.next.next;\n            &#x2F;&#x2F;首先将p指向第二个节点\n            p.next&#x3D;temp_next;\n            &#x2F;&#x2F;第一个节点指向第二个节点原本指向的后续链表\n            temp.next&#x3D;temp_next.next;\n            &#x2F;&#x2F;第二个节点指向一个节点\n            temp_next.next&#x3D;temp;\n            &#x2F;&#x2F;将活动节点后移，指向下一对需要交换的节点的前一个节点，\n            p&#x3D;p.next.next;\n\n        &#125;\n        &#x2F;&#x2F;返回调整后的链表\n        return head_node.next;\n    &#125;\n&#125;\n\n\n\n","slug":"24-两两交换链表中的节点","date":"2022-08-24T14:35:56.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,链表","author_index":"LiuQuanZe"},{"id":"04d169a11d3cee4253a53c23de1dbd14","title":"206.反转链表","content":"206.反转链表题目描述：\n反转链表\n\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\nexample 1:\n输入：head &#x3D; [1,2,3,4,5]\n输出：[5,4,3,2,1]\n\nexample 2:\n输入：head &#x3D; [1,2]\n输出：[2,1]\n\nexample 3:\n输入：head &#x3D; []\n输出：[]\n\n提示：\n\n链表中节点的数目范围是 [0, 5000]\n-5000 &lt;= Node.val &lt;= 5000\n\n题目来源：https://leetcode.cn/problems/reverse-linked-list/\n题解：&#x2F;**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val &#x3D; val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode head_node&#x3D;new ListNode();\n        ListNode p&#x3D;head;\n        while(p!&#x3D;null)&#123;\n            ListNode q&#x3D;p.next;\n            p.next&#x3D;head_node.next;\n            head_node.next&#x3D;p;\n            p&#x3D;q;\n        &#125;\n        return head_node.next;\n    &#125;\n&#125;\n\n","slug":"206-反转链表","date":"2022-08-23T13:56:14.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,链表","author_index":"LiuQuanZe"},{"id":"aa4d739c1ac4e9cbdf52b62c4e456ed6","title":"Python语法错误01","content":"Python语法错误01#出现语法错误一般是python版本问题，解决方案一般是两种\n&quot;&quot;&quot;\n1.修改python版本\n2.修改代码语法\n&quot;&quot;&quot;\n\n1.except Exception, e: 语法无效except Exception e:#python2支持，3版本不支持\n#修改为3版本语法\nexcept Exception as e:\n\n2.TypeError: a bytes-link object is requeired, not ‘str’\n需要的是byte类型的对象，而非str类型\n\n#解决方案：将字符串类型转为字节类型\n&quot;&quot;&quot;\n假设s为一个str类型的变量\n&#x3D;&gt;type(s)\n&lt;class &#39;str&#39;&gt;\n存在以下三种常见的类型转换公式\n1.b1&#x3D;bytes(s.encoding&#x3D;&#39;utf-8&#39;)\n2.b2&#x3D;str.encoding(s)\n3.b3&#x3D;s.encode(encoding&#x3D;&#39;utf&#x3D;8&#39;)\n\n&quot;&quot;&quot;\n\n\n\n","slug":"Python语法错误01","date":"2022-08-23T07:42:40.000Z","categories_index":"实验","tags_index":"Python,语法错误","author_index":"LiuQuanZe"},{"id":"e036cd89658c33624bfd31dd2060c058","title":"203.移除链表元素","content":"203.移除链表元素题目描述：\n移除链表元素\n\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 \nexample 1:\n输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6\n输出：[1,2,3,4,5]\n\nexample 2:\n输入：head &#x3D; [], val &#x3D; 1\n输出：[]\n\nexample 3:\n输入：head &#x3D; [7,7,7,7], val &#x3D; 7\n输出：[]\n\n提示：\n\n列表中的节点数目在范围 [0, 104] 内\n1 &lt;= Node.val &lt;= 50\n0 &lt;= val &lt;= 50\n\n题目来源：\nhttps://leetcode.cn/problems/remove-linked-list-elements/\n题解：&#x2F;**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val &#x3D; val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public ListNode removeElements(ListNode head, int val) &#123;\n        if(head&#x3D;&#x3D;null)&#123;\n            return null;\n        &#125;\n        &#x2F;&#x2F;创建一个虚拟头节点，目的是为了统一头结点的处理操作\n        ListNode fake_head&#x3D;new ListNode(-1,head);\n        &#x2F;&#x2F;左指针\n        ListNode pre&#x3D;fake_head;\n        &#x2F;&#x2F;右指针\n        ListNode sec&#x3D;head;\n        while(sec!&#x3D;null)&#123;\n            &#x2F;&#x2F;若当前右指针元素需要移除\n            if(sec.val&#x3D;&#x3D;val)&#123;\n                &#x2F;&#x2F;丢弃该元素,并将右指针向后移动一位\n                pre.next&#x3D;sec.next;\n                sec&#x3D;sec.next;\n            &#125;else&#123;\n                &#x2F;&#x2F;若该元素无须移除，则左右指针均向后移动一位\n                pre&#x3D;pre.next;\n                sec&#x3D;sec.next;\n            &#125;\n\n        &#125;\n        return fake_head.next;\n    &#125;\n&#125;\n\n","slug":"203-移除链表元素","date":"2022-08-20T01:35:04.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,链表","author_index":"LiuQuanZe"},{"id":"be7f5c6dc71f9de739df383de800893c","title":"416.分割等和子集","content":"416.分割等和子集题目描述：\n分割等和子集\n\n给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\nexample 1:\n输入：nums &#x3D; [1,5,11,5]\n输出：true\n解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n\nexample 2:\n输入：nums &#x3D; [1,2,3,5]\n输出：false\n解释：数组不能分割成两个元素和相等的子集。\n\n提示：\n\n1 &lt;= nums.length &lt;= 200\n1 &lt;= nums[i] &lt;= 100\n\n题目来源：https://leetcode.cn/problems/partition-equal-subset-sum/\n题解：&#x2F;&#x2F;滚动数组，一维的dp数组\nclass Solution &#123;\n    public boolean canPartition(int[] nums) &#123;\n        if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;\n            return false;\n        &#125;\n        int sum&#x3D;0;\n        for(int num:nums)&#123;\n            sum+&#x3D;num;\n        &#125;\n        &#x2F;&#x2F;是奇数，必无法分割成两个等和的子数组\n        if(sum%2&#x3D;&#x3D;1)&#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F;背包大小即为和\n        &#x2F;&#x2F;物品重量为nums[i],物品价值为nums[i]\n        int target&#x3D;sum&#x2F;2;\n        int[] dp&#x3D;new int[target+1];\n        for(int i&#x3D;nums[0];i&lt;&#x3D;target;i++)&#123;\n            dp[i]&#x3D;nums[0];\n        &#125;\n        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;\n            for(int j&#x3D;target;j&gt;&#x3D;nums[i];j--)&#123;\n                &#x2F;&#x2F;为了防止覆盖问题，背包容量从后往前遍历\n                dp[j]&#x3D;Math.max(dp[j],dp[j-nums[i]]+nums[i]);\n            &#125;\n        &#125;\n        return dp[target]&#x3D;&#x3D;target;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;01背包，二维dp数组\nclass Solution &#123;\n    public boolean canPartition(int[] nums) &#123;\n        if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;\n            return false;\n        &#125;\n        int sum&#x3D;0;\n        for(int num:nums)&#123;\n            sum+&#x3D;num;\n        &#125;\n        if(sum%2&#x3D;&#x3D;1)&#123;\n            return false;\n        &#125;\n        int target&#x3D;sum&#x2F;2;\n        int[][] dp&#x3D;new int[nums.length][target+1];\n        &#x2F;&#x2F;dp数组初始化\n        for(int i&#x3D;nums[0];i&lt;&#x3D;target;i++)&#123;\n            dp[0][i]&#x3D;nums[0];\n        &#125;\n        &#x2F;&#x2F;遍历物品从第一个开始，因为初始化的时候第0个已经遍历过了\n        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;target;j++)&#123;\n                if(j&lt;nums[i])&#123;\n                    dp[i][j]&#x3D;dp[i-1][j];\n                &#125;else&#123;\n                    dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[nums.length-1][target]&#x3D;&#x3D;target;\n    &#125;\n&#125;\n\n","slug":"416-分割等和子集","date":"2022-08-20T01:04:47.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"fb852bf52649b6773513d798310ccbeb","title":"59.螺旋矩阵Ⅱ","content":"59.螺旋矩阵Ⅱ题目描述：\n螺旋矩阵 II\n\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\nexample 1:\n输入：n &#x3D; 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]\n\nexample 2:\n输入：n &#x3D; 1\n输出：[[1]]\n\n提示：\n\n1 &lt;= n &lt;= 20\n\n题目来源：\nhttps://leetcode.cn/problems/spiral-matrix-ii/\n题解：class Solution &#123;\n    public int[][] generateMatrix(int n) &#123;\n        int[][] ret&#x3D;new int[n][n];\n        int offset&#x3D;1;   &#x2F;&#x2F;每轮循环需要偏移的量，比如第一轮是要预留一个位置，offset&#x3D;1\n        int loop&#x3D;n&#x2F;2;   &#x2F;&#x2F;需要进行的圈数，比如n&#x3D;3只需要循环一次，n&#x3D;6需要循环3次\n        int mid&#x3D;n&#x2F;2;    &#x2F;&#x2F;矩阵的中心位置，比如n&#x3D;3，中心位置是(1,1)\n        int count&#x3D;1;    &#x2F;&#x2F;用于给各个位置赋值\n        int i&#x3D;0;\n        int j&#x3D;0;\n        int startx&#x3D;0;\n        int starty&#x3D;0;       &#x2F;&#x2F;用于记录每一圈的开始位置\n        for(;loop&gt;0;loop--)&#123;\n            i&#x3D;startx;\n            j&#x3D;starty;\n            &#x2F;&#x2F;从左向右移动，j小于n-offset，预留一个位置给后面            \n            for(;j&lt;n-offset;j++)&#123;\n                ret[i][j]&#x3D;count++;\n            &#125;\n            &#x2F;&#x2F;从上向下移动，预留一个位置给后面\n            for(;i&lt;n-offset;i++)&#123;\n                ret[i][j]&#x3D;count++;\n            &#125;\n            &#x2F;&#x2F;从右向左移动，预留一个位置给后面，注意这里j不是大于0，而是大于starty，因为每一圈的开始位置是在改变的，只有第一圈才是0\n            for(;j&gt;starty;j--)&#123;\n                ret[i][j]&#x3D;count++;\n            &#125;\n            &#x2F;&#x2F;从下向上移动，预留一个位置给后面，注意这里i不是大于0，而是大于startx，因为每一圈的开始位置是在移动的，只有第一圈才是0\n            for(;i&gt;startx;i--)&#123;\n                ret[i][j]&#x3D;count++;\n            &#125;\n            &#x2F;&#x2F;更新便宜量，因为每一圈是在不断缩小的，所以边界是在变化的，所以偏移量也在变化\n            offset++;\n            &#x2F;&#x2F;更新下一圈的开始位置\n            startx++;\n            starty++;\n\n\n        &#125;\n        &#x2F;&#x2F;若n为奇数，则中心会有一个多出的元素，需要进行赋值，其实就是最后一个元素n^2\n        if(n%2&#x3D;&#x3D;1)&#123;\n            ret[mid][mid]&#x3D;n*n;\n        &#125;\n        return ret;\n    &#125;\n&#125;\n\n","slug":"59-螺旋矩阵Ⅱ","date":"2022-08-19T12:59:09.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"3e8eaaf0906092af7ecd3983c1cdcff1","title":"209.长度最小的子数组","content":"209.长度最小的子数组题目描述：\n长度最小的子数组\n\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\nexample 1:\n输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\nexample 2:\n输入：target &#x3D; 4, nums &#x3D; [1,4,4]\n输出：1\n\nexample 3:\n输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]\n输出：0\n\n\n\n提示：\n\n1 &lt;= target &lt;= 109\n1 &lt;= nums.length &lt;= 105\n1 &lt;= nums[i] &lt;= 105\n\n题目来源：\nhttps://leetcode.cn/problems/minimum-size-subarray-sum/\n题解：class Solution &#123;\n    public int minSubArrayLen(int target, int[] nums) &#123;\n        &#x2F;&#x2F;滑动窗口\n        &#x2F;*\n        基本思想：\n            1.定义两个指针，初始值均为数组左边界\n            2.定义变量记录两个指针区域之间子序列的和，再定义一个变量记录当前满足条件的最小子序列长度，初始值为无穷大\n            3.不断右移右指针，并计算子区域元素之和，当子区域和满足条件时记录当前子区域长度并更新最小子区域长度，随后将左指针右移，若依旧满足条件则继续更新最小子区域长度，直到子区域之和不满足条件，之后重新开始右移右指针\n        *&#x2F;\n        &#x2F;&#x2F;判断参数是否合法\n        if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;初始化指针，j为右指针，i为左指针\n        int i&#x3D;0;\n        int j&#x3D;0;\n        &#x2F;&#x2F;sum表示i~j子序列之和\n        int sum&#x3D;0;\n        &#x2F;&#x2F;ret记录当前的最小子序列\n        int ret&#x3D;Integer.MAX_VALUE;\n        &#x2F;&#x2F;当遍历子序列之和没有超过target，则将j右移\n        while(j&lt;nums.length)&#123;\n            sum+&#x3D;nums[j];\n            &#x2F;&#x2F;若子序列之和满足条件，则计算子序列长度，并判断是否更新ret，并将左边界右移，更新子序列之和，循环右移并更新子序列长度。\n            while(sum&gt;&#x3D;target)&#123;\n                int sub_length&#x3D;j-i+1;\n                ret&#x3D;ret&gt;sub_length? sub_length:ret;\n                sum-&#x3D;nums[i++]; \n            &#125;\n            j++;\n        &#125;\n        &#x2F;&#x2F;若ret的值发生改变，则返回，否则返回0，表示没有满足条件的解\n        return ret&#x3D;&#x3D;Integer.MAX_VALUE? 0:ret;\n    &#125;\n&#125;\n\n","slug":"209-长度最小的子数组","date":"2022-08-19T12:21:28.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"34cb425e734202379d2ace9dc721620a","title":"ERROR 2003 (HY000) Can't connect to MySQL server on 'localhost:3306' (10061)","content":"ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost:3306’ (10061)问题描述：mysql -uroot -p\n\n\n输入上传命令之后，出现标题上的错误。\n数据库无法成功连接\n\n解决方案：\n打开win搜索栏，输入“计算机管理”\n选择服务\n找到mysql，并启动即可\n\n","slug":"连接mysql失败","date":"2022-08-18T04:11:34.000Z","categories_index":"后端开发","tags_index":"报错,MySQL","author_index":"LiuQuanZe"},{"id":"15073fb27fca9b3ab97a6db7836c4a4d","title":"977.有序数组的平方","content":"977.有序数组的平方题目描述：\n有序数组的平方\n\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\nexample 1:\n输入：nums &#x3D; [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]\n\nexample 2:\n输入：nums &#x3D; [-7,-3,2,3,11]\n输出：[4,9,9,49,121]\n\n提示：\n\n1 &lt;= nums.length &lt;= 104\n-104 &lt;= nums[i] &lt;= 104\nnums 已按 非递减顺序 排序\n\n题目来源：https://leetcode.cn/problems/squares-of-a-sorted-array\n题解：&#x2F;&#x2F;先计算平方，然后排序，时间复杂度O(nlogn)\nclass Solution &#123;\n    public int[] sortedSquares(int[] nums) &#123;\n        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;\n            nums[i]*&#x3D;nums[i];\n        &#125;\n        Arrays.sort(nums);\n        return nums;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;使用双指针，一个i从头开始，一个j从尾巴开始，分别计算平方，比较大小，放入一个新的数组，新数组的指针为k，从尾部开始\nclass Solution &#123;\n    public int[] sortedSquares(int[] nums) &#123;\n        int[] ret&#x3D;new int[nums.length];\n\n        for(int i&#x3D;0,j&#x3D;nums.length-1,k&#x3D;ret.length-1;i&lt;&#x3D;j;)&#123;\n            if(nums[i]*nums[i]&gt;&#x3D;nums[j]*nums[j])&#123;\n                ret[k--]&#x3D;nums[i]*nums[i];\n                i++;\n            &#125;else&#123;\n                ret[k--]&#x3D;nums[j]*nums[j];\n                j--;\n            &#125;\n        &#125;\n        return ret;\n    &#125;\n&#125;\n\n","slug":"977-有序数组的平方","date":"2022-08-17T22:41:02.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"dcd5a30d05960c310201068cc050e1d7","title":"01 bag","content":"01背包问题题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。\n这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？\n每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。\n所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！\n题解：public class bag01 &#123;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;物品重量\n        int[] weight &#x3D; &#123;1, 3, 4&#125;;\n        &#x2F;&#x2F;物品价值\n        int[] value &#x3D; &#123;15, 20, 30&#125;;\n        &#x2F;&#x2F;背包大小\n        int bagsize &#x3D; 4;\n        testweightbagproblem(weight, value, bagsize);\n    &#125;\n\n    public static void testweightbagproblem(int[] weight, int[] value, int bagsize)&#123;\n        &#x2F;&#x2F;创建dp数组\n        int[][] dp&#x3D;new int[weight.length][bagsize+1];\n        &#x2F;&#x2F;对dp数组进行初始化\n        &#x2F;*\n        * 对dp数组的第一行进行初始化，dp[i][j]表示的是容量为j的背包，前i个物品能获得的最大价值\n        * 第一行是指将第0个物品放入不同的容量0~bagsize的背包的最大价值，其实也就是看第0个物品可不可以放入背包中，如果可以则将dp[0][j]设置为value[0]即可\n        * ，若j&lt;weight[0]则表示第0个物品放不进容量为j的背包，则容量为j的背包的价值只能是0，所以下方的j从weight[0]开始遍历，因为j&lt;weight[0]时，dp[0][j]&#x3D;0\n        * *&#x2F;\n        for(int j&#x3D;weight[0];j&lt;&#x3D;bagsize;j++)&#123;\n            dp[0][j]&#x3D;value[0];\n        &#125;\n\n        &#x2F;&#x2F;状态转换公式\n        &#x2F;*\n        * 先遍历物品i&#x3D;1;i&lt;&#x3D;weight.length，再遍历背包容量j&#x3D;1;j&lt;&#x3D;bagsize\n        * 1.当背包容量小于当前的物品的重量j&lt;weight[i]时,表示物品i无法放进此时容量为j的背包，所以dp[i][j]：容量为j的背包在i个物品中所能获得的最大价值等于容量为j的背包\n        * 在i-1个物品中所能获得的最大价值；也就是不放入第i个物品的最大价值（因为背包容量不够嘛）\n        * 2.当背包容量大于等于当前物品的重量j&gt;&#x3D;weight[i]时，表示物品可以放进此时容量为j的背包，因此出现两种选择：\n        *   （1）将物品i放进背包\n        *   （2）不将物品i放进背包，\n        * 至于选择放还是不放，就需要分别计算放入物品i和不放入物品i的背包的价值并选择能使背包价值最大化的方式（通俗的说，放入i和不放入i，谁能使背包的价值大，就选谁）\n        * 所以dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i]+value[i]])\n        * 注：这里的dp[i-1][j-weight[i]表示的是容量为j-weight[j]的背包在0~i-1所能获得最大价值，之所以j-weight[j]就是要预留出物品i的空间，所以p[i-1][j-weight[i]也可以说是为物品i\n        * 预留出背包空间后的最大可以获得的价值，再然后加上value[i]就可以得到放入物品i后，容量为j的背包所能获得的最大价值。\n        *\n        * 重新梳理：\n        * （1）如果物品i可以放入背包（背包容量允许），则分别比较物品放入前后的背包价值，选取最大值\n        * （2）若物品i不可以放入背包（背包容量不允许），则选择不放入i时的最大价值。\n        * *&#x2F;\n        for(int i&#x3D;1;i&lt;weight.length;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;bagsize;j++)&#123;\n                if(j&lt;weight[i-1])&#123;\n                    dp[i][j]&#x3D;dp[i-1][j];\n                &#125;else&#123;\n                    dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i-1]]+value[i-1]);\n                &#125;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;输出dp数组查看运行结果\n        for (int i&#x3D;0;i&lt;weight.length;i++)&#123;\n            for(int j&#x3D;0;j&lt;&#x3D;bagsize;j++)&#123;\n                System.out.printf(dp[i][j]+&quot; &quot;);\n            &#125;\n            System.out.printf(&quot;\\n&quot;);\n        &#125;\n\n\n    &#125;\n&#125;\n\n\n","slug":"01-bag","date":"2022-08-17T03:09:15.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划","author_index":"LiuQuanZe"},{"id":"eea51d59bc355db9bbe09ae2654e00b2","title":"96.不同的二叉搜索树","content":"96.不同的二叉搜索树题目描述：\n不同的二叉搜索树\n\n给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。\nexample 1:\n输入：n &#x3D; 3\n输出：5\n\nexample 2:\n输入：n &#x3D; 1\n输出：1\n\n\n\n提示：\n\n1 &lt;= n &lt;= 19\n\n题目来源：https://leetcode.cn/problems/unique-binary-search-trees/\n题解：class Solution &#123;\n    public int numTrees(int n) &#123;\n        &#x2F;&#x2F;定义dp数组\n        int[] dp&#x3D;new int[n+1];\n        &#x2F;&#x2F;dp的初始值：当有0个节点时，看作一个空的二叉树，dp[0]&#x3D;1；当有一个节点时，dp[1]&#x3D;1;\n        dp[0]&#x3D;1;\n        dp[1]&#x3D;1;\n        &#x2F;&#x2F;状态公式：dp[i]+&#x3D;dp[j-1]*dp[i-j];\n        &#x2F;&#x2F;j表示当前二叉搜索树的头节点，dp[j-1]和dp[i-j]分别表示其左右子树的二叉搜索树个数\n        &#x2F;&#x2F;详情见https:&#x2F;&#x2F;gitee.com&#x2F;programmercarl&#x2F;leetcode-master&#x2F;blob&#x2F;master&#x2F;problems&#x2F;0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md\n        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;i;j++)&#123;\n                dp[i]+&#x3D;dp[j-1]*dp[i-j];\n            &#125;\n        &#125;\n        return dp[n];\n\n\n    &#125;\n&#125;\n\n","slug":"96-不同的二叉搜索树","date":"2022-08-16T03:04:40.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"6d961b2ba2212b262ffda24ad1b8896a","title":"343.整数拆分","content":"343.整数拆分题目描述：\n整数拆分\n\n给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。\n返回 你可以获得的最大乘积 。\nexample 1:\n输入: n &#x3D; 2\n输出: 1\n解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。\n\nexample 2:\n输入: n &#x3D; 10\n输出: 36\n解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。\n\n提示：\n\n2 &lt;= n &lt;= 58\n\n题目来源：https://leetcode.cn/problems/integer-break/\n题解:class Solution &#123;\n    public int integerBreak(int n) &#123;\n        &#x2F;&#x2F;参数是否合法，当n&#x3D;0 or 1的时候无法进行拆分\n        if(n&#x3D;&#x3D;0||n&#x3D;&#x3D;1)&#123;\n           return 0;\n        &#125;\n        &#x2F;&#x2F;定义dp数组，dp[i]表示的是给定i时可以获得的最大化乘积\n        int[] dp&#x3D;new int[n+1];\n        &#x2F;&#x2F;dp数组初始化，直接从dp[2]开始初始化，因为i&#x3D;1和0是没有意义的\n        dp[2]&#x3D;1;\n        &#x2F;&#x2F;对dp数组进行遍历，确定状态转换公式：\n        &#x2F;*\n            dp[i]可以通过两个公式得到，其中j从1到i-1\n                1.j*(i-j)\n                2.j*dp[i-j]\n                j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。\n                如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。\n                所以递推公式：dp[i] &#x3D; max(&#123;dp[i], (i - j) * j, dp[i - j] * j&#125;);\n            那么在取最大值的时候，为什么还要比较dp[i]呢？\n                因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。\n        *&#x2F;\n        for(int i&#x3D;3;i&lt;&#x3D;n;i++)&#123;\n            for(int j&#x3D;1;j&lt;i-1;j++)&#123;\n                dp[i]&#x3D;Math.max(dp[i],Math.max((j*(i-j)),j*dp[i-j]));\n            &#125;\n        &#125;\n        return dp[n];\n\n\n\n    &#125;\n&#125;\n\n","slug":"343-整数拆分","date":"2022-08-15T02:23:02.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"4c356b6b38bff815cbd4488ea4093633","title":"63.不同路径Ⅱ","content":"63.不同路径Ⅱ题目描述：\n不同路径 II\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n网格中的障碍物和空位置分别用 1 和 0 来表示。\nexample 1:\n输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]\n输出：2\n解释：3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右\n\nexample 2:\n输入：obstacleGrid &#x3D; [[0,1],[0,0]]\n输出：1\n\n提示：\nm &#x3D;&#x3D; obstacleGrid.lengthn &#x3D;&#x3D; obstacleGrid[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 100obstacleGrid[i][j] 为 0 或 1\n题目来源：https://leetcode.cn/problems/unique-paths-ii\n题解：class Solution &#123;\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;\n        if(obstacleGrid&#x3D;&#x3D;null||obstacleGrid.length&#x3D;&#x3D;0||obstacleGrid[0].length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        int m&#x3D;obstacleGrid.length;\n        int n&#x3D;obstacleGrid[0].length;\n        &#x2F;&#x2F;定义dp数组，dp[i][j]表示从(0,0)出发到达（i，j）所包含的路线数\n        int[][] dp&#x3D;new int[m][n];\n        &#x2F;&#x2F;对dp数组进行初始化，注意，dp[i][0]和dp[0][j]为1，若遇到障碍，则为0。\n        for(int i&#x3D;0;i&lt;m&amp;&amp;obstacleGrid[i][0]&#x3D;&#x3D;0;i++)&#123;\n            dp[i][0]&#x3D;1;\n        &#125;\n        for(int j&#x3D;0;j&lt;n&amp;&amp;obstacleGrid[0][j]&#x3D;&#x3D;0;j++)&#123;\n            dp[0][j]&#x3D;1;\n        &#125;\n        &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]\n        for(int i&#x3D;1;i&lt;m;i++)&#123;\n            for(int j&#x3D;1;j&lt;n;j++)&#123;\n                &#x2F;&#x2F;若当前遍历的位置（i,j）不是障碍时，才进行赋值\n                if(obstacleGrid[i][j]!&#x3D;1)&#123;\n                    dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];\n                &#125;\n            &#125;\n        &#125;\n        return dp[m-1][n-1];\n\n    &#125;\n&#125;\n\n","slug":"63-不同路径Ⅱ","date":"2022-08-14T02:53:19.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"0469ba4c963055a01468ddd6a005bdd0","title":"62.爬楼梯","content":"62.爬楼梯题目描述：\n不同路径\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\nexample 1:\n输入：m &#x3D; 3, n &#x3D; 7\n输出：28\n\nexample 2:\n输入：m &#x3D; 3, n &#x3D; 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右\n3. 向下 -&gt; 向右 -&gt; 向下\n\nexample 3：\n输入：m &#x3D; 7, n &#x3D; 3\n输出：28\n\nexample 4:\n输入：m &#x3D; 3, n &#x3D; 3\n输出：6\n\n提示：\n题目来源：https://leetcode.cn/problems/unique-paths\n题解：class Solution &#123;\n    public int uniquePaths(int m, int n) &#123;\n        &#x2F;&#x2F;检查参数合法性\n        if(m&#x3D;&#x3D;0||n&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;定义dp数组，其中dp[i][j]表示的是从(0,0)点到达(i,j)点所存在的路径的数量\n        int[][] dp&#x3D;new int[m][n];\n        &#x2F;&#x2F;对dp进行初始化，dp[i][0]和dp[0][i]都初始化为1，因为从（0，0）点出发都是一条路径，因为机器人只能向下或者向右移动。\n        for(int i&#x3D;0;i&lt;m;i++)&#123;\n            dp[i][0]&#x3D;1;\n        &#125;\n        for(int j&#x3D;0;j&lt;n;j++)&#123;\n            dp[0][j]&#x3D;1;\n        &#125;\n        &#x2F;&#x2F;确定状态变化公式：dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];因为到达i，j一共就两个方向\n        for(int i&#x3D;1;i&lt;m;i++)&#123;\n            for(int j&#x3D;1;j&lt;n;j++)&#123;\n                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];\n            &#125;\n        &#125;\n        return dp[m-1][n-1];\n    &#125;\n&#125;\n\n","slug":"62-爬楼梯","date":"2022-08-14T02:00:07.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"8680cdb46230a68df8607aa6423f9a66","title":"746.使用最小的花费爬楼梯","content":"746.花费最小的花费爬楼梯题目描述：\n使用最小花费爬楼梯\n\n给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n请你计算并返回达到楼梯顶部的最低花费。\nexample 1：\n输入：cost &#x3D; [10,15,20]\n输出：15\n解释：你将从下标为 1 的台阶开始。\n- 支付 15 ，向上爬两个台阶，到达楼梯顶部。\n总花费为 15 。\n\nexample 2:\n输入：cost &#x3D; [1,100,1,1,1,100,1,1,100,1]\n输出：6\n解释：你将从下标为 0 的台阶开始。\n- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。\n- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。\n- 支付 1 ，向上爬一个台阶，到达楼梯顶部。\n总花费为 6 。\n\n提示：\n\n2 &lt;= cost.length &lt;= 1000\n0 &lt;= cost[i] &lt;= 999\n\n题目来源：https://leetcode.cn/problems/min-cost-climbing-stairs\n题解：class Solution &#123;\n    public int minCostClimbingStairs(int[] cost) &#123;\n        &#x2F;&#x2F;检查参数的合法性\n        if(cost&#x3D;&#x3D;null||cost.length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;dp数组的长度和花费数组的长度一致\n        int[] dp&#x3D;new int[cost.length];\n        &#x2F;&#x2F;dp数组初始化，第0节台阶花费cost[0]（每次登上一节）,登上第1节台阶花费cost[1](每次登上两节)\n        dp[0]&#x3D;cost[0];\n        dp[1]&#x3D;cost[1];\n        &#x2F;&#x2F;递推直到cost.length-1节台阶\n        for(int i&#x3D;2;i&lt;cost.length;i++)&#123;\n            dp[i]&#x3D;Math.min(dp[i-1],dp[i-2])+cost[i];\n        &#125;\n        &#x2F;&#x2F;因为登上最后一节台阶是不费力的，所以选择dp末尾两个的最小值即可。\n        return Math.min(dp[cost.length-1],dp[cost.length-2]);\n    &#125;\n&#125;\n\n","slug":"746-使用最小的花费爬楼梯","date":"2022-08-13T04:38:58.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"51d051a502cdfcaa3007846e503519d5","title":"70.爬楼梯","content":"70.爬楼梯题目描述：\n爬楼梯\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\nexample 1:\n输入：n &#x3D; 2\n输出：2\n解释：有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\n\nexample 2:\n输入：n &#x3D; 3\n输出：3\n解释：有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n\n提示：\n\n1 &lt;= n &lt;= 45\n\n题目来源：https://leetcode.cn/problems/climbing-stairs/\n题解：class Solution &#123;\n    public int climbStairs(int n) &#123;\n        if(n&lt;&#x3D;2)&#123;\n            return n; \n        &#125;\n        &#x2F;&#x2F;定义dp数组\n        int[] dp&#x3D;new int[n+1];\n        dp[0]&#x3D;0;\n        dp[1]&#x3D;1;\n        dp[2]&#x3D;2;\n        for(int i&#x3D;3;i&lt;&#x3D;n;i++)&#123;\n            &#x2F;&#x2F;递推公式：dp[i]&#x3D;dp[i-1]+dp[i-2]\n            dp[i]&#x3D;dp[i-1]+dp[i-2];\n        &#125;\n        return dp[n];\n    &#125;\n&#125;\n\n","slug":"70-爬楼梯","date":"2022-08-13T04:05:38.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"084b6d4a3eb1719c740e694cde17f8e9","title":"509.斐波那契数列","content":"509.斐波那契数列\n斐波那契数\n\n斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\nF(0) &#x3D; 0，F(1) &#x3D; 1\nF(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1\n\n给定 n ，请计算 F(n) 。\n题目描述：example 1:\n输入：n &#x3D; 2\n输出：1\n解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1\n\nexample 2:\n输入：n &#x3D; 3\n输出：2\n解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2\n\nexample 3:\n输入：n &#x3D; 4\n输出：3\n解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3\n\n提示：\n\n0 &lt;= n &lt;= 30\n\n题目来源：https://leetcode.cn/problems/fibonacci-number/\n题解：class Solution &#123;\n    public int fib(int n) &#123;\n        if(n&lt;2)\n            return n;\n        &#x2F;&#x2F;确定dp数组，dp[i]\n        int[] dp&#x3D;new int[n+1];\n        &#x2F;&#x2F;确定递推公式，f(n)&#x3D;f(n-1)+f(n-2)\n        &#x2F;&#x2F;dp数组的初始化，dp[0]&#x3D;0,dp[1]&#x3D;1\n        dp[0]&#x3D;0;\n        dp[1]&#x3D;1;\n        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n            dp[i]&#x3D;dp[i-1]+dp[i-2];\n        &#125;\n        return dp[n];\n\n    &#125;\n&#125;\n\n","slug":"斐波那契数列","date":"2022-08-13T03:54:49.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"401c664502fc1c05444b73fd7436e5f7","title":"1091.二进制矩阵中的最短路径","content":"1091.二进制矩阵中的最短路径题目描述：\n二进制矩阵中的最短路径\n\n难度中等214收藏分享切换为英文接收动态反馈\n给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。\n二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：\n\n路径途经的所有单元格都的值都是 0 。\n路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。\n\n畅通路径的长度 是该路径途经的单元格总数。\nexample:1\n输入：grid &#x3D; [[0,1],[1,0]]\n输出：2\n\nexample 2:\n输入：grid &#x3D; [[0,0,0],[1,1,0],[1,1,0]]\n输出：4\n\nexample 3:\n输入：grid &#x3D; [[1,0,0],[1,1,0],[1,1,0]]\n输出：-1\n\n提示：\n\nn == grid.length\nn == grid[i].length\n1 &lt;= n &lt;= 100\ngrid[i][j] 为 0 或 1\n\n题目来源：https://leetcode.cn/problems/shortest-path-in-binary-matrix/\n题解：\nclass Solution &#123;\n    public int shortestPathBinaryMatrix(int[][] grid) &#123;\n        &#x2F;&#x2F;判断参数是否合法\n        if(grid&#x3D;&#x3D;null||grid.length&#x3D;&#x3D;0||grid[0].length&#x3D;&#x3D;0)&#123;\n            return -1;\n        &#125;        \n        int m&#x3D;grid.length;\n        int n&#x3D;grid[0].length;\n        &#x2F;&#x2F;判断起点和终点是否合法\n        if(grid[0][0]&#x3D;&#x3D;1||grid[m-1][m-1]&#x3D;&#x3D;1)&#123;\n            return -1;\n        &#125;\n        &#x2F;&#x2F;定义8个移动方向\n        int[][] dirs&#x3D;&#123;&#123;1,1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;-1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;\n        &#x2F;&#x2F;创建队列，加入起点坐标\n        Queue&lt;int[]&gt; queue&#x3D;new LinkedList&lt;&gt;();\n        &#x2F;&#x2F;起点设为1，防止重复遍历,初始化层次计数\n        queue.offer(new int[]&#123;0,0&#125;);\n        grid[0][0]&#x3D;1;\n        int path&#x3D;1;\n        &#x2F;&#x2F;遍历队列\n        while(!queue.isEmpty())&#123;\n            &#x2F;&#x2F;这里获取队列大小的目的是为了区分当前遍历层次和下一个层次，若不记录size，则在队列加入新的元素后无法区分路径长度。\n            int size&#x3D;queue.size();\n            &#x2F;&#x2F;当该层的元素（size大小），全部遍历完毕，就path+1，然后进入下一层。\n            for(int i&#x3D;0;i&lt;size;i++)&#123;\n                int[] cur&#x3D;queue.poll();\n                int x&#x3D;cur[0];\n                int y&#x3D;cur[1];\n                if(x&#x3D;&#x3D;m-1&amp;&amp;y&#x3D;&#x3D;n-1)&#123;\n                    return path;\n                &#125;\n\t\t\t\t&#x2F;&#x2F;将与当前cur相邻的八个方向元素进行遍历，符合条件的入队\n                for(int[] dir:dirs)&#123;\n                    int x1&#x3D;x+dir[0];\n                    int y1&#x3D;y+dir[1];\n                    if(x1&gt;&#x3D;0&amp;&amp; x1&lt;m &amp;&amp; y1&gt;&#x3D;0&amp;&amp; y1&lt;n&amp;&amp; grid[x1][y1]&#x3D;&#x3D;0)&#123;\n                        queue.offer(new int[]&#123;x1,y1&#125;);\n                        grid[x1][y1]&#x3D;1;\n                    &#125;\n                &#125;\n\n            &#125;\n            path++;\n\n        &#125;\n\n        return -1;    \n    &#125;\n&#125;\n\n\n","slug":"1091-二进制矩阵中的最短路径","date":"2022-08-13T02:39:07.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"3a8637d28c1ed4973b1acb4bbd24e5f2","title":"不同的二叉搜索树Ⅱ","content":"95.不同的二叉搜索树Ⅱ题目描述：\n不同的二叉搜索树 II\n\n给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。\nexample 1:\n输入：n &#x3D; 3\n输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n\nexample 2:\n输入：n &#x3D; 1\n输出：[[1]]\n\n提示：\n1&lt;&#x3D;n&lt;&#x3D;8\n题目来源：https://leetcode.cn/problems/unique-binary-search-trees-ii/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public List&lt;TreeNode&gt; generateTrees(int n) &#123;\n        &#x2F;&#x2F;若n&#x3D;0则直接返回一个空的列表\n        if(n&#x3D;&#x3D;0)&#123;\n            return new ArrayList&lt;TreeNode&gt;();\n        &#125;\n        &#x2F;&#x2F;递归生成二叉搜索树\n        return generateNodes(1,n);\n    &#125;\n\n    public List&lt;TreeNode&gt; generateNodes(int left,int right)&#123;\n        &#x2F;&#x2F;返回值，存放不同的头节点，（头节点包含子对象left和right，我们只管传入不同的二叉搜索树的头节点即可）\n        List&lt;TreeNode&gt; list&#x3D;new ArrayList&lt;TreeNode&gt;();\n        &#x2F;&#x2F;当left&gt;right表示左边或者右边没有节点了，返回null\n        if(left&gt;right)&#123;\n            list.add(null);\n            return list;\n        &#125;\n        &#x2F;&#x2F;循环所有的节点，将每个遍历的节点作为根节点\n        for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;\n            &#x2F;&#x2F;获取左子树和右子树的所有可能的组合\n            List&lt;TreeNode&gt; left_sub_tree&#x3D;generateNodes(left,i-1);\n            List&lt;TreeNode&gt; right_sub_tree&#x3D;generateNodes(i+1,right);\n            &#x2F;&#x2F;对根节点进行拼接。组成不同的二叉搜索树\n            for(TreeNode a:left_sub_tree)&#123;\n                for(TreeNode b:right_sub_tree)&#123;\n                    &#x2F;&#x2F;注意根节点在此处创建，因为左右子树不同代表不同的二叉搜索树\n                    TreeNode root&#x3D;new TreeNode(i);\n                    root.left&#x3D;a;\n                    root.right&#x3D;b;\n                    &#x2F;&#x2F;将该二叉搜索树存入list\n                    list.add(root);\n                &#125;\n            &#125;\n\n        &#125;\n        return list;\n\n    &#125;\n&#125;\n\n","slug":"不同的二叉搜索树Ⅱ","date":"2022-08-12T02:59:34.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"a2d24fc395bf8cf342e3b277c21f191b","title":"为运算表达式设计优先级","content":"241.为运算表达式设计优先级题目描述：\n为运算表达式设计优先级\n\n给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。\n生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104 。\nexample1:\n输入：expression &#x3D; &quot;2-1-1&quot;\n输出：[0,2]\n解释：\n((2-1)-1) &#x3D; 0 \n(2-(1-1)) &#x3D; 2\n\nexample2:\n输入：expression &#x3D; &quot;2*3-4*5&quot;\n输出：[-34,-14,-10,-10,10]\n解释：\n(2*(3-(4*5))) &#x3D; -34 \n((2*3)-(4*5)) &#x3D; -14 \n((2*(3-4))*5) &#x3D; -10 \n(2*((3-4)*5)) &#x3D; -10 \n(((2*3)-4)*5) &#x3D; 10\n\n提示：\n提示：\n1 &lt;&#x3D; expression.length &lt;&#x3D; 20expression 由数字和算符 ‘+’、’-‘ 和 ‘*’ 组成。输入表达式中的所有整数值在范围 [0, 99] \n题目来源：https://leetcode.cn/problems/different-ways-to-add-parentheses\n题解：class Solution &#123;\n    char[] cs;\n    public List&lt;Integer&gt; diffWaysToCompute(String s) &#123;\n        &#x2F;&#x2F;转化为字符数组\n        char[] chars&#x3D;s.toCharArray();\n        &#x2F;&#x2F;调用递归函数，初始边界是0~s.length()-1\n        return dfs(chars,0,chars.length-1);\n    &#125;\n\n    public List&lt;Integer&gt; dfs(char[] chars,int left,int right)&#123;\n        &#x2F;&#x2F;创建返回值列表\n        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();\n        &#x2F;&#x2F;循环遍历每一个字符\n        for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;\n            &#x2F;&#x2F;若为数字字符，则跳过\n            if(chars[i]&lt;&#x3D;&#39;9&#39;&amp;&amp;chars[i]&gt;&#x3D;&#39;0&#39;)\n                continue;\n            &#x2F;&#x2F;若为运算符字符，则递归左边的所有运算结果和右边的所有运算结果\n            List&lt;Integer&gt; left_ret&#x3D;dfs(chars,left,i-1);\n            List&lt;Integer&gt; right_ret&#x3D;dfs(chars,i+1,right);\n            &#x2F;&#x2F;遍历左边所有的运算结果和右边所有的运算结果，根据当前遇到的运算符进行相应的运算\n            for(int a:left_ret)&#123;\n                for(int b:right_ret)&#123;\n                    if(chars[i]&#x3D;&#x3D;&#39;+&#39;)&#123;\n                        list.add(a+b);\n                    &#125;else if(chars[i]&#x3D;&#x3D;&#39;-&#39;)&#123;\n                        list.add(a-b);\n                    &#125;else if(chars[i]&#x3D;&#x3D;&#39;*&#39;)&#123;\n                        list.add(a*b);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;若list为空，则表示全部为数字字符，则将数字字符加入到list中\n        if(list.isEmpty())&#123;\n            int ret&#x3D;0;\n            for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;\n                ret&#x3D;ret*10+(chars[i]-&#39;0&#39;);\n            &#125;\n            list.add(ret);\n        &#125;\n        return list;\n    &#125;\n\n&#125;\n\n","slug":"为运算表达式设计优先级","date":"2022-08-12T02:29:37.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"8d8d1a0d9f17dbec885c291446cece5c","title":"寻找旋转排序数组中的最小值","content":"153.寻找旋转排序数组中的最小值题目描述：153. 寻找旋转排序数组中的最小值已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：\n\n若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]\n若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]\n\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\nexample 1：\n输入：nums &#x3D; [3,4,5,1,2]\n输出：1\n解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n\nexample 2：\n输入：nums &#x3D; [4,5,6,7,0,1,2]\n输出：0\n解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n\nexample 3:\n输入：nums &#x3D; [11,13,15,17]\n输出：11\n解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n\n题目来源：https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/\n题解：class Solution &#123;\n    public int findMin(int[] nums) &#123;\n        int left&#x3D;0;\n        int right&#x3D;nums.length-1;\n        int ret&#x3D;0;\n        while(left&lt;right)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            &#x2F;&#x2F;在访问时需要访问mid以及右边的元素，所以至少访问两个元素，left&lt;right为循环结束的条件\n            if(nums[mid]&gt;nums[right])&#123;\n                left&#x3D;mid+1;\n            &#125;else&#123;\n                right&#x3D;mid;\n            &#125;\n        &#125;\n        return nums[right];\n    &#125;\n&#125;\n\n","slug":"寻找旋转排序数组中的最小值","date":"2022-08-08T03:56:07.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"d84518667e657cd3814bae0fb73c941b","title":"寻找峰值","content":"162. 寻找峰值题目描述：162. 寻找峰值峰值元素是指其值严格大于左右相邻值的元素。\n给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n你可以假设 nums[-1] = nums[n] = -∞ 。\n你必须实现时间复杂度为 O(log n) 的算法来解决此问题。\nexample 1:\n输入：nums &#x3D; [1,2,3,1]\n输出：2\n解释：3 是峰值元素，你的函数应该返回其索引 2。\n\nexample 2:\n输入：nums &#x3D; [1,2,1,3,5,6,4]\n输出：1 或 5 \n解释：你的函数可以返回索引 1，其峰值元素为 2；\n     或者返回索引 5， 其峰值元素为 6。\n\n\n\n题目来源：https://leetcode.cn/problems/find-peak-element/\n题解：class Solution &#123;\n    public int findPeakElement(int[] nums) &#123;\n        if(nums.length&#x3D;&#x3D;1)&#123;\n            return 0;\n        &#125;\n        int left&#x3D;0;\n        int right&#x3D;nums.length-1;\n        int ret&#x3D;0;\n        &#x2F;&#x2F;这里使用的是左开右闭区间，不可使用左闭右闭区间，因为在进行查找时需要和右边的元素进行比较，所以必须保证，搜索区间包含至少两个元素，因此left&lt;&#x3D;right时，是不满足条件的，当left&#x3D;&#x3D;right进行判断时，会发生数组越界异常，因此该题只可以使用左闭右开区间。\n        while(right&gt;left)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            if(nums[mid]&gt;nums[mid+1])&#123;\n\n                right&#x3D;mid;\n            &#125;else&#123;\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return right;\n    &#125;\n&#125;\n\n","slug":"寻找峰值","date":"2022-08-08T03:00:38.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"37fafcaad932621c324a857d69f2ce34","title":"第一个错误版本","content":"278.第一个错误版本题目描述：278. 第一个错误的版本你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\n你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\nexample 1:\n输入：n &#x3D; 5, bad &#x3D; 4\n输出：4\n解释：\n调用 isBadVersion(3) -&gt; false \n调用 isBadVersion(5) -&gt; true \n调用 isBadVersion(4) -&gt; true\n所以，4 是第一个错误的版本。\n\nexample 2:\n输入：n &#x3D; 1, bad &#x3D; 1\n输出：1\n\n题目来源：https://leetcode.cn/problems/first-bad-version/\n题解：\n&#x2F;&#x2F;左闭右闭区间，循环结束时left&gt;right，则此时最后一次得到的mid（即最后一次查找到的版本是没有保存的，所以需要ret变量进行保存）\n&#x2F;* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); *&#x2F;\n\npublic class Solution extends VersionControl &#123;\n    public int firstBadVersion(int n) &#123;\n        int left&#x3D;0;\n        int right&#x3D;n;\n        int ret&#x3D;-1;\n        while(left&lt;&#x3D;right)&#123;\n            int mid&#x3D;left+(right-left)&#x2F;2;\n            &#x2F;&#x2F;当前版本如果是错误版本，则当前版本可能是第一个出现错误的版本，需要暂存\n            if(isBadVersion(mid))&#123;\n                ret&#x3D;mid;\n                right&#x3D;mid-1;\n            &#125;else&#123;\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return ret;\n\n        \n    &#125;\n&#125;\n\n&#x2F;* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); *&#x2F;\n\npublic class Solution extends VersionControl &#123;\n    public int firstBadVersion(int n) &#123;\n        int left&#x3D;0;\n        int right&#x3D;n;\n        int ret&#x3D;-1;\n        &#x2F;&#x2F;循环的结束条件是left&#x3D;right，并且right&#x3D;最后一个mid，所以返回值也是最后一个mid&#x3D;right&#x3D;left\n        while(left&lt;right)&#123;\n            int mid&#x3D;left+(right-left)&#x2F;2;\n            &#x2F;&#x2F;左闭右开区间，循环结束条件是left&lt;right,下一轮循环是从left~right-1，右边是开区间\n            if(isBadVersion(mid))&#123;\n                &#x2F;&#x2F; ret&#x3D;mid;\n                right&#x3D;mid;\n            &#125;else&#123;\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return right;\n\n        \n    &#125;\n&#125;\n\n","slug":"第一个错误版本","date":"2022-08-08T02:00:30.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"ea76d2e3b8ba7df05f2a9007a5c4d57e","title":"搜索旋转排序数组","content":"33. 搜索旋转排序数组题目描述：33. 搜索旋转排序数组整数数组 nums 按升序排列，数组中的值 互不相同 。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\nexample 1:\n输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0\n输出：4\n\nexample 2:\n输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3\n输出：-1\n\nexample 3:\n输入：nums &#x3D; [1], target &#x3D; 0\n输出：-1\n\n题目来源：https://leetcode.cn/problems/search-in-rotated-sorted-array/\n题解：class Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        &#x2F;&#x2F;初始边界\n        int left&#x3D;0;\n        int right&#x3D;nums.length-1;\n        &#x2F;&#x2F;区间\n        while(left&lt;&#x3D;right)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            if(nums[mid]&#x3D;&#x3D;target) return mid;\n            &#x2F;&#x2F;mid位于左边的升序序列当中\n            if(nums[mid]&gt;&#x3D;nums[left])&#123;\n                &#x2F;&#x2F;target位于左侧有序序列中\n                if(target&lt;nums[mid]&amp;&amp;target&gt;&#x3D;nums[left])&#123;\n                    right&#x3D;mid-1;\n                &#125;else&#123;\n                    left&#x3D;mid+1;\n                &#125;\n\n            &#125;else&#123;              &#x2F;&#x2F;右侧为升序\n                &#x2F;&#x2F;target位于右侧有序序列中\n                if(target&gt;nums[mid]&amp;&amp;target&lt;&#x3D;nums[right])&#123;\n                    left&#x3D;mid+1;\n                &#125;else&#123;\n                    right&#x3D;mid-1;\n                &#125;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n\n","slug":"搜索旋转排序数组","date":"2022-08-07T02:54:15.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-08-07T02:30:53.375Z","categories_index":"","tags_index":"","author_index":"LiuQuanZe"},{"id":"03e1cda0baa3a649921c8af01fed4d68","title":"我的第一篇博客","content":"第一篇博客哈哈，我有自己的博客啦！\n","slug":"demo01","date":"2022-08-07T02:30:53.353Z","categories_index":"个人","tags_index":"记录,日常","author_index":"LiuQuanZe"},{"id":"5a834cb8bdd34deef00d023624eeeb11","title":"有序数组的单一元素","content":"540. 有序数组的单一元素题目描述：\n给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。\n请你找出并返回只出现一次的那个数。\n你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。\nexample 1：\n输入: nums &#x3D; [1,1,2,3,3,4,4,8,8]\n输出: 2\n\nexample 2:\n输入: nums &#x3D;  [3,3,7,7,10,11,11]\n输出: 10\n\n题目来源：https://leetcode.cn/problems/single-element-in-a-sorted-array\n题解：class Solution &#123;\n    public int singleNonDuplicate(int[] nums) &#123;\n        if(nums.length&#x3D;&#x3D;1)&#123;\n            return nums[0];\n        &#125;\n        int left&#x3D;0;\n        int right&#x3D;nums.length-1;\n        int result&#x3D;0;\n        while(right&gt;left)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            &#x2F;&#x2F;若mid为偶数，则判断mid与mid+1是否相等，若mid为奇数，则判断mid和mid-1是否相等\n            if(nums[mid]&#x3D;&#x3D;nums[mid^1])&#123;\n                &#x2F;&#x2F;若相等则表示单个数字x位于右边\n                &#x2F;&#x2F;并且因为相等，所以mid所指向的数字一定不是单个数字x\n                left&#x3D;mid+1;\n            &#125;else&#123;\n                &#x2F;&#x2F;若不相等，则表示单个数字x位于左边，并且因为不相等，所以当前mid所指向的数字可能就是我们要找的单个数字x,不能直接提剔除\n                right&#x3D;mid;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;直接返回right\n        return nums[right];\n\n    &#125;\n&#125;\n\n\n\n","slug":"有序数组的单一元素","date":"2022-08-06T02:23:53.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"bf9943093888157a40e49bab81aa424f","title":"Pycharm模块不存在","content":"Pycharm模块不存在问题描述：当运行Python文件时，出现以下报错：\npython中已经用pip安装了某模块，但pycharm中为什么仍然显示没有该模块\n\n出现原因：pycharm里面自带一个Python解释器，而这个里面是没有几个模块的。因为咱们在DOS命令行里面下载的模块是下载到Python的解释器里而不是pycharm里面的那个。\n解决方案：打开pycharm依次点击file-&gt;Settings-&gt;Project Interpreter；\n可以看到当前项目正在使用的Python解释器，即Project Interpreter那一栏。\n可以将其替换为本机上安装的Python解释器，即cmd中可以查看到的python解释器：\n1.查找本机Python的安装地址：\nC:\\Users\\26485&gt;where python\nC:\\Users\\26485\\AppData\\Local\\Programs\\Python\\Python39\\python.exe\nC:\\Users\\26485\\AppData\\Local\\Microsoft\\WindowsApps\\python.exe\n\n2.在Project Interpreter添加对应地址中新的解释器，添加完成后，可以看到我们在本机环境下已经安装的模块和工具包。\n","slug":"Pycharm模块不存在","date":"2022-08-05T02:33:06.000Z","categories_index":"Python","tags_index":"报错,Pycharm","author_index":"LiuQuanZe"},{"id":"d776ea82847944d1f9a7d73d3912befe","title":"寻找比目标字母大的最小字母","content":"744. 寻找比目标字母大的最小字母题目描述：给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。\n在比较时，字母是依序循环出现的。举个例子：\n如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’\nexample 1:\n输入: letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]，target &#x3D; &quot;a&quot;\n输出: &quot;c&quot;\n\nexample 2:\n输入: letters &#x3D; [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target &#x3D; &quot;c&quot;\n输出: &quot;f&quot;\n\nexample 3:\n输入: letters &#x3D; [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target &#x3D; &quot;d&quot;\n输出: &quot;f&quot;\n\n\n\n题目来源：https://leetcode.cn/problems/find-smallest-letter-greater-than-target\n题解：1.二分法：开区间\nclass Solution &#123;\n    public char nextGreatestLetter(char[] letters, char target) &#123;\n   \n        &#x2F;&#x2F;当target大于数组的最大值的时候，表示数组中所有元素均小于target，因为数组中字符是有序的。\n        if(target&gt;&#x3D;letters[letters.length-1])&#123;\n            return letters[0];\n        &#125;\n        &#x2F;&#x2F;若上述if语句不符合则表示该数组必定存在大于target的元素。\n        int left&#x3D;0;\n        int right&#x3D;letters.length-1;\n                &#x2F;&#x2F; 如果为左闭右闭那么while里面的判断语句是left&lt;&#x3D;right ；若为左闭右开或者左开右闭，则while的判断语句是left &lt; right\n        &#x2F;&#x2F;左开右闭：left&#x3D;mid;right&#x3D;mid-1;\n        &#x2F;&#x2F;左闭右开：left&#x3D;mid+1;right&#x3D;mid;\n        while(left&lt;right)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            if(letters[mid]&gt;target)&#123;    &#x2F;&#x2F;当mid指向的元素大于target时，则有可能是最小的大于target的元素\n                right&#x3D;mid;\n            &#125;else&#123;     &#x2F;&#x2F;当mid元素小于或等于target时，mid指向的元素必然不是我们最终要找的元素，可以直接跳过mid指向的元素，mid+1\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return letters[left];\n     \n\n    &#125;\n&#125;\n\n\n2.线性搜索：\nclass Solution &#123;\n    public char nextGreatestLetter(char[] letters, char target) &#123;\n        int min&#x3D;Integer.MAX_VALUE;\n        int min_index&#x3D;0;\n        for(int i&#x3D;0;i&lt;letters.length;i++)&#123;\n            &#x2F;&#x2F;i指向的元素在target后面，则比较当前维护的最短距离\n            if(letters[i]-target&gt;0)&#123;\n                min&#x3D;Math.min(min,letters[i]-target);\n                if(min&#x3D;&#x3D;letters[i]-target)&#123;\n                    min_index&#x3D;i;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;若target大于letters数组中的所有元素，则直接返回0号元素\n        if(min&#x3D;&#x3D;Integer.MAX_VALUE)&#123;\n            return letters[0];\n        &#125;\n        return letters[min_index];\n    &#125;\n&#125;\n\n3.二分法：闭区间\nclass Solution &#123;\n    public char nextGreatestLetter(char[] letters, char target) &#123;\n        if(letters[letters.length-1]&lt;&#x3D;target)&#123;\n            return letters[0];\n        &#125;\n        int right&#x3D;letters.length;\n        int left&#x3D;0;\n        int result&#x3D;0;\n        &#x2F;&#x2F;闭区间写法，left&lt;&#x3D;right；right&#x3D;mid-1;left&#x3D;mid+1;因为当mid指向的元素大于target时，该元素可能就是我们要找的目标元素，所以需要记录mid指向的元素result&#x3D;mid;，对比开区间，right&#x3D;mid；left&lt;right当left&#x3D;&#x3D;right时结束循环，不会漏掉这个解，但是闭区间更清楚一些\n        while(left&lt;&#x3D;right)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            if(letters[mid]&gt;target)&#123;\n                result&#x3D;mid;\n                right&#x3D;mid-1;\n            &#125;else&#123;\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return letters[result];\n    &#125;\n&#125;\n\n\n\n","slug":"寻找比目标字母大的最小字母","date":"2022-08-05T01:53:07.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"3b8822123bb08af7e60b15ed39819f81","title":"x的平方根","content":"69. x的平方根题目描述：给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\nexample 1:\n输入：x &#x3D; 4\n输出：2\n\nexample 2:\n输入：x &#x3D; 8\n输出：2\n解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n\n\n\n题目来源：https://leetcode.cn/problems/sqrtx\n题解：&#x2F;&#x2F;左开右闭区间\nclass Solution &#123;\n    public int mySqrt(int x) &#123;\n        if(x&#x3D;&#x3D;1)&#123;\n            return 1;\n        &#125;\n        int left&#x3D;0;\n        int right&#x3D;x;\n        int result&#x3D;0;\n        while(left&lt;right)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            if((long)mid*mid&lt;&#x3D;x)&#123;\n                result&#x3D;mid;\n                left&#x3D;mid+1;\n            &#125;else&#123;\n                right&#x3D;mid;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\nint mid &#x3D; (left + right) &#x2F; 2; 与 int mid &#x3D; left + (right - left) &#x2F; 2; 二者的区别\n    二者结果一样，但是left + right 可能会溢出\n\n&#x2F;&#x2F;左闭右闭区间\nclass Solution &#123;\n    public int mySqrt(int x) &#123;\n        &#x2F;&#x2F;闭区间\n        int left&#x3D;0;\n        int right&#x3D;x;\n        &#x2F;&#x2F;暂存符合条件的元素\n        int result&#x3D;0;\n        while(left&lt;&#x3D;right)&#123;\n            int mid&#x3D;left+(right-left)&#x2F;2;\n            if((long)mid*mid&lt;&#x3D;x)&#123;\n                result&#x3D;mid;\n                left&#x3D;mid+1;\n            &#125;else&#123;\n                right&#x3D;mid-1;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n","slug":"x的平方根","date":"2022-08-04T01:36:47.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"b3d8a41da3eeb7700876b944e097bd03","title":"划分字母区间","content":"763.划分字母区间题目描述：763. 划分字母区间字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。\nexample 1:\n输入：S &#x3D; &quot;ababcbacadefegdehijhklij&quot;\n输出：[9,7,8]\n解释：\n划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。\n每个字母最多出现在一个片段中。\n像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。\n\n题目来源：https://leetcode.cn/problems/partition-labels/\n题解：class Solution &#123;\n    public List&lt;Integer&gt; partitionLabels(String s) &#123;\n        &#x2F;** \n        贪心算法：\n            由于每个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。\n            在得到每个字母的最后一次出现的下标位置之后，可以使用贪心算法将字符串划分为尽可能多的片段，具体做法如下：\n            1.从左到右遍历字符串，遍历的同时维护当前片段的开始下标start和结束下标end，初始化start&#x3D;end&#x3D;0；\n            2.对于每一个访问到的字母c，得到当前字母的最后一次出现的下标位置endc，则当前片段的结束下标一定不会小于endc，因此令end&#x3D;max(end,endc);\n            3.当访问到下标end时，当前片段访问结束，当前片段的下标范围是[start,end]，长度为end-start+1，将当前片段的长度添加到返回值，然后令start&#x3D;end+1，继续寻找下一个片段；\n            4.重复上述过程，知道遍历完字符串\n        *&#x2F;\n        用于记录每个字母出现的最后位置\n        int[] chars&#x3D;new int[26];\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            &#x2F;&#x2F;将当前字母在s中出现的位置存入chars数组中对应字母的下标位置中\n            chars[s.charAt(i)-&#39;a&#39;]&#x3D;i;\n        &#125;\n        List&lt;Integer&gt; partition&#x3D;new ArrayList&lt;&gt;();\n        int start&#x3D;0;\n        int end&#x3D;0;\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            &#x2F;&#x2F;得到对应字母c的最迟出现位置，若endc&gt;end则更新end的值，表示出现了比之前end对应字母还晚的字母，如果endc&lt;end则表示字母c的end所对应的字母的最晚出现位置已经在c的最晚出现位置之后了\n            end&#x3D;Math.max(end,chars[s.charAt(i)-&#39;a&#39;]);\n            if(end&#x3D;&#x3D;i)&#123;\n                &#x2F;&#x2F;添加片段长度，更新start的值\n                partition.add(end-start+1);\n                start&#x3D;end+1;\n            &#125;\n        &#125;\n        return partition;\n\n\n    &#125;\n&#125;\n\n\n\n","slug":"划分字母区间","date":"2022-08-03T02:16:17.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"f6c56b941ed067956656bab8c3d0bb61","title":"最大子数组和","content":"最大子数组和题目描述：\n最大子数组和\n\n给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\nexample 1:\n输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\nexample 2:\n输入：nums &#x3D; [1]\n输出：1\n\nexample 3:\n输入：nums &#x3D; [5,4,-1,7,8]\n输出：23\n\n题目来源：https://leetcode.cn/problems/maximum-subarray/\n题解：class Solution &#123;\n    public int maxSubArray(int[] nums) &#123;\n        &#x2F;*\n        贪心算法：从左到右跌倒，一个一个遍历，遇到sum&lt;0,则重置sum，，return记录每次出现的sum的值的最大值。\n        *&#x2F;\n        &#x2F;&#x2F;return的初始大小为整型数据的最小值，为了和sum进行比较时可以接受任意小的sum\n        int result&#x3D;Integer.MIN_VALUE;\n        int sum&#x3D;0;\n        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;\n            &#x2F;&#x2F;加上当前的被遍历的元素\n            sum+&#x3D;nums[i];\n            &#x2F;&#x2F;和result维护的之前sum的最大值进行比较，更新sum最大值\n            result&#x3D;Math.max(result,sum);\n            &#x2F;&#x2F;若当前和小于0，则重置sum的值为0，重新开始找子序列\n            if(sum&lt;0)&#123;\n                sum&#x3D;0;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n","slug":"最大子数组和","date":"2022-08-02T01:22:15.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"ec406ffdb14348b593a8eaccf18d5ae3","title":"非递减数列","content":"非递减数列题目描述：665. 非递减数列难度中等681收藏分享切换为英文接收动态反馈\n给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。\n我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]\nexample 1:\n输入: nums &#x3D; [4,2,3]\n输出: true\n解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。\n\nexample 2:\n输入: nums &#x3D; [4,2,1]\n输出: false\n解释: 你不能在只改变一个元素的情况下将其变为非递减数列。\n\n\n\n题目来源：https://leetcode.cn/problems/non-decreasing-array/\n题解：class Solution &#123;\n    public boolean checkPossibility(int[] nums) &#123;\n        &#x2F;**\n        贪心算法：三种逆序情况\n        1.当i&#x3D;1时，与前一个元素发生逆序，则改变前一个元素的值，【4，2，5】，当遍历至2时发生逆序，将4改为2；\n        2.当i&gt;1,并且与i-1元素发生逆序时，需要查看i-2位置的元素，若i-2位置小于或者等于i位置元素，则依旧改变i-2位置元素，eg【1, 4, 2, 5】遍历至2时发生逆序，由于1&lt;2依旧是有序的，只需要改变4即可，将4改为2；\n        3.当i&gt;1,并且与i-1元素发生逆序时，需要查看i-2位置的元素，若i-2位置大于i位置元素，则此时仅改变i-1位置的元素依旧是无法实现递增的，此时只能将i位置的元素修改为i-1位置的元素。eg【3, 4, 2, 5】，此时2与4发生逆序，若仅仅修改4的值是无法实现递增的，因为3依旧是大于2的，所以只能将2修改为4实现递增。\n        总结：\n        当 nums[i] 破坏了数组的单调递增时，即 nums[i] &lt; nums[i - 1]  时，为了让数组有序，我们发现一个规律（在上面三个例子中， nums[i] 都为 2， nums[i -1] 都为 4）：\n\n如例①的情况，当 i &#x3D; 1 ，那么修改 num[i- 1] ，不要动 nums[i] ，因为nums[i]后面的元素是啥我们还不知道呢，少动它为妙。\n如例②的情况，当 i &gt; 1 时，我们应该优先考虑把 nums[i - 1] 调小到 &gt;&#x3D; nums[i - 2] 并且 &lt;&#x3D; nums[i]。同样尽量不去修改 nums[i] ，理由同上。\n如例③的情况，当 i &gt; 1 且 nums[i] &lt; nums[i - 2] 时，我们无法调整 nums[i - 1] ，我们只能调整 nums[i] 到 nums[i - 1] 。\n         *&#x2F;\n\n\n\n        &#x2F;&#x2F;用于记录改变元素的数量\n        int count&#x3D;0;\n        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;\n            &#x2F;&#x2F;发生逆序，即不是递增\n            if(nums[i]&lt;nums[i-1])&#123;\n                &#x2F;&#x2F;当逆序发生在1位置,改变前一个元素的位置\n                if(i&#x3D;&#x3D;1)&#123;\n                    nums[i-1]&#x3D;nums[i];\n                &#125;else if(nums[i]&lt;nums[i-2])&#123;    &#x2F;&#x2F;i位置元素小于i-2位置，则改变i的值\n                    nums[i]&#x3D;nums[i-1];\n                &#125;else if(nums[i]&gt;&#x3D;nums[i-2])&#123;   &#x2F;&#x2F;i位置元素大于等于i-2位置，改变i-1位置\n                    nums[i-1]&#x3D;nums[i];\n                &#125;\n                if(++count&gt;1)&#123;\n                    return false;\n                &#125;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n\n\n参考资料：https://leetcode.cn/problems/non-decreasing-array/solution/3-zhang-dong-tu-bang-zhu-ni-li-jie-zhe-d-06gi/\n\n","slug":"非递减数列","date":"2022-08-01T02:10:59.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"82a606d2417be24205d07d3a23121174","title":"判断子序列","content":"392.判断子序列题目描述：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。\nexample 1:\n输入：s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;\n输出：true\n\nexample 2:\n输入：s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;\n输出：false\n\n题目来源：https://leetcode.cn/problems/is-subsequence/\n题解：class Solution &#123;\n    public boolean isSubsequence(String s, String t) &#123;\n        &#x2F;&#x2F;定义分别指向两个字符串序列的指针\n        int index_s&#x3D;0;\n        int index_t&#x3D;0;\n        &#x2F;&#x2F;当匹配成功，子序列后移，匹配失败，主序列后移&#x3D;&#x3D;贪心算法\n        while(index_s&lt;s.length()&amp;&amp;index_t&lt;t.length())&#123;\n            if(s.charAt(index_s)&#x3D;&#x3D;t.charAt(index_t))&#123;\n                index_s++;\n            &#125;\n            index_t++;\n        &#125;\n        &#x2F;&#x2F;当子序列达到末尾，表示子序列匹配成功，返回true\n        if(index_s&#x3D;&#x3D;s.length())&#123;\n            return true;\n        &#125;\n        &#x2F;&#x2F;否则表示匹配失败，返回false\n        return false;\n    &#125;\n&#125;\n\n","slug":"判断子序列","date":"2022-07-31T03:01:34.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"17a5d31322fb6873ed3794c44302ea45","title":"种花问题","content":"605.种花问题题目描述：假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。\n给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。\nexample 1:\n输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1\n输出：true\n\nexample 2:\n输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2\n输出：false\n\n\n\n题目来源：https://leetcode.cn/problems/can-place-flowers/\n题解：class Solution &#123;\n    public boolean canPlaceFlowers(int[] flowerbed, int n) &#123;\n        if(flowerbed.length&#x3D;&#x3D;0)&#123;\n            return false;\n        &#125;\n        for(int i&#x3D;0;i&lt;flowerbed.length;i++)&#123;\n            &#x2F;&#x2F;遇到的情况\n            &#x2F;&#x2F;1.当前元素为0，并且后续也为0，则插入花，并减少剩余数量，i++，向后跳两格\n            &#x2F;&#x2F;2.当前元素为0，且为最后一个元素，则插入花，向后跳两格子\n            &#x2F;&#x2F;3.当前元素为1，则继续向后跳两格，因为后一个位子必定没法插入\n            &#x2F;&#x2F;4.若当前元素为0，后续为1，则跳一格，进入第三种情况\n            &#x2F;&#x2F;每次只需要判断当前元素和后一个元素，无需考虑前一个元素，并且从第一个元素开始判断\n            if(flowerbed[i]&#x3D;&#x3D;0&amp;&amp;(i+1&#x3D;&#x3D;flowerbed.length||flowerbed[i+1]&#x3D;&#x3D;0))&#123;\n                i++;\n                n--;\n            &#125;else if(flowerbed[i]&#x3D;&#x3D;1)&#123;\n                i++;\n            &#125;\n\n        &#125;\n        return n&lt;&#x3D;0? true:false;\n    &#125;\n&#125;\n\n","slug":"种花问题","date":"2022-07-30T01:41:20.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"6b879bd90cb55e176f69ea7d49b28d19","title":"买卖股票的最佳时机2","content":"122. 买卖股票的最佳时机2题目描述：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\n在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n返回 你能获得的 最大 利润 。\nexample 1:\n输入：prices &#x3D; [7,1,5,3,6,4]\n输出：7\n解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。\n     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。\n     总利润为 4 + 3 &#x3D; 7 。\n\nexample 2:\n输入：prices &#x3D; [1,2,3,4,5]\n输出：4\n解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。\n     总利润为 4 。\n\n\n\n题目来源：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/\n题解：class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        &#x2F;&#x2F;贪心，只要股票能涨，就卖，只要能赚到钱，就卖\n        int max_profit&#x3D;0;\n        &#x2F;&#x2F;从第二天开始遍历，只要比前一天价格高，就卖掉\n        for(int i&#x3D;1;i&lt;prices.length;i++)&#123;\n            if(prices[i]&gt;prices[i-1])&#123;\n                max_profit+&#x3D;prices[i]-prices[i-1];\n            &#125;\n        &#125;\n        return max_profit;\n    &#125;\n&#125;\n\n","slug":"卖出股票的最佳时机2","date":"2022-07-29T02:18:33.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"5d7c6d0b72a0ac167a5663e12c3dcdf4","title":"买股票的最佳时机","content":"121. 买股票的最佳时机题目描述：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\nexample 1:\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。\n     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\nexample 2:\n输入：prices &#x3D; [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n\n题目来源：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/\n题解：&#x2F;*\n贪心：最大收益一定是在历史最低点买入\n\n*&#x2F;\npublic class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        \n        &#x2F;&#x2F;最大收益，初始化为0\n        int maxprofit &#x3D; 0;\n        &#x2F;&#x2F;最低买入点，初始化为最大值\n        int min_time&#x3D;Integer.MAX_VALUE;\n        &#x2F;&#x2F;遍历每天价格\n        for(int price:prices)&#123;\n            &#x2F;&#x2F;若出现了更低的买入点，则更新买入点\n            min_time&#x3D;Math.min(min_time,price);\n            &#x2F;&#x2F;若当前价格高于最低买入点，则计算收益，并更新最大收集\n            maxprofit&#x3D;Math.max(maxprofit,price-min_time);\n        &#125;\n        return maxprofit;\n    &#125;\n&#125;\n\n","slug":"买股票的最佳时机","date":"2022-07-29T01:41:19.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"3961e8d57cd72a6f65bba4c20e028616","title":"列表导出为数组","content":"Java中List集合的toArray方法1. toArray()\n当没有参数指定时，返回的数组中元素的类型是Object类型的。因为List在使用时一般会指定泛型，所以该方法是不常用的。\n\n2.toArray(T[] a)\nleetcode-406使用到了该方法将列表对象转化为二维数组\n可以导出数组为指定的类型\n\nList&lt;String&gt; list&#x3D;new List&lt;&gt;();\nlist.add(&quot;hello&quot;);\nlist.add(&quot;world&quot;);\nString[] strs&#x3D;list.toArray(new String[list.size()]);\n\nList&lt;int[]&gt; list&#x3D;new List&lt;&gt;();\nlist.add(new int[]&#123;0,1&#125;);\nlist.add(new int[]&#123;1,0&#125;);\nint[][] ret&#x3D;list.toArray(new int[list.size()][]);\n\n\n\n","slug":"ListtoArray","date":"2022-07-28T03:18:32.000Z","categories_index":"","tags_index":"Java,数据结构","author_index":"LiuQuanZe"},{"id":"17c36b5674ca98b6f74033f762d79de8","title":"根据身高重建队列","content":"406.根据身高重建队列题目描述：假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。\n请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\nexample 1:\n输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n解释：\n编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。\n编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。\n编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。\n编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。\n编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。\n\n\n\nexample 2:\n输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\n输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n\n\n\n题目来源：https://leetcode.cn/problems/queue-reconstruction-by-height/\n题解class Solution &#123;\n    public int[][] reconstructQueue(int[][] people) &#123;\n        &#x2F;*\n        第一个元素进行降序排序，即元素越小，排的越靠后，\n        对于第一个元素相同的数组，针对第二个元素进行升序排序，即越小越靠前，之所以这样排序，是因为，最后是按照第二个元素\n        进行插入的，也就是说，被插入的时间比较早的元素比较容易被挤到后面，也是因为这个原因，第一个元素是降序，越小的插入的时间越迟，越大的越有可能后移，这样是不会出错的。\n        同理第二个元素，越大的越靠后，因为后面元素的插入不会影响前面的元素，而前面元素的插入是会影响后面的，所以先插小，后插大\n\n         *&#x2F;\n         &#x2F;&#x2F;对第一个元素进行降序排序，在第一个元素相同时对第二个元素进行降序\n        Arrays.sort(people,(m,n)-&gt;&#123;\n            &#x2F;&#x2F;第一个元素不相等时，使用降序\n            if(m[0]!&#x3D;n[0])&#123;\n                return n[0]-m[0];\n                &#x2F;&#x2F;第一个元素相等时，使用升序\n            &#125;else&#123;\n                return m[1]-n[1];\n            &#125;\n        &#125;);\n        &#x2F;&#x2F;创建返回值\n        List&lt;int[]&gt; list&#x3D;new ArrayList&lt;&gt;();\n        &#x2F;&#x2F;将排序后的数组插入到返回值中\n        for(int[] person:people)&#123;\n            &#x2F;&#x2F;若返回值列表大小大于要插入位置，则直接插入\n            if(list.size()&gt; person[1])&#123;\n                list.add(person[1],person);\n            &#125;else&#123;      &#x2F;&#x2F;若返回值列表大小小于要插入位置，则将person插入列表末尾位置\n                list.add(list.size(),person);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;将列表转化为二维数组进行返回\n        return list.toArray(new int[list.size()][]);\n\n    &#125;\n&#125;\n\n","slug":"根据身高重建队列","date":"2022-07-28T03:13:52.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"8c8ee24da1a163a01cda5376a75169b1","title":"452.Minimum Number of Arrows to Burst Balloons","content":"452.Minimum Number of Arrows to Burst Balloons题目描述：There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] &#x3D; [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;&#x3D; x &lt;&#x3D; xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\n有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。\n一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。\n给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。\nexample 1:\n输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]\n输出：2\n解释：气球可以用2支箭来爆破:\n-在x &#x3D; 6处射出箭，击破气球[2,8]和[1,6]。\n-在x &#x3D; 11处发射箭，击破气球[10,16]和[7,12]。\n\nexample 2:\n输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]\n输出：4\n解释：每个气球需要射出一支箭，总共需要4支箭。\n\nexample 3:\n输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]\n输出：2\n解释：气球可以用2支箭来爆破:\n- 在x &#x3D; 2处发射箭，击破气球[1,2]和[2,3]。\n- 在x &#x3D; 4处射出箭，击破气球[3,4]和[4,5]。\n\n题目链接：https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/\n题解：&#x2F;*排序+贪心*&#x2F;\nclass Solution &#123;\n    public int findMinArrowShots(int[][] points) &#123;\n        &#x2F;&#x2F;检查数组是否合法\n        if(points.length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;依据右边界的大小进行升序排序\n        Arrays.sort(points,new Comparator&lt;&gt;()&#123;\n            public int compare(int[] m,int[] n)&#123;\n                &#x2F;&#x2F;m小n大则不用交换位置，因为我们要的就是升序排序\n                if(m[1]&lt;n[1])&#123;\n                    return -1;\n                    &#x2F;&#x2F;m大n小，则需要交换位置，保证升序\n                &#125;else if(m[1]&gt;n[1])&#123;\n                    return 1;\n                    &#x2F;&#x2F;若m&#x3D;n则不需要交换位置，【当返回值小于等于0时，不进行元素交换，仅当返回值大于0时才需要进行交换！】\n                &#125;else&#123;\n\n                    return 0;\n                &#125;\n            &#125;\n        &#125;);\n        &#x2F;&#x2F;获取第一个元素的右边界作为初始右边界\n        long right&#x3D;points[0][1];\n        &#x2F;&#x2F;用于箭矢计数，初始值为1\n        int num&#x3D;1;\n        &#x2F;&#x2F;对元素进行遍历，如果需要遇到了不重叠的气球（即左边界大于right），则需要增加箭矢的数量，并更新右边界的值\n        for(int[] b:points)&#123;\n            if(b[0]&gt;right)&#123;\n                num++;\n                right&#x3D;b[1];\n            &#125;\n        &#125;\n        &#x2F;&#x2F;返回箭矢的数量\n        return num;\n\n    &#125;\n&#125;\n\n","slug":"MinimumNumberofArrowstoBurstBalloons","date":"2022-07-27T02:11:15.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"0b469cb01192ec369bac9950f85cb59d","title":"Non—overlapping Intervals","content":"435. Non-overlapping Intervals题目描述：Given an array of intervals intervals where intervals[i] &#x3D; [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nexample 1:\nInput: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n\n\n\n\nexample 2:\nInput: intervals &#x3D; [[1,2],[1,2],[1,2]]\nOutput: 2\nExplanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n\nexample 3:\nInput: intervals &#x3D; [[1,2],[2,3]]\nOutput: 0\nExplanation: You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.\n\n来源：力扣（LeetCode）链接：https://leetcode.cn/problems/non-overlapping-intervals\n题解：&#x2F;*\n\t贪心法：\n\t1.首先对数组参数interval中的各个区间元素进行排序，下面是按照右边界升序排序的。\n\t2.选出排序后的第一个区间的右边界作为初始右边界，并初始化未重叠区间的数量。\n\t3.依次遍历数组中其他的区间元素，若遍历到的区间元素的左边界并未超过初始右边界，则表示两个区间不重叠，\n\t  则：可以将该区间加入到非重叠区间集合中，更新未重叠区间数量，更新初始右边界。\n\t4.最后遍历完成即可得到未重叠区间数量，最后获得需要删减的区间的数量作为返回值返回即可。\n*&#x2F;\nclass Solution &#123;\n    public int eraseOverlapIntervals(int[][] intervals) &#123;\n        &#x2F;&#x2F;检查参数是否合法,长度为0，则无需移除任何元素\n        if(intervals.length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;对间隔数组进行排序，对右边界进行排序，进行升序排序，排序完成后，最靠左的元素的右边界最小\n        Arrays.sort(intervals,new Comparator&lt;int[]&gt;()&#123;\n            public int compare(int[] m,int[] n)&#123;\n                return m[1]-n[1];\n            &#125;\n        &#125;);\n        &#x2F;&#x2F;获取间隔数组的长度\n        int length&#x3D;intervals.length;\n        &#x2F;&#x2F;获取初始右边界，即具有最小右边界的元素\n        int right_bound&#x3D;intervals[0][1];\n        &#x2F;&#x2F;non_overlapping_num记录的是不重叠的间隔的数量,因为至少存在一个元素，所以初始化ans为1.\n        int non_overlapping_num&#x3D;1;\n        &#x2F;&#x2F;若找到不重叠的下一个间隔【因为这里的数组已经按照右边界进行排序了，替换的右边界是逐渐增加的】\n        for(int i&#x3D;1;i&lt;length;i++)&#123;\n            &#x2F;&#x2F;若当前间隔元素不重叠\n            if(intervals[i][0]&gt;&#x3D;right_bound)&#123;\n                non_overlapping_num++;\n                right_bound&#x3D;intervals[i][1];\n            &#125;\n        &#125;\n        &#x2F;&#x2F;数组长度减去ans（当前不重叠元素个数），得到的就是需要移除的元素的个数\n        return length-non_overlapping_num;\n\n    &#125;\n&#125;\n\n\n","slug":"NonoverlappingIntervals","date":"2022-07-25T07:05:31.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"db0cb7674f2527793ee34b531f627ef0","title":"Assign Cookies","content":"Assign Cookies题目描述：Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;&#x3D; g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\nexample1:\nInput: g &#x3D; [1,2,3], s &#x3D; [1,1]\nOutput: 1\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\nexample2:\nInput: g &#x3D; [1,2], s &#x3D; [1,2,3]\nOutput: 2\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n\n来源：力扣（LeetCode）链接：https://leetcode.cn/problems/assign-cookies\n题解：&#x2F;*排序+贪心*&#x2F;\nclass Solution &#123;\n    public int findContentChildren(int[] g, int[] s) &#123;\n        &#x2F;&#x2F;g是每个孩子需要的饼干尺寸\n        &#x2F;&#x2F;s是你有的饼干的尺寸\n        &#x2F;&#x2F;使用贪心算法，以孩子的胃口为基准，按照胃口大小从小到大进行满足。\n        Arrays.sort(s);\n        Arrays.sort(g);\n        int numberOfChildren&#x3D;g.length;\n        int numberOfCookie&#x3D;s.length;\n        int i&#x3D;0;\n        int j&#x3D;0;\n        int ret&#x3D;0;\n        \n        while(i&lt;numberOfChildren&amp;&amp;j&lt;numberOfCookie)&#123;\n            while(j&lt;numberOfCookie&amp;&amp;g[i]&gt;s[j])&#123;\n                j++;\n            &#125;\n            if(j&lt;numberOfCookie)&#123;\n                ret++;\n            &#125;\n            i++;\n            j++;\n        &#125;\n        return ret;\n    &#125;\n&#125;\n\n","slug":"Assign-Cookies","date":"2022-07-24T00:59:12.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"c37588bd65d4c5745225faacbe87ed1b","title":"平台开发所使用的前端组件工具","content":"平台开发中所使用到的Vue工具和组件vue-prism-editor1. 实现效果\n可输入代码，并且代码语法高亮\n支持编辑模式与不可编辑模式\n\n2. 使用步骤\n安装依赖\n\nnpm install vue-prism-editor\n\n\n由于vue-prism-editor需要prismjs依赖，所以需要导入prismjs依赖\n\nnpm install prismjs\n\n\n在需要使用的页面导入组件\n\nimport &#123; PrismEditor &#125; from &quot;vue-prism-editor&quot;;\nimport &quot;vue-prism-editor&#x2F;dist&#x2F;prismeditor.min.css&quot;;\nimport &#123; highlight, languages &#125; from &quot;prismjs&#x2F;components&#x2F;prism-core&quot;;\nimport &quot;prismjs&#x2F;components&#x2F;prism-clike&quot;;\nimport &quot;prismjs&#x2F;components&#x2F;prism-javascript&quot;;\nimport &quot;prismjs&#x2F;themes&#x2F;prism-tomorrow.css&quot;; \n\n\nhtml\n\n&lt;prism-editor\n   class&#x3D;&quot;my-editor height-300&quot;\n    v-model&#x3D;&quot;code&quot;\n    aria-disabled\n    :highlight&#x3D;&quot;highlighter&quot;\n    line-numbers\n    :readonly&#x3D;&quot;false&quot;\n    :tabSize&#x3D;&quot;4&quot;\n    &gt;&lt;&#x2F;prism-editor&gt;\n\n\njavascript\n\nexport default &#123;\n\t components: &#123;\n\t \t\tPrismEditor\n\t &#125;,\n\t data: () &#x3D;&gt; (&#123;\n\t \t\tcode: &#39; &#39;,\n\t &#125;),\n\t methods: &#123;\n\t\t \thighlighter(code) &#123;\n\t\t \t\treturn highlight(code, languages.js); &#x2F;&#x2F;returns html\n\t\t \t&#125;\n\t &#125;\n&#125;;\n\n\nCSS\n\n&lt;style lang&#x3D;&quot;scss&quot;&gt;\n\t.my-editor &#123;\n\t background: #2d2d2d;\n\t color: #ccc;\n\t font-family: Fira code, Fira Mono, Consolas, Menlo, Courier, monospace;\n\t font-size: 14px;\n\t line-height: 1.5;\n\t padding: 5px;\n\t&#125;\n\t\n\t.prism-editor__textarea:focus &#123;\n\t outline: none;\n\t&#125;\n\t\n\t&#x2F;* 非必须 *&#x2F;\n\t.height-300 &#123;\n\t \theight: 300px;\n\t&#125;\n&lt;&#x2F;style&gt;\n\n参考资料：https://blog.csdn.net/c_qianxia5040/article/details/124008768\nfile-saver1. 实现效果\n可以将一段字符串保存为一个文件\n\n2. 使用步骤\n安装依赖\n\nnpm install file-saver --save\n\n\n在需要使用文件保存的页面导入依赖\n\nimport &#123; saveAs &#125; from &#39;file-saver&#39;;\n\n\n保存文件demo\n\ndownloadTxt() &#123;\n    let str_file &#x3D; &#39;文件内的字符串内容&#39;\n    let strData &#x3D; new Blob([str_file], &#123; type: &#39;text&#x2F;plain;charset&#x3D;utf-8&#39; &#125;);\n    saveAs(strData, &quot;文件.py&quot;);\n&#125;,\n\n参考资料：https://wjw1014.blog.csdn.net/article/details/124320511\n","slug":"toolsInVue","date":"2022-07-22T13:14:49.000Z","categories_index":"Web前端","tags_index":"Vue,模块","author_index":"LiuQuanZe"},{"id":"7543ffbb46b57fc1881ab7a5290f7749","title":"75.颜色排序--单指针","content":"75. 颜色排序–单指针题目描述：Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library’s sort function.\nexample 1:\nInput: nums &#x3D; [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n\nexample 2:\nInput: nums &#x3D; [2,0,1]\nOutput: [0,1,2]\n\n\n\n题解：class Solution &#123;\n    public void sortColors(int[] nums) &#123;\n        int index&#x3D;0;\n        &#x2F;&#x2F;确定0的位置\n        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;\n            if(nums[i]&#x3D;&#x3D;0)&#123;\n                swap(nums,i,index++);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;确定1的位置\n        for(int j&#x3D;index;j&lt;nums.length;j++)&#123;\n            if(nums[j]&#x3D;&#x3D;1)&#123;\n                swap(nums,j,index++);\n            &#125;\n        &#125;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n&#125;\n\n","slug":"75SortColors01","date":"2022-07-22T01:58:53.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"c4515973a08e01e147ab3e57422101e1","title":"Vue中localStorage的简单使用","content":"Vue中localStorage的简单使用localStorage主要作为本地存储来使用。下面记录三个主要用法：\n\n存储数据\n\nlocalStorage.setItem(&#39;key&#39;,&#39;value&#39;)\n\n\n取出数据\n\nlocalStorage.getItem(&#39;key&#39;)\n\n\n删除本地存储数据\n\nlocalStorage.removeItem(&#39;key&#39;)\n\n\n当存储的是json格式时，需要使用JSON.stringify()转化为字符串\n\n","slug":"localStorage","date":"2022-07-21T12:09:11.000Z","categories_index":"WEB前端","tags_index":"Vue","author_index":"LiuQuanZe"},{"id":"28e06c560ccb367ab8fe61d12d122120","title":"Sort Characters By Frequency_桶排序","content":"Sort Characters By Frequency——桶排序题目描述：Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.\nReturn the sorted string. If there are multiple answers, return any of them.\nexample 1:\nInput: s &#x3D; &quot;tree&quot;\nOutput: &quot;eert&quot;\nExplanation: &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.\nSo &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.\n\n\n\nexample 2:\nInput: s &#x3D; &quot;cccaaa&quot;\nOutput: &quot;aaaccc&quot;\nExplanation: Both &#39;c&#39; and &#39;a&#39; appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers.\nNote that &quot;cacaca&quot; is incorrect, as the same characters must be together.\n\n\n\n\n\n题解：class Solution &#123;\n    public String frequencySort(String s) &#123;\n        &#x2F;&#x2F;创建map存储字符及其出现次数\n        Map&lt;Character,Integer&gt; map&#x3D;new HashMap&lt;&gt;();\n        int max_frequency&#x3D;0;\n        int frequency&#x3D;0;\n        char ch&#x3D;&#39; &#39;;\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            ch&#x3D;s.charAt(i);\n            map.put(ch,map.getOrDefault(ch,0)+1);\n            max_frequency&#x3D;Math.max(max_frequency,map.get(ch));\n        &#125;\n\n        &#x2F;&#x2F;创建buckets，并初始化buckets\n        StringBuffer[] buckets&#x3D;new StringBuffer[max_frequency+1];\n        for(int i&#x3D;0;i&lt;max_frequency+1;i++)&#123;\n            buckets[i]&#x3D;new StringBuffer();\n        &#125;\n        for(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet())&#123;\n            ch&#x3D;entry.getKey();\n            frequency&#x3D;entry.getValue();\n            buckets[frequency].append(ch);\n        &#125;\n        &#x2F;&#x2F;创建返回值\n        StringBuffer ret&#x3D;new StringBuffer();\n        &#x2F;&#x2F;添加返回值\n        for(int i&#x3D;max_frequency;i&gt;&#x3D;1;i--)&#123;\n            StringBuffer bucket&#x3D;buckets[i];\n            for(int j&#x3D;0;j&lt;bucket.length();j++)&#123;\n                for(int k&#x3D;0;k&lt;i;k++)&#123;\n                    ret.append(bucket.charAt(j));\n                &#125;\n            &#125;\n\n        &#125;\n        return ret.toString();\n\n\n    &#125;\n&#125;\n\n","slug":"SortCharactersByFrequency-BucketSort","date":"2022-07-21T03:08:16.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"47c6968c5ee85e81112866938362b070","title":"Bucket Sort","content":"桶排序介绍：&#x2F;*\n桶排序是一个排序算法，工作原理是将数组分到有限数量的桶中。\n每个桶内再进行个别排序（可以使用其他不同的排序算法实现）。\n*&#x2F;\n\n基本步骤：\n设定一个基准，将待排序的数据按照一定的范围，从小到大平均分搭配N个桶中，此时，桶与桶之间已经排好序了，但是桶内是无序的。\n将桶内的元素进行排序\n将每个桶按照从小到大的编号，一次取出桶内元素，排序完成。\n\n","slug":"BucketSort","date":"2022-07-21T02:51:39.000Z","categories_index":"数据结构与算法","tags_index":"Java","author_index":"LiuQuanZe"},{"id":"95fb99a87b0934d93a7b934555997ee9","title":"Sort Characters By Frequency","content":"Sort Characters By Frequency题目描述：Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.\nReturn the sorted string. If there are multiple answers, return any of them.\nexample 1:\nInput: s &#x3D; &quot;tree&quot;\nOutput: &quot;eert&quot;\nExplanation: &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.\nSo &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.\n\n\n\nexample 2:\nInput: s &#x3D; &quot;cccaaa&quot;\nOutput: &quot;aaaccc&quot;\nExplanation: Both &#39;c&#39; and &#39;a&#39; appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers.\nNote that &quot;cacaca&quot; is incorrect, as the same characters must be together.\n\n\n\n\n\n题解：class Solution &#123;\n    public String frequencySort(String s) &#123;\n        &#x2F;&#x2F;创建map存储字符及其出现次数\n        Map&lt;Character,Integer&gt; map&#x3D;new HashMap&lt;&gt;();\n        char ch&#x3D;&#39; &#39;;\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            ch&#x3D;s.charAt(i);\n            map.put(ch,map.getOrDefault(ch,0)+1);\n        &#125;\n\n        &#x2F;&#x2F;创建list列表存储字符\n        List&lt;Character&gt; list&#x3D;new ArrayList&lt;&gt;(map.keySet());\n        &#x2F;&#x2F;对list进行降序排序，根据出现次数\n        Collections.sort(list,(m,n)-&gt;map.get(n)-map.get(m));\n        &#x2F;&#x2F;创建返回值\n        StringBuffer ret&#x3D;new StringBuffer();\n        &#x2F;&#x2F;将结果存储返回值\n        for(int k&#x3D;0;k&lt;list.size();k++)&#123;\n            ch&#x3D;list.get(k);\n            int frequency&#x3D;map.get(ch);\n            for(int j&#x3D;0;j&lt;frequency;j++)&#123;\n                ret.append(ch);\n            &#125;\n        &#125;\n        return ret.toString();\n\n    &#125;\n&#125;\n\n","slug":"SortCharactersByFrequency","date":"2022-07-21T02:12:13.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"457fe231ac1330559343c50bbf83f171","title":"Top K Frequent Elements","content":"Top K Frequent Elements题目描述：Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\nexample 1:\nInput: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2\nOutput: [1,2]\n\nexample 2:\nInput: nums &#x3D; [1], k &#x3D; 1\nOutput: [1]\n\n\n\n题解：class Solution &#123;\n    public int[] topKFrequent(int[] nums, int k) &#123;\n        &#x2F;&#x2F;创建map，记录元素及其出现次数\n       Map&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;Integer,Integer&gt;();\n       for(int num:nums)&#123;\n           map.put(num,map.getOrDefault(num,0)+1);\n       &#125;\n       &#x2F;&#x2F;创建结构为小根堆的优先队列，队列元素为一个大小为2的数组，[0]表示元素，[1]表示出现次数\n       &#x2F;&#x2F;这里创建优先队列时，由于队列中的元素类型并非整型，所以需要传入比较器，规定比较规则\n       PriorityQueue&lt;int[]&gt; queue&#x3D;new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;()&#123;\n           public int compare(int[] m,int[] n)&#123;\n               return m[1]-n[1];\n           &#125;\n       &#125;);\n        &#x2F;&#x2F;将map中的键值对存入优先队列\n       for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;\n           int key&#x3D;entry.getKey();\n           int value&#x3D;entry.getValue();\n           &#x2F;&#x2F;若队列已满，则需要判断是否需要替换\n           if(k&#x3D;&#x3D;queue.size())&#123;\n               &#x2F;&#x2F;若当前元素出现次数小于堆顶元素，则表示堆内元素出现次数均大于key，则无需替换，否则需要替换堆顶元素\n               if(value&gt;queue.peek()[1])&#123;\n                   queue.poll();\n                   queue.offer(new int[]&#123;key,value&#125;);\n               &#125;\n           &#125;else&#123;   &#x2F;&#x2F;若队列元素个数小于k，则直接加入队列中\n               \n               queue.offer(new int[]&#123;key,value&#125;);\n           &#125;\n       &#125;\n       &#x2F;&#x2F;将队列中维护的元素存入ret数组并返回\n        int[] ret&#x3D;new int[k];\n       for(int i&#x3D;0;i&lt;k;i++)&#123;\n           ret[i]&#x3D;queue.poll()[0];\n       &#125;\n       return ret;\n       \n\n    &#125;\n\n\n   \n&#125;\n\n\n\n\n\n","slug":"TopKFrequentElements","date":"2022-07-21T01:11:44.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"b11e16d08ad1418b22f0f4722489b2fa","title":"Kth Largest Element in an Array——堆排序","content":"Kth Largest Element in an Array——堆排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nYou must solve it in O(n) time complexity.\n题解：class Solution &#123;\n    public int findKthLargest(int[] nums, int k) &#123;\n        &#x2F;&#x2F;堆的大小\n        int heapSize&#x3D;nums.length;\n        &#x2F;&#x2F;初始建立大根堆\n        buildMaxHeap(nums,heapSize);\n        &#x2F;&#x2F;取出堆顶元素，置换到堆底，再对置换完成的堆进行调整\n        for(int i&#x3D;nums.length-1;i&gt;&#x3D;nums.length-k+1;i--)&#123;\n            swap(nums,0,i);\n            adjustHeap(nums,0,--heapSize);\n        &#125;\n        &#x2F;&#x2F;返回第k次调整的堆顶元素\n        return nums[0];\n    &#125;\n    &#x2F;&#x2F;初始建堆\n    public void buildMaxHeap(int[] nums,int heapSize)&#123;\n        &#x2F;&#x2F;找到第一个非叶节点，不断下坠\n        for(int i&#x3D;heapSize&#x2F;2;i&gt;&#x3D;0;i--)&#123;\n            adjustHeap(nums,i,heapSize);\n        &#125;\n    &#125;\n\t&#x2F;&#x2F;堆调整\n    public void adjustHeap(int[] nums,int i,int heapSize)&#123;\n        &#x2F;&#x2F;创建指针分别指向i节点的左右孩子节点\n        int left&#x3D;i*2+1;\n        int right&#x3D;i*2+2;\n        int largest&#x3D;i;\n        &#x2F;&#x2F;通过两次判断，将largest指针指向最大节点\n        if(left&lt;heapSize&amp;&amp;nums[left]&gt;nums[largest])&#123;\n            largest&#x3D;left;\n        &#125;\n        if(right&lt;heapSize&amp;&amp;nums[right]&gt;nums[largest])&#123;\n            largest&#x3D;right;\n        &#125;\n        &#x2F;&#x2F;若不符合大根堆要求，则进行调整\n        if(largest!&#x3D;i)&#123;\n            swap(nums,largest,i);\n            adjustHeap(nums,largest,heapSize);\n        &#125;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n\n&#125;\n\n\n\n","slug":"FindKthLargest01","date":"2022-07-21T00:45:06.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"124012fd83870b9daa284761d75f9454","title":"找到第k大的元素——快速排序","content":"Kth Largest Element in an Array——快速排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nYou must solve it in O(n) time complexity.\n题解：class Solution &#123;\n    public int findKthLargest(int[] nums, int k) &#123;\n        return fastSelection(nums,0,nums.length-1,k-1);\t&#x2F;&#x2F;注意，传入的参数是nums.length-1和k-1\n    &#125;\n\t&#x2F;&#x2F;快速排序，递归\n    public int fastSelection(int[] nums,int start,int end,int kth)&#123;\n        &#x2F;&#x2F;划分并确定一个元素的位置\n        int cur&#x3D;partition(nums,start,end);\n        &#x2F;&#x2F;若为第k个元素，则直接返回\n        if(cur&#x3D;&#x3D;kth)&#123;\n            return nums[cur];\n        &#125;else if(cur&lt;kth)&#123;\t\t&#x2F;&#x2F;否则对右边区域进行划分\n            return fastSelection(nums,cur+1,end,kth);\n        &#125;else&#123;\t\t\t\t&#x2F;&#x2F;对左边区域进行划分\n            return fastSelection(nums,start,cur-1,kth);\n        &#125;\n    &#125;\n\t&#x2F;&#x2F;划分区间\n    public int partition(int[] nums,int start,int end)&#123;\n       \t &#x2F;&#x2F;随机选择枢轴元素\n        int pivot&#x3D;start+(int)(Math.random()*(end-start+1));\n        &#x2F;&#x2F;将枢轴元素调换至右边界\n        swap(nums,pivot,end);\n        &#x2F;&#x2F;双指针index和i用于进行划分，确定枢轴元素的最终位置\n        int index&#x3D;start-1;\n        for(int i&#x3D;start;i&lt;end;i++)&#123;\n            if(nums[i]&gt;nums[end])&#123;\n                swap(nums,i,++index);\n            &#125;\n        &#125;\n        swap(nums,++index,end);\n        return index;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n\n&#125;\n\n\n\n","slug":"FindKthLargest","date":"2022-07-21T00:24:42.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"2233f52546249f8733475a932932ac4d","title":"PriorityQueue的简单使用","content":"Java中的优先队列Java中的PriorityQueue默认是小顶堆，逻辑上是堆，物理上是数组，每次取出的元素是最小的。【可以通过比较器的方式传入不同的比较规则】\n特点：\n实现了Queue接口\n不允许放入null元素\n插入方法：\nadd()和offer(),前者插入失败抛出异常，后者插入失败返回false。\n\n\n获取堆顶元素：\nelement()和peek():都是获取堆顶元素，前者获取失败抛出异常，后者返回null\n\n\n获取并删除队首元素：\nremove()和poll()都是获取并删除队首元素，前者失败抛出异常，后者失败返回null。\n\n\n\n构造：\n构造小顶堆\n\nPriorityQueue small&#x3D;new PriorityQueue&lt;&gt;();\n\n\n构造大顶堆\n\nPriorityQueue big&#x3D;new PriorityQueue&lt;&gt;(Collections.reverseOrder());\n&#x2F;&#x2F;使用比较器构造大顶堆\nPriorityQueue&lt;int[]&gt; queue&#x3D;new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123;\n\tpublic int compare(int[] m, int[] n) &#123;\n\t\treturn m[1] - n[1];\n\t&#125;\n&#125;);\n   \n","slug":"PriorityQueue_SimpleUse","date":"2022-07-20T03:10:24.000Z","categories_index":"","tags_index":"Java,数据结构","author_index":"LiuQuanZe"},{"id":"0147aaa7b5bc889d40916e1f2d1d947a","title":"Hexo添加标签和分类","content":"如何在Hexo中添加分类和标签？分类：\n创建分类选项：\n生成【分类页】，并添加type属性\n\n\n\nhexo new page categories\n\n\n执行成功：\n\nINFO  Created: H:\\blog\\source\\categories\\index.md\n\n\n根据上述路径，找到index.md,添加type和layout：\n\ntitle: categories\ndate: 2022-07-19 16:16:46\ntype: &quot;categories&quot;\nlayout: &quot;categories&quot;\n\n\n保存并关闭index.md\n使用categories：\n\ntitle: Console失效\ndate: 2022-07-19 16:02:42\ncategories: \n- web前端\ntags:\n- Vue\n- 报错\n\n\n\n标签：\n创建标签选项：\n生成【标签页】，并添加type属性\n\n\n\nhexo new page tags\n\n\n执行成功：\n\nINFO  Created: H:\\blog\\source\\tags\\index.md\n\n\n根据上述路径，找到index.md,添加type和layout：\n\ntitle: 文章分类\ndate: 2022-01-07 22:53:43\ntype: &quot;tags&quot;\nlayout: &quot;tags&quot;\n\n\n保存并关闭index.md\n使用tags：\n\ntitle: Console失效\ndate: 2022-07-19 16:02:42\ncategories: \n- web前端\ntags:\n- Vue\n- 报错\n\n\n\n\n\n\n\n","slug":"HexoTagsAndCategories","date":"2022-07-19T08:18:19.000Z","categories_index":"个人博客","tags_index":"Hexo,使用说明","author_index":"LiuQuanZe"},{"id":"85d7f0ee0105da9c47f8cfa58c2659ee","title":"Console失效","content":"console.log()失效问题描述：当使用console.log()想要打印到控制台时，发现idea出现下滑红线，并且num run serve也通不过。\n错误信息：ESLint: Unexpected console statement.(no-console)\n\n\n\n解决办法：进行简单的配置即可：\n在package.json的eslintConfig:{}中的”rules”:{}，增加一行代码【”no-console”: “off”】\n&quot;rules&quot;: &#123;\n  &quot;no-console&quot;:&quot;off&quot;\n&#125;,\n\n","slug":"CannotUseConsole","date":"2022-07-19T08:02:42.000Z","categories_index":"web前端","tags_index":"Vue,报错","author_index":"LiuQuanZe"},{"id":"ea91dec26a5ee2422c404ab47e32c3f7","title":"Ryu的Rest API初体验","content":"ryu.app.ofctl_restryu.app.ofctl_rest provides REST APIs for retrieving the switch stats and Updating the switch stats. This application helps you debug your application and get various statistics.\n【其实就是ryu自己提供的一个应用程序，提供了获取交换机状态以及更新交换机状态的REST APIs。该应用可以帮助我们debug自己创建的应用并获取各种统计数据】\n \n\n\n\n\nThis application supports OpenFlow version 1.0, 1.2, 1.3, 1.4 and 1.5.\n【支持OpenFlow版本 1.0 1.2 1.3 1.4和1.5】\n使用\n将ofctl_rest和simple_switch_13.py一起启动\n\n\n\n启动拓扑\n\n\n\n另起一个终端，进行请求发送，测试接口\n\n\n\n其余接口尚未测试，该接口响应成功，响应结果是否正确要看具体实验情况。\n\n【注】使用的是python3，则需要修改ofctl_rest源码：\n\n第133行：\n\n#原本\nbody&#x3D;json.dumps(dps)\n#改为\nbody &#x3D; json.dumps(list(dps)).encode(&quot;utf-8&quot;)\n\n\n若是python2，则应该不需要修改，运行时不会报错\n\n","slug":"ofctlrest","date":"2022-07-18T03:52:22.000Z","categories_index":"SDN","tags_index":"使用方法,科研","author_index":"LiuQuanZe"}]