[{"id":"de679446ce90a96213f1c24b7dcd05cc","title":"701.二叉搜索树中的插入操作","content":"701.二叉搜索树中的插入操作题目描述：\n二叉搜索树中的插入操作\n\n给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。\nexample 1:\n输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5\n输出：[4,2,7,1,3,5]\n\nexample 2:\n输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25\n输出：[40,20,60,10,30,50,70,null,null,25]\n\nexample 3:\n输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5\n输出：[4,2,7,1,3,5]\n\n提示：\n\n树中的节点数将在 [0, 104]的范围内。\n-108 &lt;= Node.val &lt;= 108\n所有值 Node.val 是 独一无二 的。\n-108 &lt;= val &lt;= 108\n保证 val 在原始BST中不存在\n\n题目来源：\nhttps://leetcode.cn/problems/insert-into-a-binary-search-tree/description/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public TreeNode insertIntoBST(TreeNode root, int val) &#123;\n        &#x2F;&#x2F;若当前二叉搜索树为空，则创建新节点，并返回\n        if(root&#x3D;&#x3D;null)\n            return new TreeNode(val);\n        &#x2F;&#x2F;记录树的根节点，创建前驱节点\n        TreeNode newRoot&#x3D;root;\n        TreeNode pre&#x3D;null;\n        &#x2F;&#x2F;当活动节点不为null时进行循环遍历\n        while(root!&#x3D;null)&#123;\n            &#x2F;&#x2F;记录当前位置\n            pre&#x3D;root;\n            &#x2F;&#x2F;若当前节点val大于val则表示插入元素应该在当前节点的左子树\n            if(root.val&gt;val)&#123;\n                root&#x3D;root.left;\n            &#125;else&#123;\n                root&#x3D;root.right;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;当root&#x3D;null时跳出循环，此时pre指向的是叶子节点，若叶子节点的val大于插入元素，则作为左孩子，否则作为右孩子\n        if(pre.val&gt;val)&#123;\n            pre.left&#x3D;new TreeNode(val);\n        &#125;else&#123;\n            pre.right&#x3D;new TreeNode(val);\n        &#125;\n        return newRoot;\n    &#125;\n&#125;\n\n","slug":"701-二叉搜索树中的插入操作","date":"2022-10-12T02:51:28.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"2f59e63c36776555eba1dd17097990fc","title":"236.二叉搜索树的最近公共祖先","content":"236.二叉搜索树的最近公共祖先题目描述：\n二叉搜索树的最近公共祖先\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]\nexample 1:\n输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6\n\nexample 2:\n输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n\n\n\n提示：\n\n所有节点的值都是唯一的。\np、q 为不同节点且均存在于给定的二叉搜索树中。\n\n题目来源：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) &#123; val &#x3D; x; &#125;\n * &#125;\n *&#x2F;\n\nclass Solution &#123;\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;\n        return findNode(root,p,q);\n    &#125;\n    &#x2F;&#x2F;因为是二叉搜索树，所以和普通二叉树的递归有所不同，之后还需要对比看，还没理解透\n    public TreeNode findNode(TreeNode root,TreeNode p,TreeNode q)&#123;\n        if(root&#x3D;&#x3D;null)\n            return null;\n        &#x2F;&#x2F;若该节点值大于pq，搜索左边，\n        if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)&#123;\n            TreeNode left&#x3D;lowestCommonAncestor(root.left,p,q);\n            if(left!&#x3D;null)&#123;\n                return left;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;若该节点值小于pq，则搜索右边\n        if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)&#123;\n            TreeNode right&#x3D;lowestCommonAncestor(root.right,p,q);\n            if(right!&#x3D;null)&#123;\n                return right;\n            &#125;\n        &#125;\n        return root;\n    &#125;\n    \n&#125;\n\n\n\n","slug":"236-二叉搜索树的最近公共祖先","date":"2022-10-11T03:12:26.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"601c51b501c0367e52192a7f2085d7dc","title":"236.二叉树的最近公共祖先","content":"236.二叉树的最近公共祖先题目描述：\n二叉树的最近公共祖先\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\nexample 1：\n输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n\nexample 2:\n输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n\nexample 3:\n输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2\n输出：1\n\n提示：\n树中节点数目在范围 [2, 105] 内。-109 &lt;&#x3D; Node.val &lt;&#x3D; 109所有 Node.val 互不相同 。p !&#x3D; qp 和 q 均存在于给定的二叉树中。\n题目来源:https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) &#123; val &#x3D; x; &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;&#x2F;递归，回溯，使用后序遍历\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;\n        &#x2F;&#x2F;若当前节点为其中一个指定节点，或者当前节点为null，则返回\n        if(root&#x3D;&#x3D;p||root&#x3D;&#x3D;q||root&#x3D;&#x3D;null)&#123;\n            return root;\n        &#125;\n        &#x2F;&#x2F;左子树是否存在公共祖先\n        TreeNode left&#x3D;lowestCommonAncestor(root.left,p,q);\n        TreeNode right&#x3D;lowestCommonAncestor(root.right,p,q);\n        if(left&#x3D;&#x3D;null&amp;&amp;right&#x3D;&#x3D;null)&#123;\n            return null;\n        &#125;else if(left!&#x3D;null&amp;&amp;right&#x3D;&#x3D;null)&#123;\n            return left;\n        &#125;else if(left&#x3D;&#x3D;null&amp;&amp;right!&#x3D;null)&#123;\n            return right;\n        &#125;\n        return root;\n\n    &#125;\n&#125;\n\n","slug":"236-二叉树的最近公共祖先","date":"2022-10-10T08:16:57.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"4292498269ab452abce6e693ac1873b6","title":"501.二叉搜索树中的众数","content":"501.二叉搜索树中的众数题目描述：\n二叉搜索树中的众数\n\n给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。\n如果树中有不止一个众数，可以按 任意顺序 返回。\n假定 BST 满足如下定义：\n\n结点左子树中所含节点的值 小于等于 当前节点的值\n结点右子树中所含节点的值 大于等于 当前节点的值\n左子树和右子树都是二叉搜索树\n\nexample 1:\n输入：root &#x3D; [1,null,2,2]\n输出：[2]\n\nexample 2:\n输入：root &#x3D; [0]\n输出：[0]\n\n提示：\n\n树中节点的数目在范围 [1, 104] 内\n-105 &lt;= Node.val &lt;= 105\n\n题目来源：https://leetcode.cn/problems/find-mode-in-binary-search-tree/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;&#x2F;存储出现最大次数的元素有哪些\n    public List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();\n    &#x2F;&#x2F;记录当前出现次数最多的元素的个数\n    public int maxCount&#x3D;0;\n    &#x2F;&#x2F;记录当前节点元素出现的次数\n    public int count&#x3D;0;\n    &#x2F;&#x2F;记录上一个节点\n    public TreeNode pre&#x3D;null;\n\n    public int[] findMode(TreeNode root) &#123;\n        findMode_1(root);\n        int[] res&#x3D;new int[list.size()];\n        for(int i&#x3D;0;i&lt;list.size();i++)&#123;\n            res[i]&#x3D;list.get(i);\n        &#125;\n        return res;\n    &#125;\n\n    &#x2F;&#x2F;进行中序遍历，并在遍历到该节点时更新当前元素的count，并检查是否需要更新maxCount，如果需要更新maxCount（当前元素Count大于maxCount）则将返回值列表中元素全部清除，若小于maxCount，则不进行更新，若等于maxCount，则将元素加入到resList，即返回列表中。\n    public void findMode_1(TreeNode node)&#123;\n        if(node&#x3D;&#x3D;null)\n            return ;\n        findMode_1(node.left);\n        if(pre&#x3D;&#x3D;null||pre.val!&#x3D;node.val)&#123;\n            count&#x3D;1;\n        &#125;else&#123;\n            count++;\n        &#125;\n        if(count&gt;maxCount)&#123;\n            maxCount&#x3D;count;\n            list.clear();\n            list.add(node.val);\n        &#125;else if(count&#x3D;&#x3D;maxCount)&#123;\n            list.add(node.val);\n        &#125;\n        pre&#x3D;node;\n        findMode_1(node.right);\n\n    &#125;\n&#125;\n\n","slug":"501-二叉搜索树中的众数","date":"2022-10-09T01:46:39.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"6226c398b825b38b91ad0079c34b0472","title":"530.二叉搜索树的最小绝对值差","content":"530.二叉搜索树的最小绝对值差题目描述：\n二叉搜索树的最小绝对差\n\n给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。\n差值是一个正数，其数值等于两值之差的绝对值。\nexample 1：\n输入：root &#x3D; [4,2,6,1,3]\n输出：1\n\nexample 2:\n输入：root &#x3D; [1,0,48,null,null,12,49]\n输出：1\n\n提示：\n\n树中节点的数目范围是 [2, 104]\n0 &lt;= Node.val &lt;= 105\n\n题目来源：https://leetcode.cn/problems/minimum-absolute-difference-in-bst/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;&#x2F;记录当前的最小绝对值之差\n    public int result&#x3D;Integer.MAX_VALUE;\n    &#x2F;&#x2F;记录前一个节点的值\n    public TreeNode pre&#x3D;null;\n    public void findMin(TreeNode node)&#123;\n        if(node&#x3D;&#x3D;null)\n            return;\n        findMin(node.left);\n        if(pre!&#x3D;null)&#123;\n            result&#x3D;Math.min(result,node.val-pre.val);\n        &#125;\n        pre&#x3D;node;\n        findMin(node.right);\n        \n    &#125;\n\n    public int getMinimumDifference(TreeNode root) &#123;\n        findMin(root);\n        return result;\n\n    &#125;\n&#125;\n\n","slug":"530-二叉搜索树的最小绝对值差","date":"2022-10-08T01:03:59.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"dd5945836ee2298d3cd22289ae215e69","title":"98.验证二叉搜索树","content":"98.验证二叉搜索树问题描述：\n验证二叉搜索树\n\n给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n有效 二叉搜索树定义如下：\n\n节点的左子树只包含 小于 当前节点的数。\n节点的右子树只包含 大于 当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\nexample 1：\n输入：root &#x3D; [2,1,3]\n输出：true\n\nexample 2:\n输入：root &#x3D; [5,1,4,null,null,3,6]\n输出：false\n解释：根节点的值是 5 ，但是右子节点的值是 4 。\n\n提示：\n\n树中节点数目范围在[1, 104] 内\n-231 &lt;= Node.val &lt;= 231 - 1\n\n题目来源：https://leetcode.cn/problems/validate-binary-search-tree/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;&#x2F;进行中序遍历，并将遍历的节点值存入到list集合中\n    public void valid(TreeNode node,List&lt;Integer&gt; list)&#123;\n        if(node&#x3D;&#x3D;null)\n            return ;\n        valid(node.left,list);\n        list.add(node.val);\n        valid(node.right,list);\n    &#125;\n\n    \n    public boolean isValidBST(TreeNode root) &#123;\n\n        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();\n        valid(root,list);\n        &#x2F;&#x2F;将集合转化为数组\n        Integer[] arr&#x3D;list.toArray(new Integer[list.size()]);\n        &#x2F;&#x2F;判断数组是否为升序，如果不是升序，则不是二叉搜索树，否则是二叉搜索树\n        for(int i&#x3D;1;i&lt;arr.length;i++)&#123;\n            if(arr[i]&lt;&#x3D;arr[i-1])\n                return false;\n        &#125;\n        return true;\n    &#125;\n&#125;\n\n","slug":"98-验证二叉搜索树","date":"2022-10-07T00:54:24.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"4e6e4747e1b3af852c2bcbf832cc15bd","title":"700.二叉搜索树中的搜索","content":"700.二叉搜索树中的搜索题目描述：\n二叉搜索树中的搜索\n\n给定二叉搜索树（BST）的根节点 root 和一个整数值 val。\n你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。\nexample 1：\n输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2\n输出：[2,1,3]\n\nexample 2:\n输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5\n输出：[]\n\n提示：\n\n数中节点数在 [1, 5000] 范围内\n1 &lt;= Node.val &lt;= 107\nroot 是二叉搜索树\n1 &lt;= val &lt;= 107\n\n题目来源：https://leetcode.cn/problems/search-in-a-binary-search-tree/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public TreeNode findTree(TreeNode node,int val)&#123;\n        if(node&#x3D;&#x3D;null)\n            return null;\n        if(node.val&#x3D;&#x3D;val)\n            return node;\n        if(node.val&lt;val)&#123;\n            return findTree(node.right,val);\n        &#125;\n        return findTree(node.left,val);\n    &#125;\n\n    public TreeNode searchBST(TreeNode root, int val) &#123;\n        return findTree(root,val);\n    &#125;\n&#125;\n\n","slug":"700-二叉搜索树中的搜索","date":"2022-10-06T01:18:40.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"df36dac409def39859c6c978ff85b201","title":"617.合并二叉树","content":"617.合并二叉树题目描述：\n合并二叉树\n\n给你两棵二叉树： root1 和 root2 。\n想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。\n返回合并后的二叉树。\n注意: 合并过程必须从两个树的根节点开始。\nexample 1:\n输入：root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]\n输出：[3,4,5,5,4,null,7]\n\nexample 2:\n输入：root1 &#x3D; [1], root2 &#x3D; [1,2]\n输出：[2,2]\n\n提示：\n\n两棵树中的节点数目在范围 [0, 2000] 内\n-104 &lt;= Node.val &lt;= 104\n\n题目来源：https://leetcode.cn/problems/merge-two-binary-trees/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public TreeNode buildTree(TreeNode node1,TreeNode node2)&#123;\n        if(node1&#x3D;&#x3D;null&amp;&amp;node2&#x3D;&#x3D;null)\n            return null;\n        TreeNode node;\n        if(node1&#x3D;&#x3D;null&amp;&amp;node2!&#x3D;null)&#123;\n            &#x2F;&#x2F;若node1为空，则构造出的树和node2相同，直接返回node2\n            return node2;\n        &#125;else if(node1!&#x3D;null&amp;&amp;node2&#x3D;&#x3D;null)&#123;\n            return node1;\n        &#125;else&#123;\n            node&#x3D;new TreeNode(node1.val+node2.val);\n        \n            node.left&#x3D;buildTree(node1.left,node2.left);\n            node.right&#x3D;buildTree(node1.right,node2.right);\n        &#125;\n        return node;\n    &#125;\n\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;\n        return buildTree(root1,root2);\n    &#125;\n&#125;\n\n","slug":"617-合并二叉树","date":"2022-10-05T01:34:50.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"de48b7aad10b18e063971ae0b35f5843","title":"654.最大二叉树","content":"654.最大二叉树题目描述：\n最大二叉树\n\n给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:\n\n创建一个根节点，其值为 nums 中的最大值。\n递归地在最大值 左边 的 子数组前缀上 构建左子树。\n递归地在最大值 右边 的 子数组后缀上 构建右子树。\n\n返回 nums 构建的 *最大二叉树* 。\nexample 1：\n输入：nums &#x3D; [3,2,1,6,0,5]\n输出：[6,3,5,null,2,0,null,null,1]\n解释：递归调用如下所示：\n- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。\n    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。\n        - 空数组，无子节点。\n        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。\n            - 空数组，无子节点。\n            - 只有一个元素，所以子节点是一个值为 1 的节点。\n    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。\n        - 只有一个元素，所以子节点是一个值为 0 的节点。\n        - 空数组，无子节点。\n\nexample 2:\n输入：nums &#x3D; [3,2,1]\n输出：[3,null,2,null,1]\n\n提示：\n\n1 &lt;= nums.length &lt;= 1000\n0 &lt;= nums[i] &lt;= 1000\nnums 中的所有整数 互不相同\n\n题目来源：https://leetcode.cn/problems/maximum-binary-tree\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;&#x2F;递归函数\n    public TreeNode buildTree(int[] nums,int start,int end)&#123;\n        &#x2F;&#x2F;若超出范围，则表示没有节点，则返回null\n        if(start&gt;&#x3D;end)&#123;\n            return null;\n        &#125;\n        &#x2F;&#x2F;循环找出当前数组范围内的最大值及其下标\n        int max&#x3D;-1;\n        int index_max&#x3D;-1;\n        for(int i&#x3D;start;i&lt;end;i++)&#123;\n            if(nums[i]&gt;max)&#123;\n                max&#x3D;nums[i];\n                index_max&#x3D;i;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;构造节点\n        TreeNode node&#x3D;new TreeNode(max);\n        &#x2F;&#x2F;递归构造左子树，注意传入的区间参数，左闭右开\n        node.left&#x3D;buildTree(nums,start,index_max);\n        &#x2F;&#x2F;左闭右开\n        node.right&#x3D;buildTree(nums,index_max+1,end);\n        return node;\n    &#125;\n\n    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;\n        if(nums&#x3D;&#x3D;null)\n            return null;\n        &#x2F;&#x2F;左闭右开\n        return buildTree(nums,0,nums.length);\n    &#125;\n&#125;\n\n","slug":"654-最大二叉树","date":"2022-10-04T01:34:03.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"1dd4eb0dc067f1daee6408ed548f50e5","title":"106. 从中序与后序遍历序列构造二叉树","content":"106.从中序与后序遍历序列构造二叉树题目描述：\n从中序与后序遍历序列构造二叉树\n\n给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。\nexample 1:\n输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]\n输出：[3,9,20,null,null,15,7]\n\nexample 2:\n输入：inorder &#x3D; [-1], postorder &#x3D; [-1]\n输出：[-1]\n\n提示：\n1 &lt;&#x3D; inorder.length &lt;&#x3D; 3000postorder.length &#x3D;&#x3D; inorder.length-3000 &lt;&#x3D; inorder[i], postorder[i] &lt;&#x3D; 3000inorder 和 postorder 都由 不同 的值组成postorder 中每一个值都在 inorder 中inorder 保证是树的中序遍历postorder 保证是树的后序遍历\n题目来源：https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\n \n class Solution &#123;\n     &#x2F;&#x2F;为了更加方便的找到中序序列中节点下标\n    Map&lt;Integer, Integer&gt; map;  &#x2F;&#x2F; 方便根据数值查找位置\n    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        &#x2F;&#x2F;将中序序列存入map，key为节点val，value为节点val所在的下标\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n        &#x2F;&#x2F;注意，右边界是数组长度，是最后一个元素下标的后一个位置    \n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n    \n    \n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (inBegin &gt;&#x3D; inEnd || postBegin &gt;&#x3D; postEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        \n        int rootIndex &#x3D; map.get(postorder[postEnd - 1]);  &#x2F;&#x2F; 找到后序遍历的最后一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定后序数列的个数\n        &#x2F;&#x2F;递归构造左子树\n        root.left &#x3D; findNode(inorder, inBegin, rootIndex,\n                            postorder, postBegin, postBegin + lenOfLeft);\n        &#x2F;&#x2F;递归构造右子树\n        root.right &#x3D; findNode(inorder, rootIndex + 1, inEnd,\n                            postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    &#125;\n&#125;\n\n","slug":"106-从中序与后序遍历序列构造二叉树","date":"2022-10-03T12:53:13.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"26c4b1d62f73766a69fff244a3f35602","title":"105. 从前序与中序遍历序列构造二叉树","content":"105.从前序与中序遍历序列构造二叉树题目描述：\n从前序与中序遍历序列构造二叉树\n\n给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。\nexample 1:\n输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]\n输出: [3,9,20,null,null,15,7]\n\nexample 2:\n输入: preorder &#x3D; [-1], inorder &#x3D; [-1]\n输出: [-1]\n\n提示：\n1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000inorder.length &#x3D;&#x3D; preorder.length-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000preorder 和 inorder 均 无重复 元素inorder 均出现在 preorderpreorder 保证 为二叉树的前序遍历序列inorder 保证 为二叉树的中序遍历序列\n题目来源：https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    Map&lt;Integer, Integer&gt; map;\n    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n\n        return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n\n    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (preBegin &gt;&#x3D; preEnd || inBegin &gt;&#x3D; inEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        int rootIndex &#x3D; map.get(preorder[preBegin]);  &#x2F;&#x2F; 找到前序遍历的第一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定前序数列的个数\n        root.left &#x3D; findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,  \n                            inorder, inBegin, rootIndex);\n        root.right &#x3D; findNode(preorder, preBegin + lenOfLeft + 1, preEnd,\n                            inorder, rootIndex + 1, inEnd);\n\n        return root;\n    &#125;\n&#125;\n\n","slug":"105-从前序与中序遍历序列构造二叉树","date":"2022-10-03T12:52:58.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"03aa7645b6656a5f9f59ee379b9ad29c","title":"112.路径综合","content":"112.路径综合题目描述：\n路径总和\n\n给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。\n叶子节点 是指没有子节点的节点。\nexample 1:\n输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22\n输出：true\n解释：等于目标和的根节点到叶节点路径如上图所示。\n\nexample 2:\n输入：root &#x3D; [1,2,3], targetSum &#x3D; 5\n输出：false\n解释：树中存在两条根节点到叶子节点的路径：\n(1 --&gt; 2): 和为 3\n(1 --&gt; 3): 和为 4\n不存在 sum &#x3D; 5 的根节点到叶子节点的路径。\n\nexample 3:\n输入：root &#x3D; [], targetSum &#x3D; 0\n输出：false\n解释：由于树是空的，所以不存在根节点到叶子节点的路径。\n\n提示：\n\n树中节点的数目在范围 [0, 5000] 内\n-1000 &lt;= Node.val &lt;= 1000\n-1000 &lt;= targetSum &lt;= 1000\n\n题目来源：https://leetcode.cn/problems/path-sum\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;&#x2F;递归，传入三个参数，第一个是当前节点，一个是从根节点到当前节点的父节点路径上的val之和，targetNum是目标路径上的节点val之和\n    public boolean traverse(TreeNode node,int count,int targetSum)&#123;\n        &#x2F;&#x2F;加上当前节点的val，表示根节点到当前节点这条路径上的所有节点的val之和\n        count+&#x3D;node.val;\n        &#x2F;&#x2F;如果当前节点是叶子节点，则判断当前路径节点的val之和是否等于目标路径的节点val之和，如果等于，则返回true，否则返回false\n        if(node.left&#x3D;&#x3D;null&amp;&amp;node.right&#x3D;&#x3D;null)&#123;\n            if(count&#x3D;&#x3D;targetSum)&#123;\n                return true;\n            &#125;else&#123;\n                return false;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;如果当前节点不是叶子节点，则分别判断左右子树中是否存在目标路径，下面两个变量分别存储左右子树是否存在目标路径\n        boolean left&#x3D;false;\n        boolean right&#x3D;false;\n        &#x2F;&#x2F;若左子树非空，则对左子树进行递归\n        if(node.left!&#x3D;null)&#123;\n            left&#x3D;traverse(node.left,count,targetSum);\n        &#125;\n        &#x2F;&#x2F;对右子树进行递归\n        if(node.right!&#x3D;null)&#123;\n            right&#x3D;traverse(node.right,count,targetSum);\n        &#125;\n        &#x2F;&#x2F;当左子树或者右子树中存在一条目标路径则表示该树存在目标路径，这里使用||\n        return left||right;\n\n    &#125;\n\n    public boolean hasPathSum(TreeNode root, int targetSum) &#123;\n        if(root&#x3D;&#x3D;null)\n            return false;\n        return traverse(root,0,targetSum);\n    &#125;\n&#125;\n\n","slug":"112-路径综合","date":"2022-10-01T15:19:03.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"806f699ee80a6615fc5f8fc6dcffa078","title":"513.找树左下角的值","content":"513.找树左下角的值题目描述：\n找树左下角的值\n\n给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。\n假设二叉树中至少有一个节点。\nexample 1：\n输入: root &#x3D; [2,1,3]\n输出: 1\n\nexample 2:\n输入: [1,2,3,4,null,5,6,null,null,7]\n输出: 7\n\n提示：\n\n二叉树的节点个数的范围是 [1,104]\n-231 &lt;= Node.val &lt;= 231 - 1\n\n题目来源：\nhttps://leetcode.cn/problems/find-bottom-left-tree-value/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public int findBottomLeftValue(TreeNode root) &#123;\n        if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)&#123;\n            return root.val;\n        &#125;\n        int[] deepest&#x3D;new int[2];\n        \n        deepest[0]&#x3D;0;\n        deepest[1]&#x3D;0;\n        findAllLeftLeaf(root,deepest,1);\n        return deepest[1];\n    &#125;\n    public void findAllLeftLeaf(TreeNode root,int[] deepest,int depth)&#123;\n        if(root&#x3D;&#x3D;null)\n            return ;\n        if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)\n            return ;\n        if(root.left!&#x3D;null&amp;&amp;root.left.left&#x3D;&#x3D;null&amp;&amp;root.left.right&#x3D;&#x3D;null)&#123;\n            &#x2F;&#x2F;若深度更深\n            if(depth+1&gt;deepest[0])&#123;\n                deepest[0]&#x3D;depth+1;\n                deepest[1]&#x3D;root.left.val;\n            &#125;\n        &#125;\n        findAllLeftLeaf(root.left,deepest,depth+1);\n        findAllLeftLeaf(root.right,deepest,depth+1);\n\n            \n    &#125;\n&#125;\n\n","slug":"513-找树左下角的值","date":"2022-09-30T15:03:56.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"4d298bda0eb98905fab53c1b930a261c","title":"404.左叶子之和","content":"404.左叶子之和题目描述：\n左叶子之和\n\n给定二叉树的根节点 root ，返回所有左叶子之和。\nexample 1：\n输入: root &#x3D; [3,9,20,null,null,15,7] \n输出: 24 \n解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n\nexample 2:\n输入: root &#x3D; [1]\n输出: 0\n\n提示：\n\n节点数在 [1, 1000] 范围内\n-1000 &lt;= Node.val &lt;= 1000\n\n题目来源：https://leetcode.cn/problems/sum-of-left-leaves\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public int sumOfLeftLeaves(TreeNode root) &#123;\n        &#x2F;&#x2F;若当前节点为空，则返回0\n        if(root&#x3D;&#x3D;null)\n            return 0;\n        &#x2F;&#x2F;若当前节点为叶子节点，则返回0\n        if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)\n            return 0;\n        &#x2F;&#x2F;记录左子树的所有叶子节点的值\n        int leftValue&#x3D;0;\n        &#x2F;&#x2F;如果左孩子节点就是叶子节点，则leftValue就是左孩子节点的值\n        if(root.left!&#x3D;null&amp;&amp;root.left.left&#x3D;&#x3D;null&amp;&amp;root.left.right&#x3D;&#x3D;null)\n            leftValue&#x3D;root.left.val;\n        &#x2F;&#x2F;返回当前节点左子树和右子树的所有左叶子节点的值之和\n        return leftValue+sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right);\n    &#125;\n&#125;\n\n","slug":"404-左叶子之和","date":"2022-09-30T14:44:06.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"6c742a50ccef56ef00338cd62d89869a","title":"257.二叉树的所有路径","content":"257.二叉树的所有路径题目描述：\n二叉树的所有路径\n\n给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。\n叶子节点 是指没有子节点的节点。\nexample 1:\n输入：root &#x3D; [1,2,3,null,5]\n输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]\n\nexample 2:\n输入：root &#x3D; [1]\n输出：[&quot;1&quot;]\n\n提示：\n\n树中节点的数目在范围 [1, 100] 内\n-100 &lt;= Node.val &lt;= 100\n\n题目来源：https://leetcode.cn/problems/binary-tree-paths/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n\n    &#x2F;&#x2F;递归+回溯的方法\n    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;\n        &#x2F;&#x2F;创建结果列表，列表元素是字符串，字符串表示的是路径\n        List&lt;String&gt; result&#x3D;new ArrayList&lt;&gt;();\n        if(root&#x3D;&#x3D;null)\n            return result;\n        &#x2F;&#x2F;用于存储路径，列表元素是整型变量，变量表示的是每一个节点的值\n        List&lt;Integer&gt; paths&#x3D;new ArrayList&lt;&gt;();\n        &#x2F;&#x2F;进行递归和回溯\n        traverse(root,paths,result);\n        &#x2F;&#x2F;返回搜索的路径结果\n        return result;\n    &#125;\n\n    public void traverse(TreeNode node,List&lt;Integer&gt; paths,List&lt;String&gt; result)&#123;\n        &#x2F;&#x2F;将该节点加入路径\n        paths.add(node.val);\n\n        &#x2F;&#x2F;判断是否为叶子节点，如果是叶子节点，则将paths列表转化为路径字符串，并加入到result中，并返回\n        if(node.left&#x3D;&#x3D;null&amp;&amp;node.right&#x3D;&#x3D;null)&#123;\n            StringBuffer temp&#x3D;new StringBuffer();\n            for(int i&#x3D;0;i&lt;paths.size()-1;i++)&#123;\n                temp.append(paths.get(i)).append(&quot;-&gt;&quot;);\n            &#125;\n            temp.append(paths.get(paths.size()-1));\n            result.add(temp.toString());\n            return;\n        &#125;\n        &#x2F;&#x2F;如果该节点存在左孩子，则将左孩子进行递归\n        &#x2F;&#x2F;注意，这里需要将paths列表的最后一个元素弹出，\n        &#x2F;&#x2F;若该元素的左孩子就是叶子节点，则paths最后一个元素就是左孩子节点，因为后续要继续寻找路径，所以这里的叶节点需要弹出。\n        if(node.left!&#x3D;null)&#123;\n            traverse(node.left,paths,result);\n            paths.remove(paths.size()-1);\n        &#125;\n        if(node.right!&#x3D;null)&#123;\n            traverse(node.right,paths,result);\n            paths.remove(paths.size()-1);\n        &#125;\n    &#125;\n&#125;\n\n","slug":"257-二叉树的所有路径","date":"2022-09-29T13:48:25.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"21a7b5849c8515778a333234cc58b5b6","title":"110.平衡二叉树","content":"110.平衡二叉树题目描述：\n平衡二叉树\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n本题中，一棵高度平衡二叉树定义为：\n\n\n\n\n\n\n\n\n\n一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。\nexample 1:\n输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：true\n\nexample 2:\n输入：root &#x3D; [1,2,2,3,3,null,null,4,4]\n输出：false\n\nexample 3:\n输入：root &#x3D; []\n输出：true\n\n提示：\n\n树中的节点数在范围 [0, 5000] 内\n-104 &lt;= Node.val &lt;= 104\n\n题目来源：https://leetcode.cn/problems/balanced-binary-tree/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public int is_balanced(TreeNode node)&#123;\n        &#x2F;&#x2F;若节点为空，则返回高度为0\n        if(node&#x3D;&#x3D;null)\n            return 0;\n        &#x2F;&#x2F;左子树高度，并检查是否左子树是否平衡\n        int left_depth&#x3D;is_balanced(node.left);\n        if(left_depth&#x3D;&#x3D;-1)  return -1;\n        &#x2F;&#x2F;右子树高度，并检查是否右子树是否平衡\n        int right_depth&#x3D;is_balanced(node.right);\n        if(right_depth&#x3D;&#x3D;-1) return -1;\n        &#x2F;&#x2F;如果左子树和右子树高度差大于1，则不平衡，若平衡，则返回当前节点为根节点的树高度\n        return Math.abs(left_depth-right_depth)&gt;1?-1:1+Math.max(right_depth,left_depth);\n    &#125;\n\n    public boolean isBalanced(TreeNode root) &#123;\n        return is_balanced(root)&#x3D;&#x3D;-1?false:true;\n    &#125;\n&#125;\n\n","slug":"110-平衡二叉树","date":"2022-09-27T14:53:38.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"576c683ca9399adeb9bce96faa97dac2","title":"222.完全二叉树的节点个数","content":"222.完全二叉树的节点个数题目描述：\n完全二叉树的节点个数\n\n给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。\n完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。\nexample 1:\n输入：root &#x3D; [1,2,3,4,5,6]\n输出：6\n\nexample 2:\n输入：root &#x3D; []\n输出：0\n\nexample 3:\n输入：root &#x3D; [1]\n输出：1\n\n提示：\n\n树中节点的数目范围是[0, 5 * 104]\n0 &lt;= Node.val &lt;= 5 * 104\n题目数据保证输入的树是 完全二叉树\n\n题目来源：\nhttps://leetcode.cn/problems/count-complete-tree-nodes/\n题解：&#x2F;&#x2F;解法1：层序遍历，记录节点个数\nclass Solution &#123;\n    &#x2F;&#x2F;迭代法\n    public int countNodes(TreeNode root) &#123;\n        if(root&#x3D;&#x3D;null)\n            return 0;\n        int node_count&#x3D;0;\n        Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();\n        queue.offer(root);\n        while(!queue.isEmpty())&#123;\n            TreeNode temp&#x3D;queue.poll();\n            node_count++;\n            if(temp.left!&#x3D;null) queue.offer(temp.left);\n            if(temp.right!&#x3D;null) queue.offer(temp.right);\n        &#125;\n        return node_count;\n\n    &#125;\n&#125;\n\n&#x2F;&#x2F;解法2：利用二叉树性质\nclass Solution &#123;\n    &#x2F;&#x2F;利用完全二叉树的性质，使用递归，查看左遍历深度left_depth，和右深度right_depth,若左右深度相同，则该二叉树为完全二叉树，返回节点个数2^depth-1\n    &#x2F;&#x2F;若左右深度不同，则递归左孩子，求出左子树的节点个数，递归右子树，求出右子树的节点个数，再加上1为根节点。\n    public int countNodes(TreeNode root) &#123;\n        if(root&#x3D;&#x3D;null)\n            return 0;\n        TreeNode left_child&#x3D;root.left;\n        TreeNode right_child&#x3D;root.right;\n        int left_depth&#x3D;0;\n        int right_depth&#x3D;0;\n        while(left_child!&#x3D;null)&#123;\n            left_child&#x3D;left_child.left;\n            left_depth++;\n        &#125;\n        \n        System.out.println(left_depth);\n        while(right_child!&#x3D;null)&#123;\n            right_child&#x3D;right_child.right;\n            right_depth++;\n        &#125;\n        System.out.println(right_depth);\n        &#x2F;&#x2F; 若左右深度相同，则该二叉树为完全二叉树，返回节点个数2^depth-1\n        if(right_depth&#x3D;&#x3D;left_depth)&#123;\n            return (2&lt;&lt;right_depth)-1;\n        &#125;\n        else&#123;\n            &#x2F;&#x2F; 若左右深度不同，则递归左孩子，求出左子树的节点个数，递归右子树，求出右子树的节点个数，再加上1为根节点。\n            return countNodes(root.right)+countNodes(root.left)+1;\n        &#125;\n    &#125;\n&#125;\n\n","slug":"222-完全二叉树的节点个数","date":"2022-09-25T14:17:21.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"5e70057312954f6211ec72bb65eb479c","title":"111.二叉树的最小深度","content":"111.二叉树的最小深度问题描述：\n二叉树的最小深度\n\n给定一个二叉树，找出其最小深度。\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n说明：叶子节点是指没有子节点的节点。\nexample 1:\n输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：2\n\nexample 2:\n输入：root &#x3D; [2,null,3,null,4,null,5,null,6]\n输出：5\n\n提示：\n\n树中节点数的范围在 [0, 105] 内\n-1000 &lt;= Node.val &lt;= 1000\n\n题目来源：\nhttps://leetcode.cn/problems/minimum-depth-of-binary-tree/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;**\n    层序遍历，和最大深度不同，最大深度是记录二叉树拥有的层次，而最小深度，是寻找距离根节点最近的叶子节点，即层序遍历遇到的第一个叶子节点（没有左孩子和右孩子的节点）。\n    \n     *&#x2F;\n    public int minDepth(TreeNode root) &#123;\n        \n        if(root&#x3D;&#x3D;null)\n            return 0;\n        Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();\n        int deep&#x3D;0;\n        queue.offer(root);\n        while(!queue.isEmpty())&#123;\n            int size&#x3D;queue.size();\n            deep++;\n            for(int i&#x3D;0;i&lt;size;i++)&#123;\n                TreeNode temp&#x3D;queue.poll();\n                if(temp.left&#x3D;&#x3D;null&amp;&amp;temp.right&#x3D;&#x3D;null)&#123;\n                    return deep;\n                &#125;\n                if(temp.left!&#x3D;null)&#123;\n                    queue.offer(temp.left);\n                &#125;\n                if(temp.right!&#x3D;null) &#123;\n                    queue.offer(temp.right);\n                &#125;\n\n            &#125;\n        &#125;\n        return deep;\n\n    &#125;\n&#125;\n\n\n","slug":"111-二叉树的最小深度","date":"2022-09-24T14:45:07.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"0db04708e016f3790cc78724de1cd91e","title":"101.对称二叉树","content":"101.对称二叉树题目描述：example 1：\n\t\t1\n      |    |\n      2    2\n    |   |  |   |\n    3   4   4   3\n输入：root &#x3D; [1,2,2,3,4,4,3]\n输出：true\n\nexample 2:\n\t\t1\n      |    |\n      2    2\n        |      |\n        3       3\n输入：root &#x3D; [1,2,2,null,3,null,3]\n输出：false\n\n提示：\n\n树中节点数目在范围 [1, 1000] 内\n-100 &lt;= Node.val &lt;= 100\n\n题目来源：https://leetcode.cn/problems/symmetric-tree/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public boolean isSymmetric(TreeNode root) &#123;\n        return check(root.left,root.right);\n    &#125;\n    public boolean check(TreeNode left,TreeNode right)&#123;\n        &#x2F;&#x2F;当一个空，一个不空，则不对称\n        if(left&#x3D;&#x3D;null&amp;&amp;right!&#x3D;null)\n            return false;\n        if(left!&#x3D;null&amp;&amp;right&#x3D;&#x3D;null)\n            return false;\n        &#x2F;&#x2F;若两个都为空，则对称\n        if(left&#x3D;&#x3D;null&amp;&amp;right&#x3D;&#x3D;null)\n            return true;\n        &#x2F;&#x2F;若两个值不一致，则不对称\n        if(left.val!&#x3D;right.val)\n            return false;\n        &#x2F;&#x2F;若两个值一致，继续判断下一层节点是否对称\n        boolean left_check&#x3D;check(left.left,right.right);\n        boolean right_check&#x3D;check(left.right,right.left);\n        &#x2F;&#x2F;仅当下层所有的节点都对称时，才对称，否则都不对称\n        return left_check&amp;&amp;right_check;\n    &#125;\n&#125;\n\n\n\n","slug":"101-对称二叉树","date":"2022-09-23T13:05:24.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"ef0dd3ab7debf38b3a6c2ed67270d73b","title":"226.翻转二叉树","content":"226. 翻转二叉树题目描述：example 1:\n\t\t4\n      |    |\n      2    7\n    |   |  |   |\n    1   3   6   9\n        4\n      |    |\n      7    2\n    |   |  |   |\n    9   6   3   1\n输入：root &#x3D; [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]\n\nexample 2:\n\t\t2\n      |    |\n      1    3\n        2\n      |    |\n      1    3\n输入：root &#x3D; [2,1,3]\n输出：[2,3,1]\n\nexample 3:\n输入：root &#x3D; []\n输出：[]\n\n提示：\n\n树中节点数目范围在 [0, 100] 内\n-100 &lt;= Node.val &lt;= 100\n\n题目来源:https://leetcode.cn/problems/invert-binary-tree/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;&#x2F;后序遍历，若将遍历节点的左右孩子互换\n    public void postOrder(TreeNode root)&#123;\n        if(root&#x3D;&#x3D;null)\n            return;\n        if(root.left!&#x3D;null) postOrder(root.left);\n        if(root.right!&#x3D;null) postOrder(root.right);\n        TreeNode temp&#x3D;root.left;\n        root.left&#x3D;root.right;\n        root.right&#x3D;temp;\n        \n    &#125;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if(root&#x3D;&#x3D;null)\n            return null;\n        postOrder(root);\n        return root;\n    &#125;\n&#125;\n\n\n\n","slug":"226-翻转二叉树","date":"2022-09-22T14:25:52.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"833c2507cf941e2d538bb205a797d8ee","title":"102二叉树的层次遍历","content":"102.二叉树的层次遍历题目描述：\n二叉树的层序遍历\n\n给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\nexample 1:\n输入：root &#x3D; [3,9,20,null,null,15,7]\n输出：[[3],[9,20],[15,7]]\n\nexample 2:\n输入：root &#x3D; [1]\n输出：[[1]]\n\nexample 3:\n输入：root &#x3D; []\n输出：[]\n\n提示：\n\n树中节点数目在范围 [0, 2000] 内\n-1000 &lt;= Node.val &lt;= 1000\n\n题目来源：https://leetcode.cn/problems/binary-tree-level-order-traversal/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        &#x2F;&#x2F;若树为空，返回空列表\n        if(root&#x3D;&#x3D;null)  return new LinkedList();\n        Queue&lt;TreeNode&gt; queue&#x3D;new LinkedList&lt;&gt;();\n        List&lt;List&lt;Integer&gt;&gt; result&#x3D;new ArrayList&lt;&gt;();\n        &#x2F;&#x2F;根节点入队\n        queue.offer(root);\n\n        &#x2F;&#x2F;每次遍历都将同一层次的所有节点出队，并将节点的左右孩子分别入队。\n        while(!queue.isEmpty())&#123;\n            &#x2F;&#x2F;记录队列长度，即该层节点个数\n            int level_size&#x3D;queue.size();\n            &#x2F;&#x2F;创建列表存储该层节点的值\n            List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();\n            &#x2F;&#x2F;遍历该层所有节点，size就是用来确定该层的元素个数，将该层节点左右孩子依次入队\n            for(int i&#x3D;0;i&lt;level_size;i++)&#123;\n                TreeNode temp&#x3D;queue.poll();\n                list.add(temp.val);\n                if(temp.left!&#x3D;null) queue.offer(temp.left);\n                if(temp.right!&#x3D;null) queue.offer(temp.right);\n\n            &#125;\n            result.add(list);\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n","slug":"102二叉树的层次遍历","date":"2022-09-21T13:56:20.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"c8b3d710ba9b825096c6638c8fc52d7d","title":"94-145-144-二叉树的中后前序遍历-迭代法","content":"94&amp;145&amp;144.二叉树的中后前序遍历题目描述[中]：\n二叉树的中序遍历\n\n给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\nexample 1:\n输入：root &#x3D; [1,null,2,3]\n输出：[1,3,2]\n\nexample 2:\n输入：root &#x3D; []\n输出：[]\n\nexample 3:\n输入：root &#x3D; [1]\n输出：[1]\n\n提示：\n\n树中节点数目在范围 [0, 100] 内\n-100 &lt;= Node.val &lt;= 100\n\n题目来源：https://leetcode.cn/problems/binary-tree-inorder-traversal/\n题解[中]：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n\n    &#x2F;** \n    中序遍历为，左中右，所以和前序遍历不同，需要先从根节点开始，一直向左下遍历，遍历到最后一个左下结点，边遍历边入栈，当没有左孩子了，就将栈顶元素出栈，访问节点的value，并指向该节点的右孩子。\n    *&#x2F;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();\n        if(root&#x3D;&#x3D;null)\n            return result;\n        TreeNode p&#x3D;root;\n        while(p!&#x3D;null||!stack.isEmpty())&#123;\n            if(p!&#x3D;null)&#123;\n                stack.push(p);\n                p&#x3D;p.left;\n            &#125;else&#123;\n                p&#x3D;stack.pop();\n                result.add(p.val);\n                p&#x3D;p.right;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n\n&#125;\n\n\n\n\n\n题目描述[后]：\n二叉树的后序遍历\n\n给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。\nexample 1:\n输入：root &#x3D; [1,null,2,3]\n输出：[3,2,1]\n\nexample 2:\n输入：root &#x3D; []\n输出：[]\n\nexample 3:\n输入：root &#x3D; [1]\n输出：[1]\n\n提示：\n\n树中节点数目在范围 [0, 100] 内\n-100 &lt;= Node.val &lt;= 100\n\n题目来源：https://leetcode.cn/problems/binary-tree-postorder-traversal/\n题解[后]：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;**\n    只要在先序遍历迭代法的基础上进行修改即可，先入左孩子，再入右孩子。最后遍历完成后，对得到的列表元素进行反转，即可得到后序遍历序列\n     *&#x2F;\n   public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        if(root&#x3D;&#x3D;null)\n            return result;\n        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();\n        stack.push(root);\n        while(!stack.isEmpty())&#123;\n            TreeNode node&#x3D;stack.pop();\n            result.add(node.val);\n            if(node.left!&#x3D;null) stack.push(node.left);\n            if(node.right!&#x3D;null) stack.push(node.right);\n        &#125;\n        Collections.reverse(result);\n        return result;\n    &#125;\n&#125;\n\n\n\n题目描述[前]：\n二叉树的前序遍历\n\n给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\nexample 1:\n输入：root &#x3D; [1,null,2,3]\n输出：[1,2,3]\n\nexample 2:\n输入：root &#x3D; []\n输出：[]\n\nexample 3:\n输入：root &#x3D; [1]\n输出：[1]\n\n提示：\n\n树中节点数目在范围 [0, 100] 内\n-100 &lt;= Node.val &lt;= 100\n\n题目来源：https://leetcode.cn/problems/binary-tree-preorder-traversal/\n题解[前]：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    &#x2F;**\n    使用栈实现前序遍历，首先根节点入栈，开始循环，先出栈，访问出栈节点value，然后右孩子入栈，然后左孩子入栈，开始下一轮循环。之所以先右如，后左如，是为了保证出栈时先访问左孩子，后访问右孩子。\n     *&#x2F;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        Stack&lt;TreeNode&gt; stack&#x3D;new Stack&lt;&gt;();\n        if(root&#x3D;&#x3D;null)\n            return result;\n        stack.push(root);\n        while(!stack.isEmpty())&#123;\n            TreeNode node&#x3D;stack.pop();\n            result.add(node.val);\n            if(node.right!&#x3D;null) stack.push(node.right);\n            if(node.left!&#x3D;null) stack.push(node.left);\n        &#125;\n    \n        return result;\n    &#125;\n&#125;\n\n\n\n\n\n","slug":"94-145-144-二叉树的中后前序遍历-迭代法","date":"2022-09-20T12:40:17.000Z","categories_index":"","tags_index":"","author_index":"LiuQuanZe"},{"id":"ed6d09f7c666a266cc6ff445e8452d5b","title":"94&145&144.二叉树的中后前序遍历","content":"94&amp;145&amp;144.二叉树的中后前序遍历题目描述[中]：\n二叉树的中序遍历\n\n给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\nexample 1:\n输入：root &#x3D; [1,null,2,3]\n输出：[1,3,2]\n\nexample 2:\n输入：root &#x3D; []\n输出：[]\n\nexample 3:\n输入：root &#x3D; [1]\n输出：[1]\n\n提示：\n\n树中节点数目在范围 [0, 100] 内\n-100 &lt;= Node.val &lt;= 100\n\n题目来源：https://leetcode.cn/problems/binary-tree-inorder-traversal/\n题解[中]：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n        public void inOrder(TreeNode root,List&lt;Integer&gt; result)&#123;\n        if(root&#x3D;&#x3D;null)\n            return;\n        inOrder(root.left,result);\n        result.add(root.val);\n        inOrder(root.right,result);\n    &#125;\n\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        inOrder(root,result);\n        return result;\n    &#125;\n\n&#125;\n\n\n\n\n\n题目描述[后]：\n二叉树的后序遍历\n\n给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。\nexample 1:\n输入：root &#x3D; [1,null,2,3]\n输出：[3,2,1]\n\nexample 2:\n输入：root &#x3D; []\n输出：[]\n\nexample 3:\n输入：root &#x3D; [1]\n输出：[1]\n\n提示：\n\n树中节点数目在范围 [0, 100] 内\n-100 &lt;= Node.val &lt;= 100\n\n题目来源：https://leetcode.cn/problems/binary-tree-postorder-traversal/\n题解[后]：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public void postOrder(TreeNode root,List&lt;Integer&gt; result)&#123;\n        if(root&#x3D;&#x3D;null)\n            return ;\n        postOrder(root.left,result);\n        postOrder(root.right,result);\n        result.add(root.val);\n    &#125;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        postOrder(root,result);\n        return result;\n    &#125;\n&#125;\n\n\n\n题目描述[前]：\n二叉树的前序遍历\n\n给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\nexample 1:\n输入：root &#x3D; [1,null,2,3]\n输出：[1,2,3]\n\nexample 2:\n输入：root &#x3D; []\n输出：[]\n\nexample 3:\n输入：root &#x3D; [1]\n输出：[1]\n\n提示：\n\n树中节点数目在范围 [0, 100] 内\n-100 &lt;= Node.val &lt;= 100\n\n题目来源：https://leetcode.cn/problems/binary-tree-preorder-traversal/\n题解[前]：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public void preOrder(TreeNode root,List&lt;Integer&gt; result)&#123;\n        if(root&#x3D;&#x3D;null)\n            return;\n        result.add(root.val);\n        preOrder(root.left,result);\n        preOrder(root.right,result);\n    &#125;\n\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result&#x3D;new ArrayList&lt;&gt;();\n        preOrder(root,result);\n        return result;\n    &#125;\n&#125;\n\n\n\n\n\n","slug":"94-145-144-二叉树的中后前序遍历","date":"2022-09-19T11:44:26.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,二叉树","author_index":"LiuQuanZe"},{"id":"9087aaa078842eff85ab79f796fcf5f3","title":"239.滑动窗口的最大值","content":"239.滑动窗口的最大值题目描述：\n滑动窗口最大值\n\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\nexample 1:\n输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\n提示：\n\n1 &lt;= nums.length &lt;= 105\n-104 &lt;= nums[i] &lt;= 104\n1 &lt;= k &lt;= nums.length\n\n题目来源：https://leetcode.cn/problems/sliding-window-maximum\n题解：&#x2F;&#x2F;自定义数组\nclass MyQueue &#123;\n    Deque&lt;Integer&gt; deque &#x3D; new LinkedList&lt;&gt;();\n    &#x2F;&#x2F;弹出元素时，比较当前要弹出的数值是否等于队列出口的数值；\n    &#x2F;&#x2F;仅有两种可能，1.要弹出的元素等于队列出口元素，那么就弹出，因为表示该元素是上一个滑动窗口的最大值，下一个滑动窗口中不包含该元素，需要新的最大值\n    &#x2F;&#x2F;2.需要弹出的元素小于队列出口元素，则不进行处理，因为对下一个滑动窗口的最大值选取没有影响\n    &#x2F;&#x2F;同时判断队列当前是否为空\n    void poll(int val) &#123;\n        if (!deque.isEmpty() &amp;&amp; val &#x3D;&#x3D; deque.peek()) &#123;\n            deque.poll();\n        &#125;\n    &#125;\n    &#x2F;&#x2F;添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出\n    &#x2F;&#x2F;保证队列元素单调递减\n    &#x2F;&#x2F;比如此时队列元素【4,2,1】，3将要入队，比1大，所以1弹出，此时队列：【4,2】，循环再次判断，3和2进行比较，3大于2，所以2弹出，此时队列【4】，再次和4比较，3小于4，跳出循环，将3加入队尾，此时队列变为【4,3】\n    void add(int val) &#123;\n        while (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123;\n            deque.removeLast();\n        &#125;\n        deque.add(val);\n    &#125;\n    &#x2F;&#x2F;队列队顶元素始终为最大值[获取队头元素，因为队列是有序的，因此队头元素是最大值，即当前滑动窗口的最大值]\n    int peek() &#123;\n        return deque.peek();\n    &#125;\n&#125;\n\nclass Solution &#123;\n    public int[] maxSlidingWindow(int[] nums, int k) &#123;\n        if (nums.length &#x3D;&#x3D; 1) &#123;\n            return nums;\n        &#125;\n        int len &#x3D; nums.length - k + 1;\n        &#x2F;&#x2F;存放结果元素的数组\n        int[] res &#x3D; new int[len];\n        int num &#x3D; 0;\n        &#x2F;&#x2F;自定义队列\n        MyQueue myQueue &#x3D; new MyQueue();\n        &#x2F;&#x2F;先将前k的元素放入队列，也就是第一个滑动窗口中的所有元素放入队列中\n        for (int i &#x3D; 0; i &lt; k; i++) &#123;\n            myQueue.add(nums[i]);\n        &#125;\n        &#x2F;&#x2F;由于add方法是自动会对插入元素进行排序的，因此当将第一个滑动窗口的元素放入队列中后，队头元素就已经是最大元素了，即第一滑动窗口的元素\n        res[num++] &#x3D; myQueue.peek();\n        &#x2F;&#x2F;开始将窗口进行滑动，即再次从第二个滑动窗口进行遍历\n        for (int i &#x3D; k; i &lt; nums.length; i++) &#123;\n            &#x2F;&#x2F;弹出上一个滑动窗口的元素，加入该滑动窗口的新元素，然后获取该滑动窗口的最大值\n            &#x2F;&#x2F;滑动窗口移除最前面的元素，移除是判断该元素是否放入队列\n            myQueue.poll(nums[i - k]);\n            &#x2F;&#x2F;滑动窗口加入最后面的元素\n            myQueue.add(nums[i]);\n            &#x2F;&#x2F;记录对应的最大值\n            res[num++] &#x3D; myQueue.peek();\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n\n\n","slug":"239-滑动窗口的最大值","date":"2022-09-18T05:03:58.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,栈和队列","author_index":"LiuQuanZe"},{"id":"b64a14a9b898433644724b2c4c472c30","title":"150. 逆波兰表达式求值","content":"150.逆波兰表达式求值题目描述：\n逆波兰表达式求值\n\n根据 逆波兰表示法，求表达式的值。\n有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n注意 两个整数之间的除法只保留整数部分。\n可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\nexample 1:\n输入：tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n输出：9\n解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9\n\nexample 2:\n输入：tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;]\n输出：6\n解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6\n\nexample 3:\n输入：tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n输出：22\n解释：该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5\n&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5\n&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5\n&#x3D; ((10 * 0) + 17) + 5\n&#x3D; (0 + 17) + 5\n&#x3D; 17 + 5\n&#x3D; 22\n\n提示：\n\n1 &lt;&#x3D; tokens.length &lt;&#x3D; 104\ntokens[i] 是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数\n\n题目来源：https://leetcode.cn/problems/evaluate-reverse-polish-notation\n题解：class Solution &#123;\n    &#x2F;**\n    如果是遍历到数字，则进站，如果遍历到运算符，则将栈顶的两个元素出栈，然后经过该运算符运算，将运算结果入栈。遍历完成后将栈顶元素出栈，该元素就是最终的运算结果\n     *&#x2F;\n    public int evalRPN(String[] tokens) &#123;\n        Deque&lt;Integer&gt; stack &#x3D; new LinkedList();\n        for (String s : tokens) &#123;\n            if (&quot;+&quot;.equals(s)) &#123;        &#x2F;&#x2F; leetcode 内置jdk的问题，不能使用&#x3D;&#x3D;判断字符串是否相等\n                stack.push(stack.pop() + stack.pop());      &#x2F;&#x2F; 注意 - 和&#x2F; 需要特殊处理\n            &#125; else if (&quot;-&quot;.equals(s)) &#123;\n                stack.push(-stack.pop() + stack.pop());\n            &#125; else if (&quot;*&quot;.equals(s)) &#123;\n                stack.push(stack.pop() * stack.pop());\n            &#125; else if (&quot;&#x2F;&quot;.equals(s)) &#123;\n                int temp1 &#x3D; stack.pop();\n                int temp2 &#x3D; stack.pop();\n                stack.push(temp2 &#x2F; temp1);\n            &#125; else &#123;\n                stack.push(Integer.valueOf(s));\n            &#125;\n        &#125;\n        return stack.pop();\n    &#125;\n&#125;\n\n","slug":"150-逆波兰表达式求值","date":"2022-09-17T00:27:04.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,栈和队列","author_index":"LiuQuanZe"},{"id":"1e9d09714216aecd266bb235c84e915f","title":"1047.删除字符串中所有相邻重复项","content":"1047.删除字符串中所有相邻重复项题目描述：\n删除字符串中的所有相邻重复项\n\n给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。\n在 S 上反复执行重复项删除操作，直到无法继续删除。\n在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\nexample 1:\n输入：&quot;abbaca&quot;\n输出：&quot;ca&quot;\n解释：\n例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。\n\n提示：\n\n1 &lt;= S.length &lt;= 20000\nS 仅由小写英文字母组成。\n\n题目来源：https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string\n题解：class Solution &#123;\n    public String removeDuplicates(String S) &#123;\n        &#x2F;&#x2F;创建deque\n        ArrayDeque&lt;Character&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        char ch;\n        &#x2F;&#x2F;遍历字符串，检查栈顶元素是否与当前遍历元素相同，如果相同，则栈顶元素出栈，否则当前遍历元素入栈。，若栈为空，则直接入栈\n        for (int i &#x3D; 0; i &lt; S.length(); i++) &#123;\n            ch &#x3D; S.charAt(i);\n            if (deque.isEmpty() || deque.peek() !&#x3D; ch) &#123;\n                deque.push(ch);\n            &#125; else &#123;\n                deque.pop();\n            &#125;\n        &#125;\n        String str &#x3D; &quot;&quot;;\n        &#x2F;&#x2F;剩余的元素即为不重复的元素，注意这里是出栈元素拼接str，不要搞反，因为出栈的字符是逆序的\n        while (!deque.isEmpty()) &#123;\n            str &#x3D; deque.pop() + str;\n        &#125;\n        return str;\n\n    &#125;\n&#125;\n\n","slug":"1047-删除字符串中所有相邻重复项","date":"2022-09-16T15:21:54.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,栈和队列","author_index":"LiuQuanZe"},{"id":"965581e4ba331d2a60f395aea86a2168","title":"20.有效的括号","content":"20.有效的括号题目描述：\n有效的括号\n\n给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。\n\nexample 1:\n输入：s &#x3D; &quot;()&quot;\n输出：true\n\nexample 2:\n输入：s &#x3D; &quot;()[]&#123;&#125;&quot;\n输出：true\n\nexample 3:\n输入：s &#x3D; &quot;(]&quot;\n输出：false\n\n提示：\n\n1 &lt;= s.length &lt;= 104\ns 仅由括号 &#39;()[]&#123;&#125;&#39; 组成\n\n题目来源：https://leetcode.cn/problems/valid-parentheses/\n题解：class Solution &#123;\n    public boolean isValid(String s) &#123;\n        Deque&lt;Character&gt; deque &#x3D; new LinkedList&lt;&gt;();\n        char ch;\n        for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;\n            ch &#x3D; s.charAt(i);\n            &#x2F;&#x2F;碰到左括号，就把相应的右括号入栈\n            if (ch &#x3D;&#x3D; &#39;(&#39;) &#123;\n                deque.push(&#39;)&#39;);\n            &#125;else if (ch &#x3D;&#x3D; &#39;&#123;&#39;) &#123;\n                deque.push(&#39;&#125;&#39;);\n            &#125;else if (ch &#x3D;&#x3D; &#39;[&#39;) &#123;\n                deque.push(&#39;]&#39;);\n            &#125; else if (deque.isEmpty() || deque.peek() !&#x3D; ch) &#123;\n                return false;\n            &#125;else &#123;&#x2F;&#x2F;如果是右括号判断是否和栈顶元素匹配\n                deque.pop();\n            &#125;\n        &#125;\n        &#x2F;&#x2F;最后判断栈中元素是否匹配\n        return deque.isEmpty();\n    &#125;\n&#125;\n\n","slug":"20-有效的括号","date":"2022-09-15T15:43:52.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,栈和队列","author_index":"LiuQuanZe"},{"id":"5411a6b47b43d9c6d288402eac141a08","title":"225.用队列实现栈","content":"225.用队列实现栈问题描述：\n用队列实现栈\n\n请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\n实现 MyStack 类：\n\nvoid push(int x) 将元素 x 压入栈顶。\nint pop() 移除并返回栈顶元素。\nint top() 返回栈顶元素。\nboolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n注意：\n\n你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。\n你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n\nexample 1:\n输入：\n[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 2, 2, false]\n\n解释：\nMyStack myStack &#x3D; new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); &#x2F;&#x2F; 返回 2\nmyStack.pop(); &#x2F;&#x2F; 返回 2\nmyStack.empty(); &#x2F;&#x2F; 返回 False\n\n提示：\n\n1 &lt;= x &lt;= 9\n最多调用100 次 push、pop、top 和 empty\n每次调用 pop 和 top 都保证栈不为空\n\n题目来源：https://leetcode.cn/problems/implement-stack-using-queues\n题解：class MyStack &#123;\n    &#x2F;** \n        队列模拟栈，其实一个队列就够了，那么我们先说一说两个队列来实现栈的思路。\n\n    队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。\n\n    所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。\n\n    但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是另一个队列完全用又来备份的！\n\n    如下面动画所示，用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。\n    *&#x2F;\n    &#x2F;&#x2F; Deque 接口继承了 Queue 接口\n    &#x2F;&#x2F; 所以 Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst\n    Deque&lt;Integer&gt; que1;\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    public MyStack() &#123;\n        que1 &#x3D; new ArrayDeque&lt;&gt;();\n    &#125;\n    \n    &#x2F;** Push element x onto stack. *&#x2F;\n    public void push(int x) &#123;\n        que1.addLast(x);\n    &#125;\n    \n    &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;\n    public int pop() &#123;\n        int size &#x3D; que1.size();\n        size--;\n        &#x2F;&#x2F; 将 que1 除了最后一个元素之外的所有元素从队头移到队尾，相当于暴露最后一个元素，用以满足栈的先进后出的特性，同时将元素从队头移到队尾的操作可以替换原先的使用另一个辅助队列的方式，降低了时间复杂度\n        while (size-- &gt; 0) &#123;\n            que1.addLast(que1.peekFirst());\n            que1.pollFirst();\n        &#125;\n\n        int res &#x3D; que1.pollFirst();\n        return res;\n    &#125;\n    \n    &#x2F;** Get the top element. *&#x2F;\n    public int top() &#123;\n        return que1.peekLast();\n    &#125;\n    \n    &#x2F;** Returns whether the stack is empty. *&#x2F;\n    public boolean empty() &#123;\n        return que1.isEmpty();\n    &#125;\n&#125;\n\n&#x2F;**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj &#x3D; new MyStack();\n * obj.push(x);\n * int param_2 &#x3D; obj.pop();\n * int param_3 &#x3D; obj.top();\n * boolean param_4 &#x3D; obj.empty();\n *&#x2F;\n\n","slug":"225-用队列实现栈","date":"2022-09-14T14:46:17.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,栈和队列","author_index":"LiuQuanZe"},{"id":"d91274a3d01b11b2d199e36958cb424f","title":"232.用栈实现队列","content":"232.用栈实现队列题目描述：\n用栈实现队列\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾\nint pop() 从队列的开头移除并返回元素\nint peek() 返回队列开头的元素\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n说明：\n\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\nexample 1:\n输入：\n[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue &#x3D; new MyQueue();\nmyQueue.push(1); &#x2F;&#x2F; queue is: [1]\nmyQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); &#x2F;&#x2F; return 1\nmyQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]\nmyQueue.empty(); &#x2F;&#x2F; return false\n\n提示：\n1 &lt;&#x3D; x &lt;&#x3D; 9最多调用 100 次 push、pop、peek 和 empty假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n题目来源：https://leetcode.cn/problems/implement-queue-using-stacks\n题解：class MyQueue &#123;\n    Stack&lt;Integer&gt; in;\n    Stack&lt;Integer&gt; out;\n\n    public MyQueue() &#123;\n        in&#x3D;new Stack&lt;&gt;();\n        out&#x3D;new Stack&lt;&gt;();\n    &#125;\n    \n    public void push(int x) &#123;\n        in.push(x);\n    &#125;\n    \n    &#x2F;&#x2F;输出栈为空，则将输入栈的元素全部存入输出栈，然后pop输出栈；若输出栈不为空，则直接pop输出栈\n    public int pop() &#123;\n        if(out.isEmpty())&#123;\n            while(!in.isEmpty())&#123;\n                int temp&#x3D;in.pop();\n                out.push(temp);\n            &#125;\n        &#125;\n        return out.pop();\n\n\n    &#125;\n    \n    &#x2F;&#x2F;输出栈为空，则将输入栈的元素全部存入输出栈，然后peek输出栈；若输出栈不为空，则直接peek输出栈\n    public int peek() &#123;\n        if(out.isEmpty())&#123;\n            while(!in.isEmpty())&#123;\n                int temp&#x3D;in.pop();\n                out.push(temp);\n            &#125;\n        &#125;\n        return out.peek();\n    &#125;\n    &#x2F;&#x2F;输入输出栈均为空时，队列为空\n    public boolean empty() &#123;\n        return in.isEmpty()&amp;&amp;out.isEmpty();\n\n    &#125;\n&#125;\n\n&#x2F;**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj &#x3D; new MyQueue();\n * obj.push(x);\n * int param_2 &#x3D; obj.pop();\n * int param_3 &#x3D; obj.peek();\n * boolean param_4 &#x3D; obj.empty();\n *&#x2F;\n\n","slug":"232-用栈实现队列","date":"2022-09-12T11:50:50.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,栈和队列","author_index":"LiuQuanZe"},{"id":"92bbfd2514ed32aedece3fa7e7cce0b7","title":"28.实现 strStr()","content":"28.实现 strStr()题目描述：\n实现 strStr()\n\n实现 strStr() 函数。\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。\n说明：\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。\nexample 1:\n输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;\n输出：2\n\nexample 2:\n输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;\n输出：-1\n\n提示：\n\n1 &lt;= haystack.length, needle.length &lt;= 104\nhaystack 和 needle 仅由小写英文字符组成\n\n题目来源：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/\n题解：&#x2F;&#x2F; 方法一\nclass Solution &#123;\n    &#x2F;&#x2F;求出next数组\n    public void getNext(int[] next,String s)&#123;\n        int j&#x3D;-1;\n        next[0]&#x3D;j;\n        &#x2F;&#x2F;j指向前缀的末尾，i指向后缀的末尾\n        for(int i&#x3D;1;i&lt;next.length;i++)&#123;\n            &#x2F;&#x2F;若前缀的末尾和后缀的末尾不匹配，则将前缀的末尾进行回退\n            while(j&gt;&#x3D;0&amp;&amp;s.charAt(i)!&#x3D;s.charAt(j+1))&#123;\n                j&#x3D;next[j];\n            &#125;\n            &#x2F;&#x2F;若匹配成功，则i和j都向后移动\n            if(s.charAt(i)&#x3D;&#x3D;s.charAt(j+1))&#123;\n                j++;\n            &#125;\n            &#x2F;&#x2F;求得最大前后缀长度\n            next[i]&#x3D;j;\n        &#125;\n        \n    &#125;\n    \n    public int strStr(String haystack, String needle) &#123;\n        int[] next&#x3D;new int[needle.length()];\n        &#x2F;&#x2F;j为模式串指针\n        int j&#x3D;-1;\n        &#x2F;&#x2F;求next数组\n        getNext(next,needle);\n        &#x2F;&#x2F;i为匹配串指针\n        for(int i&#x3D;0;i&lt;haystack.length();i++)&#123;\n            &#x2F;&#x2F;若匹配失败，则模式串指针回退\n            while(j&gt;&#x3D;0&amp;&amp;haystack.charAt(i)!&#x3D;needle.charAt(j+1))&#123;\n                j&#x3D;next[j];\n            &#125;\n            &#x2F;&#x2F;匹配成功继续向后匹配\n            if(needle.charAt(j+1)&#x3D;&#x3D;haystack.charAt(i))&#123;\n                j++;\n            &#125;\n            &#x2F;&#x2F;判断模式串是否匹配成功，若j到达模式串末尾，则返回匹配成功位置\n            if(j&#x3D;&#x3D;needle.length()-1)&#123;\n                return i-needle.length()+1;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;匹配失败\n        return -1;\n    &#125;\n&#125;\n\n","slug":"28-实现-strStr","date":"2022-09-11T14:34:12.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,字符串","author_index":"LiuQuanZe"},{"id":"d3c414b58259addf0d47c58705b851eb","title":"459.重复的子字符串","content":"459.重复的子字符串题目描述：\n重复的子字符串\n\n给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。\nexample 1:\n输入: s &#x3D; &quot;abab&quot;\n输出: true\n解释: 可由子串 &quot;ab&quot; 重复两次构成。\n\nexample 2:\n输入: s &#x3D; &quot;aba&quot;\n输出: false\n\nexample 3:\n输入: s &#x3D; &quot;abcabcabcabc&quot;\n输出: true\n解释: 可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。)\n\n提示：\n\n1 &lt;= s.length &lt;= 104\ns 由小写英文字母组成\n\n题目来源：https://leetcode.cn/problems/repeated-substring-pattern/\n题解：&#x2F;*\n将两个 ss 连在一起，并移除第一个和最后一个字符。如果 ss 是该字符串的子串，那么 ss 就满足题目要求。\n\n注意到我们证明的是如果 ss 满足题目要求，那么 ss 有这样的性质，而我们使用的方法却是如果 ss 有这样的性质，那么 ss 满足题目要求。因此，只证明了充分性是远远不够的，我们还需要证明必要性。\n*&#x2F;\nclass Solution &#123;\n    public boolean repeatedSubstringPattern(String s) &#123;\n        &#x2F;&#x2F;将字符串进行拼接，查看拼接完后第二个字符串的位置，\n        return (s+s).indexOf(s,1)!&#x3D;s.length();\n    &#125;\n&#125;\n\n","slug":"459-重复的子字符串","date":"2022-09-10T12:17:28.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,字符串","author_index":"LiuQuanZe"},{"id":"2416193f75be6eeb61e08489a1aa53a0","title":"剑指Offer58-II.左旋转字符串","content":"剑指Offer58-II.左旋转字符串题目描述：剑指 Offer 58 - II. 左旋转字符串\n字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。\nexample 1:\n输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2\n输出: &quot;cdefgab&quot;\n\nexample 2:\n输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6\n输出: &quot;umghlrlose&quot;\n\n提示：\n\n1 &lt;= k &lt; s.length &lt;= 10000\n\n题目来源：剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）\n题解：\nclass Solution &#123;\n    &#x2F;&#x2F;先反转1-n的字符串，然后反转n+1到末尾的字符串\n    &#x2F;&#x2F;最后对整个字符串进行反转，不需要额外的空间\n    public String reverseLeftWords(String s, int n) &#123;\n        int len&#x3D;s.length();\n        StringBuilder sb&#x3D;new StringBuilder(s);\n        reverseString(sb,0,n-1);\n        reverseString(sb,n,len-1);\n        return sb.reverse().toString();\n    &#125;\n     public void reverseString(StringBuilder sb, int start, int end) &#123;\n        while (start &lt; end) &#123;\n            char temp &#x3D; sb.charAt(start);\n            sb.setCharAt(start, sb.charAt(end));\n            sb.setCharAt(end, temp);\n            start++;\n            end--;\n            &#125;\n        &#125;\n&#125;\n\n","slug":"剑指Offer58-II-左旋转字符串","date":"2022-09-07T13:28:59.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,字符串","author_index":"LiuQuanZe"},{"id":"bf3e3be4adc10fbd226da035ce8a9591","title":"151.反转字符串中的单词","content":"151.反转字符串中的单词题目描述：\n反转字符串中的单词\n\n给你一个字符串 s ，请你反转字符串中 单词 的顺序。\n单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\nexample 1:\n输入：s &#x3D; &quot;the sky is blue&quot;\n输出：&quot;blue is sky the&quot;\n\nexample 2:\n输入：s &#x3D; &quot;  hello world  &quot;\n输出：&quot;world hello&quot;\n解释：反转后的字符串中不能存在前导空格和尾随空格。\n\nexample 3:\n输入：s &#x3D; &quot;a good   example&quot;\n输出：&quot;example good a&quot;\n解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n\n提示：\n\n1 &lt;= s.length &lt;= 104\ns 包含英文大小写字母、数字和空格 &#39; &#39;\ns 中 至少存在一个 单词\n\n题目来源：https://leetcode.cn/problems/reverse-words-in-a-string\n题解：class Solution &#123;\n    public String reverseWords(String s) &#123;\n        &#x2F;&#x2F;源字符数组\n        char[] s_char&#x3D;s.toCharArray();\n        &#x2F;&#x2F;创建新的字符数组\n        char[] new_str&#x3D;new char[s_char.length+1];\n        &#x2F;&#x2F;新字符数组指针\n        int newStr_index&#x3D;0;\n        &#x2F;&#x2F;源字符数组指针，从末尾开始\n        int i&#x3D;s_char.length-1;\n        &#x2F;&#x2F;从后向前遍历\n        while(i&gt;&#x3D;0)&#123;\n            &#x2F;&#x2F;找到最后一个单词的末尾位置并记录\n            while(i&gt;&#x3D;0&amp;&amp;s_char[i]&#x3D;&#x3D;&#39; &#39;) i--;\n            int right&#x3D;i;\n            &#x2F;&#x2F;找到最后一个单词的起始位置并记录\n            while(i&gt;&#x3D;0&amp;&amp;s_char[i]!&#x3D;&#39; &#39;) i--;\n            int left&#x3D;i+1;\n            &#x2F;&#x2F;将原字符数组的最后一个单词，存入新字符数组的第一个单词位置\n            for(int j&#x3D;left;j&lt;&#x3D;right;j++)&#123;\n                new_str[newStr_index++]&#x3D;s_char[j];\n                &#x2F;&#x2F;若遍历到单词末尾，则添加空格\n                if(j&#x3D;&#x3D;right)&#123;\n                    new_str[newStr_index++]&#x3D;&#39; &#39;;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;若原数组没有单词，则返回空字符串\n        if(newStr_index&#x3D;&#x3D;0)&#123;\n            return &quot;&quot;;\n            &#x2F;&#x2F;否则返回反转后的字符串\n        &#125;else&#123;\n            return new String(new_str,0,newStr_index-1);\n        &#125;\n\n    &#125;\n&#125;\n\n","slug":"151-反转字符串中的单词","date":"2022-09-06T13:39:09.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,字符串","author_index":"LiuQuanZe"},{"id":"e719937f6951d143569f327df963f42d","title":"05.替换空格","content":"05.替换空格题目描述：剑指 Offer 05. 替换空格\n请实现一个函数，把字符串 s 中的每个空格替换成”%20”。\nexample 1:\n输入：s &#x3D; &quot;We are happy.&quot;\n输出：&quot;We%20are%20happy.&quot;\n\n提示：\n0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000\n题目来源：https://leetcode.cn/problems/ti-huan-kong-ge-lcof/\n题解：&#x2F;&#x2F;常规方法：从前向后遍历，遇到空格则替换为&quot;02%&quot;，可以使用StringBuilder实现，但是每次替换，后面的字符串需要向后移动\n&#x2F;&#x2F;使用一个新的对象，复制 str，复制的过程对其判断，是空格则替换，否则直接复制，类似于数组复制\npublic static String replaceSpace(StringBuffer str) &#123;\n        if (str &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n\t\t&#x2F;&#x2F;选用 StringBuilder 单线程使用，比较快，选不选都行\n        StringBuilder sb &#x3D; new StringBuilder();\n\t\t&#x2F;&#x2F;使用 sb 逐个复制 str ，碰到空格则替换，否则直接复制\n        for (int i &#x3D; 0; i &lt; str.length(); i++) &#123;\n\t\t&#x2F;&#x2F;str.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型\n        &#x2F;&#x2F;if (&quot; &quot;.equals(String.valueOf(str.charAt(i))))&#123;\n            if (s.charAt(i) &#x3D;&#x3D; &#39; &#39;) &#123;\n                sb.append(&quot;%20&quot;);\n            &#125; else &#123;\n                sb.append(str.charAt(i));\n            &#125;\n        &#125;\n        return sb.toString();\n    &#125;\n&#x2F;&#x2F;从后向前遍历，使用双指针的方法进行实现，速度更快beat 100%\nclass Solution &#123;\n    public String replaceSpace(String s) &#123;\n        &#x2F;&#x2F;判断参数是否合法\n        if(s.length()&#x3D;&#x3D;0||s&#x3D;&#x3D;null)&#123;\n            return s;\n        &#125;\n        &#x2F;&#x2F;拼接字符串\n        StringBuilder tail&#x3D;new StringBuilder();\n        &#x2F;&#x2F;每遍历到一个空格，拼接字符串扩大两个空格大小\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            if(s.charAt(i)&#x3D;&#x3D;&#39; &#39;)&#123;\n                tail.append(&quot;  &quot;);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;若不存在空格，则直接返回\n        if(tail.length()&#x3D;&#x3D;0)&#123;\n            return s;\n        &#125;\n        &#x2F;&#x2F;记录左右指针\n        int left&#x3D;s.length()-1;\n        s+&#x3D;tail;\n        int right&#x3D;s.length()-1;\n        char[] chars&#x3D;s.toCharArray();\n        &#x2F;&#x2F;左指针i从后向前遍历\n        while(left&gt;&#x3D;0)&#123;\n            if(chars[left]&#x3D;&#x3D;&#39; &#39;)&#123;\n                chars[right--]&#x3D;&#39;0&#39;;\n                chars[right--]&#x3D;&#39;2&#39;;\n                chars[right]&#x3D;&#39;%&#39;;\n            &#125;else&#123;\n                chars[right]&#x3D;chars[left];\n            &#125;\n            left--;\n            right--;\n        &#125;\n        return new String(chars);\n    &#125;\n&#125;\n\n\n\n\n\n\n","slug":"05-替换空格","date":"2022-09-05T14:29:42.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,字符串","author_index":"LiuQuanZe"},{"id":"097e37183692c086b0f10d951c3da4e4","title":"541.反转字符串Ⅱ","content":"541.反转字符串Ⅱ题目描述：\n反转字符串 II\n\n给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。\n\n如果剩余字符少于 k 个，则将剩余字符全部反转。\n如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n\nexample 1：\n输入：s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2\n输出：&quot;bacdfeg&quot;\n\nexample 2:\n输入：s &#x3D; &quot;abcd&quot;, k &#x3D; 2\n输出：&quot;bacd&quot;\n\n提示：\n\n1 &lt;= s.length &lt;= 104\ns 仅由小写英文组成\n1 &lt;= k &lt;= 104\n\n题目来源：https://leetcode.cn/problems/reverse-string-ii/\n题解：class Solution &#123;\n    public String reverseStr(String s, int k) &#123;\n        char[] ch &#x3D; s.toCharArray();\n        &#x2F;&#x2F; 1. 每隔 2k 个字符的前 k 个字符进行反转，每次循环挑出一个2k区间\n        for (int i &#x3D; 0; i&lt; ch.length; i +&#x3D; 2 * k) &#123;\n            &#x2F;&#x2F; 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符\n            if (i + k &lt;&#x3D; ch.length) &#123;\n                reverse(ch, i, i + k -1);\n                continue;\n            &#125;\n            &#x2F;&#x2F; 3. 剩余字符少于 k 个，则将剩余字符全部反转\n            reverse(ch, i, ch.length - 1);\n        &#125;\n        return  new String(ch);\n\n    &#125;\n    &#x2F;&#x2F; 定义翻转函数\n    public void reverse(char[] ch, int i, int j) &#123;\n    for (; i &lt; j; i++, j--) &#123;\n        char temp  &#x3D; ch[i];\n        ch[i] &#x3D; ch[j];\n        ch[j] &#x3D; temp;\n    &#125;\n\n    &#125;\n&#125;\n\n","slug":"541-反转字符串Ⅱ","date":"2022-09-03T13:23:56.000Z","categories_index":"","tags_index":"Java,leetcode,字符串","author_index":"LiuQuanZe"},{"id":"db3930f2bf194d71c39748bb27ba1de2","title":"344.反转字符串","content":"344.反转字符串题目描述：\n反转字符串\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。\nexample 1:\n输入：s &#x3D; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]\n输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]\n\nexample 2:\n输入：s &#x3D; [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]\n输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]\n\n提示：\n\n1 &lt;= s.length &lt;= 105\ns[i] 都是 ASCII 码表中的可打印字符\n\n题目来源：https://leetcode.cn/problems/reverse-string/\n题解：class Solution &#123;\n    public void reverseString(char[] s) &#123;\n        int left&#x3D;0;\n        int right&#x3D;s.length-1;\n        while(left&lt;right)&#123;\n            swap(s,left,right);\n            left++;\n            right--;\n        &#125;\n    &#125;\n\n    public void swap(char[] s,int left,int right)&#123;\n        char temp&#x3D;s[left];\n        s[left]&#x3D;s[right];\n        s[right]&#x3D;temp;\n    &#125;\n&#125;\n\n\n\n","slug":"344-反转字符串","date":"2022-09-02T13:55:52.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,字符串","author_index":"LiuQuanZe"},{"id":"6402807c619d1044cedb6c34299402ec","title":"15.三数之和","content":"15.三数之和题目描述：\n三数之和\n\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\nexample 1:\n输入：nums &#x3D; [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。\nnums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。\nnums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n\nexample 2:\n输入：nums &#x3D; [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。\n\nexample 3:\n输入：nums &#x3D; [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。\n\n提示：\n\n3 &lt;= nums.length &lt;= 3000\n-105 &lt;= nums[i] &lt;= 105\n\n题目来源：https://leetcode.cn/problems/3sum\n题解：class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();\n        &#x2F;&#x2F;对数组进行排序\n        Arrays.sort(nums);\n\n        \n        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n            &#x2F;&#x2F;因为已经排序了，如果第i个元素大于0，则之后的元素均大于0， 不能满足和为0，直接退出\n            if (nums[i] &gt; 0) &#123;\n                return result;\n            &#125;\n\n            &#x2F;&#x2F;去重，如果i和i-1的元素相同，则遍历下一个\n            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;\n                continue;\n            &#125;\n\n            &#x2F;&#x2F;left初始指向i+1，right指向数组末尾\n            int left &#x3D; i + 1;\n            int right &#x3D; nums.length - 1;\n            &#x2F;&#x2F;寻找满足条件的三个数\n            while (right &gt; left) &#123;\n                &#x2F;&#x2F;获取三个指针指向的值\n                int sum &#x3D; nums[i] + nums[left] + nums[right];\n                &#x2F;&#x2F;如果sum大于0，表示和太大，right指针左移，将和减小\n                if (sum &gt; 0) &#123;\n                    right--;\n                    &#x2F;&#x2F;若sum小于0，则表示太小，left右移，扩大sum\n                &#125; else if (sum &lt; 0) &#123;\n                    left++;\n                    &#x2F;&#x2F;当sum&#x3D;&#x3D;0，则表示满足条件\n                &#125; else &#123;\n                    &#x2F;&#x2F;将该组合加入结果集合\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                    &#x2F;&#x2F;寻找下一组满足条件的和，但是需要去重\n                    while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;\n                    while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;\n                    \n                    right--; \n                    left++;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n","slug":"15-三数之和","date":"2022-08-31T01:40:26.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"d39f1cd0e2f648b0b919de3afe262477","title":"454.四数相加Ⅱ","content":"454.四数相加Ⅱ题目描述：\n四数相加 II\n\n给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：\n\n0 &lt;= i, j, k, l &lt; n\nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\n\nexample 1：\n输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]\n输出：2\n解释：\n两个元组如下：\n1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0\n2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0\n\nexample 2:\n输入：nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]\n输出：1\n\n提示：\nn &#x3D;&#x3D; nums1.lengthn &#x3D;&#x3D; nums2.lengthn &#x3D;&#x3D; nums3.lengthn &#x3D;&#x3D; nums4.length1 &lt;&#x3D; n &lt;&#x3D; 200-228 &lt;&#x3D; nums1[i], nums2[i], nums3[i], nums4[i] &lt;&#x3D; 228\n题目来源：https://leetcode.cn/problems/4sum-ii\n题解：class Solution &#123;\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123;\n        HashMap&lt;Integer,Integer&gt; hashMap&#x3D;new HashMap&lt;&gt;();\n        &#x2F;&#x2F;记录可以满足四数相加为0的组合的个数\n        int res&#x3D;0;\n        &#x2F;&#x2F;遍历nums1和nums2元素相加之和，存入map中，key为两数之和，value是key两数之和出现的次数\n        for(int num1:nums1)&#123;\n            for(int num2:nums2)&#123;\n                int temp&#x3D;num1+num2;\n                if(hashMap.containsKey(temp))&#123;\n                    hashMap.put(temp,hashMap.get(temp)+1);\n                &#125;else&#123;\n                    hashMap.put(temp,1);\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;遍历nums3和nums4元素相加之和，检查map中是否存在0-两数之和，如果存在，则表示存在一组满足条件的解，并将res加上map中的value，表示\n        &#x2F;&#x2F;存在多个解\n        for(int num3:nums3)&#123;\n            for(int num4:nums4)&#123;\n                int temp&#x3D;num3+num4;\n                if(hashMap.containsKey(0-temp))&#123;\n                    res+&#x3D;hashMap.get(0-temp);\n                &#125;\n            &#125;\n        &#125;\n        return res;\n\n    &#125;\n&#125;\n\n","slug":"454-四数相加Ⅱ","date":"2022-08-31T01:01:44.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,哈希表","author_index":"LiuQuanZe"},{"id":"b036e493bdd6ef884e6984b888ff5e94","title":"202.快乐数","content":"202.快乐数题目描述：\n快乐数\n\n编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」 定义为：\n\n对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\n如果这个过程 结果为 1，那么这个数就是快乐数。\n\n如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\nexample 1：\n输入：n &#x3D; 19\n输出：true\n解释：\n12 + 92 &#x3D; 82\n82 + 22 &#x3D; 68\n62 + 82 &#x3D; 100\n12 + 02 + 02 &#x3D; 1\n\nexample 2:\n输入：n &#x3D; 2\n输出：false\n\n提示：\n\n1 &lt;= n &lt;= 231 - 1\n\n题目来源：https://leetcode.cn/problems/happy-number/\n题解：class Solution &#123;\n    public boolean isHappy(int n) &#123;\n        &#x2F;&#x2F;存储替换过的数字，因为题目说了可能会出现无限循环的情况，会重复出现某个数字，比如\n        &#x2F;&#x2F;2，4，16，37，58，89，145，42，20，2\n        HashSet&lt;Integer&gt; set&#x3D;new HashSet&lt;Integer&gt;();\n        while(n!&#x3D;1&amp;&amp;!set.contains(n))&#123;\n            set.add(n);\n            n&#x3D;getNextNumber(n);\n        &#125;\n        return n&#x3D;&#x3D;1;\n    &#125;\n    &#x2F;&#x2F;计算下一个数字\n    public int getNextNumber(int n)&#123;\n        int res&#x3D;0;\n        while(n&gt;0)&#123;\n            int temp&#x3D;n%10;\n            res+&#x3D;temp*temp;\n            n&#x3D;n&#x2F;10;\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n","slug":"202-快乐数","date":"2022-08-29T13:03:42.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,哈希表","author_index":"LiuQuanZe"},{"id":"c18601503540d5650db70b6721599b9d","title":"349.两个数组的交集","content":"349.两个数组的交集题目描述：\n两个数组的交集\n\n给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\nexample 1:\n输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]\n输出：[2]\n\nexample 2:\n输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]\n输出：[9,4]\n解释：[4,9] 也是可通过的\n\n提示：\n\n1 &lt;= nums1.length, nums2.length &lt;= 1000\n0 &lt;= nums1[i], nums2[i] &lt;= 1000\n\n题目来源：https://leetcode.cn/problems/intersection-of-two-arrays/\n题解：class Solution &#123;\n    public int[] intersection(int[] nums1, int[] nums2) &#123;\n        if (nums1 &#x3D;&#x3D; null || nums1.length &#x3D;&#x3D; 0 || nums2 &#x3D;&#x3D; null || nums2.length &#x3D;&#x3D; 0) &#123;\n            return new int[0];\n        &#125;\n        &#x2F;&#x2F;存储数组元素\n        Set&lt;Integer&gt; set1 &#x3D; new HashSet&lt;&gt;();\n        &#x2F;&#x2F;存储结果\n        Set&lt;Integer&gt; resSet &#x3D; new HashSet&lt;&gt;();\n        &#x2F;&#x2F;遍历数组1\n        for (int i : nums1) &#123;\n            set1.add(i);\n        &#125;\n        &#x2F;&#x2F;遍历数组2的过程中判断哈希表中是否存在该元素，若存在，则存入resSet中，因为输出结果是唯一的，因此并集的结果使用set集合来存储\n        for (int i : nums2) &#123;\n            if (set1.contains(i)) &#123;\n                resSet.add(i);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;将结果集合转为数组\n        return resSet.stream().mapToInt(x -&gt; x).toArray();\n    &#125;\n&#125;\n\n","slug":"349-两个数组的交集","date":"2022-08-29T12:47:57.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,哈希表","author_index":"LiuQuanZe"},{"id":"4b837d23486a4c7408641cab9ca86e52","title":"242.有效的字母异位词","content":"242.有效的字母异位词题目描述：\n有效的字母异位词\n\n给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。\n注意：若 *s* 和 *t* 中每个字符出现的次数都相同，则称 *s* 和 *t* 互为字母异位词。\nexample 1：\n输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;\n输出: true\n\nexample 2:\n输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;\n输出: false\n\n提示：\n\n1 &lt;= s.length, t.length &lt;= 5 * 104\ns 和 t 仅包含小写字母\n\n题目来源：https://leetcode.cn/problems/valid-anagram/\n题解：&#x2F;*\n定义一个数组，来记录字符串s里字符出现的次数。\n需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。\n\n再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了。\n\n那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。\n\n那么最后检查一下，record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。\n\n最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。\n\n时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。\n*&#x2F;\nclass Solution &#123;\n    public boolean isAnagram(String s, String t) &#123;\n\n        int[] record &#x3D; new int[26];\n        for (char c : s.toCharArray()) &#123;\n            record[c - &#39;a&#39;] +&#x3D; 1;\n        &#125;\n        for (char c : t.toCharArray()) &#123;\n            record[c - &#39;a&#39;] -&#x3D; 1;\n        &#125;\n        for (int i : record) &#123;\n            if (i !&#x3D; 0) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n\n","slug":"242-有效的字母异位词","date":"2022-08-28T13:00:21.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,哈希表","author_index":"LiuQuanZe"},{"id":"3775c9e904a11de6ad41f14528d2779f","title":"142.环形链表Ⅱ","content":"142.环形链表Ⅱ题目描述：\n环形链表 II\n\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\nexample 1：\n输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\nexample 2:\n输入：head &#x3D; [1,2], pos &#x3D; 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n\nexample 3:\n输入：head &#x3D; [1], pos &#x3D; -1\n输出：返回 null\n解释：链表中没有环。\n\n提示：\n\n链表中节点的数目范围在范围 [0, 104] 内\n-105 &lt;= Node.val &lt;= 105\npos 的值为 -1 或者链表中的一个有效索引\n\n题目来源：https://leetcode.cn/problems/linked-list-cycle-ii/submissions/\n题解：&#x2F;*\n判断是否有环：可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。\n此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。\n首先判断是否有环，如果有环，则记录相遇节点，然后下一步寻找环的入口节点：从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。\n*&#x2F;\n&#x2F;**\n * Definition for singly-linked list.\n * class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123;\n *         val &#x3D; x;\n *         next &#x3D; null;\n *     &#125;\n * &#125;\n *&#x2F;\npublic class Solution &#123;\n    public ListNode detectCycle(ListNode head) &#123;\n        ListNode slow &#x3D; head;\n        ListNode fast &#x3D; head;\n        while (fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null) &#123;\n            slow &#x3D; slow.next;\n            fast &#x3D; fast.next.next;\n            if (slow &#x3D;&#x3D; fast) &#123;&#x2F;&#x2F; 有环\n                ListNode index1 &#x3D; fast;\n                ListNode index2 &#x3D; head;\n                &#x2F;&#x2F; 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口\n                while (index1 !&#x3D; index2) &#123;\n                    index1 &#x3D; index1.next;\n                    index2 &#x3D; index2.next;\n                &#125;\n                return index1;\n            &#125;\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n","slug":"142-环形链表Ⅱ","date":"2022-08-27T12:12:23.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,链表","author_index":"LiuQuanZe"},{"id":"997023f756e83c602ad393bfa331d66a","title":"24.两两交换链表中的节点","content":"24.两两交换链表中的节点题目描述：\n两两交换链表中的节点\n\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\nexample1:\n输入：head &#x3D; [1,2,3,4]\n输出：[2,1,4,3]\n\nexample 2:\n输入：head &#x3D; []\n输出：[]\n\nexample 3:\n输入：head &#x3D; [1]\n输出：[1]\n\n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 &lt;= Node.val &lt;= 100\n\n题目来源：https://leetcode.cn/problems/swap-nodes-in-pairs/\n题解：https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E6%80%9D%E8%B7%AF\n题解：&#x2F;**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val &#x3D; val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public ListNode swapPairs(ListNode head) &#123;\n        ListNode head_node&#x3D;new ListNode();\n        head_node.next&#x3D;head;\n        &#x2F;&#x2F;活动指针，指向的是当前需要交换的节点的前一个节点，方便交换，这里之所以采用虚拟头节点，是为了统一化处理\n        ListNode p&#x3D;head_node;\n        while(p.next!&#x3D;null&amp;&amp;p.next.next!&#x3D;null)&#123;\n            &#x2F;&#x2F;指向需要交换的第一个节点\n            ListNode temp&#x3D;p.next;\n            &#x2F;&#x2F;指向需要交换的第二个节点\n            ListNode temp_next&#x3D;p.next.next;\n            &#x2F;&#x2F;首先将p指向第二个节点\n            p.next&#x3D;temp_next;\n            &#x2F;&#x2F;第一个节点指向第二个节点原本指向的后续链表\n            temp.next&#x3D;temp_next.next;\n            &#x2F;&#x2F;第二个节点指向一个节点\n            temp_next.next&#x3D;temp;\n            &#x2F;&#x2F;将活动节点后移，指向下一对需要交换的节点的前一个节点，\n            p&#x3D;p.next.next;\n\n        &#125;\n        &#x2F;&#x2F;返回调整后的链表\n        return head_node.next;\n    &#125;\n&#125;\n\n\n\n","slug":"24-两两交换链表中的节点","date":"2022-08-24T14:35:56.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,链表","author_index":"LiuQuanZe"},{"id":"04d169a11d3cee4253a53c23de1dbd14","title":"206.反转链表","content":"206.反转链表题目描述：\n反转链表\n\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\nexample 1:\n输入：head &#x3D; [1,2,3,4,5]\n输出：[5,4,3,2,1]\n\nexample 2:\n输入：head &#x3D; [1,2]\n输出：[2,1]\n\nexample 3:\n输入：head &#x3D; []\n输出：[]\n\n提示：\n\n链表中节点的数目范围是 [0, 5000]\n-5000 &lt;= Node.val &lt;= 5000\n\n题目来源：https://leetcode.cn/problems/reverse-linked-list/\n题解：&#x2F;**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val &#x3D; val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode head_node&#x3D;new ListNode();\n        ListNode p&#x3D;head;\n        while(p!&#x3D;null)&#123;\n            ListNode q&#x3D;p.next;\n            p.next&#x3D;head_node.next;\n            head_node.next&#x3D;p;\n            p&#x3D;q;\n        &#125;\n        return head_node.next;\n    &#125;\n&#125;\n\n","slug":"206-反转链表","date":"2022-08-23T13:56:14.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,链表","author_index":"LiuQuanZe"},{"id":"aa4d739c1ac4e9cbdf52b62c4e456ed6","title":"Python语法错误01","content":"Python语法错误01#出现语法错误一般是python版本问题，解决方案一般是两种\n&quot;&quot;&quot;\n1.修改python版本\n2.修改代码语法\n&quot;&quot;&quot;\n\n1.except Exception, e: 语法无效except Exception e:#python2支持，3版本不支持\n#修改为3版本语法\nexcept Exception as e:\n\n2.TypeError: a bytes-link object is requeired, not ‘str’\n需要的是byte类型的对象，而非str类型\n\n#解决方案：将字符串类型转为字节类型\n&quot;&quot;&quot;\n假设s为一个str类型的变量\n&#x3D;&gt;type(s)\n&lt;class &#39;str&#39;&gt;\n存在以下三种常见的类型转换公式\n1.b1&#x3D;bytes(s.encoding&#x3D;&#39;utf-8&#39;)\n2.b2&#x3D;str.encoding(s)\n3.b3&#x3D;s.encode(encoding&#x3D;&#39;utf&#x3D;8&#39;)\n\n&quot;&quot;&quot;\n\n\n\n","slug":"Python语法错误01","date":"2022-08-23T07:42:40.000Z","categories_index":"实验","tags_index":"Python,语法错误","author_index":"LiuQuanZe"},{"id":"e036cd89658c33624bfd31dd2060c058","title":"203.移除链表元素","content":"203.移除链表元素题目描述：\n移除链表元素\n\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 \nexample 1:\n输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6\n输出：[1,2,3,4,5]\n\nexample 2:\n输入：head &#x3D; [], val &#x3D; 1\n输出：[]\n\nexample 3:\n输入：head &#x3D; [7,7,7,7], val &#x3D; 7\n输出：[]\n\n提示：\n\n列表中的节点数目在范围 [0, 104] 内\n1 &lt;= Node.val &lt;= 50\n0 &lt;= val &lt;= 50\n\n题目来源：\nhttps://leetcode.cn/problems/remove-linked-list-elements/\n题解：&#x2F;**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val &#x3D; val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public ListNode removeElements(ListNode head, int val) &#123;\n        if(head&#x3D;&#x3D;null)&#123;\n            return null;\n        &#125;\n        &#x2F;&#x2F;创建一个虚拟头节点，目的是为了统一头结点的处理操作\n        ListNode fake_head&#x3D;new ListNode(-1,head);\n        &#x2F;&#x2F;左指针\n        ListNode pre&#x3D;fake_head;\n        &#x2F;&#x2F;右指针\n        ListNode sec&#x3D;head;\n        while(sec!&#x3D;null)&#123;\n            &#x2F;&#x2F;若当前右指针元素需要移除\n            if(sec.val&#x3D;&#x3D;val)&#123;\n                &#x2F;&#x2F;丢弃该元素,并将右指针向后移动一位\n                pre.next&#x3D;sec.next;\n                sec&#x3D;sec.next;\n            &#125;else&#123;\n                &#x2F;&#x2F;若该元素无须移除，则左右指针均向后移动一位\n                pre&#x3D;pre.next;\n                sec&#x3D;sec.next;\n            &#125;\n\n        &#125;\n        return fake_head.next;\n    &#125;\n&#125;\n\n","slug":"203-移除链表元素","date":"2022-08-20T01:35:04.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode,链表","author_index":"LiuQuanZe"},{"id":"be7f5c6dc71f9de739df383de800893c","title":"416.分割等和子集","content":"416.分割等和子集题目描述：\n分割等和子集\n\n给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\nexample 1:\n输入：nums &#x3D; [1,5,11,5]\n输出：true\n解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n\nexample 2:\n输入：nums &#x3D; [1,2,3,5]\n输出：false\n解释：数组不能分割成两个元素和相等的子集。\n\n提示：\n\n1 &lt;= nums.length &lt;= 200\n1 &lt;= nums[i] &lt;= 100\n\n题目来源：https://leetcode.cn/problems/partition-equal-subset-sum/\n题解：&#x2F;&#x2F;滚动数组，一维的dp数组\nclass Solution &#123;\n    public boolean canPartition(int[] nums) &#123;\n        if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;\n            return false;\n        &#125;\n        int sum&#x3D;0;\n        for(int num:nums)&#123;\n            sum+&#x3D;num;\n        &#125;\n        &#x2F;&#x2F;是奇数，必无法分割成两个等和的子数组\n        if(sum%2&#x3D;&#x3D;1)&#123;\n            return false;\n        &#125;\n        &#x2F;&#x2F;背包大小即为和\n        &#x2F;&#x2F;物品重量为nums[i],物品价值为nums[i]\n        int target&#x3D;sum&#x2F;2;\n        int[] dp&#x3D;new int[target+1];\n        for(int i&#x3D;nums[0];i&lt;&#x3D;target;i++)&#123;\n            dp[i]&#x3D;nums[0];\n        &#125;\n        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;\n            for(int j&#x3D;target;j&gt;&#x3D;nums[i];j--)&#123;\n                &#x2F;&#x2F;为了防止覆盖问题，背包容量从后往前遍历\n                dp[j]&#x3D;Math.max(dp[j],dp[j-nums[i]]+nums[i]);\n            &#125;\n        &#125;\n        return dp[target]&#x3D;&#x3D;target;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;01背包，二维dp数组\nclass Solution &#123;\n    public boolean canPartition(int[] nums) &#123;\n        if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;\n            return false;\n        &#125;\n        int sum&#x3D;0;\n        for(int num:nums)&#123;\n            sum+&#x3D;num;\n        &#125;\n        if(sum%2&#x3D;&#x3D;1)&#123;\n            return false;\n        &#125;\n        int target&#x3D;sum&#x2F;2;\n        int[][] dp&#x3D;new int[nums.length][target+1];\n        &#x2F;&#x2F;dp数组初始化\n        for(int i&#x3D;nums[0];i&lt;&#x3D;target;i++)&#123;\n            dp[0][i]&#x3D;nums[0];\n        &#125;\n        &#x2F;&#x2F;遍历物品从第一个开始，因为初始化的时候第0个已经遍历过了\n        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;target;j++)&#123;\n                if(j&lt;nums[i])&#123;\n                    dp[i][j]&#x3D;dp[i-1][j];\n                &#125;else&#123;\n                    dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[nums.length-1][target]&#x3D;&#x3D;target;\n    &#125;\n&#125;\n\n","slug":"416-分割等和子集","date":"2022-08-20T01:04:47.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"fb852bf52649b6773513d798310ccbeb","title":"59.螺旋矩阵Ⅱ","content":"59.螺旋矩阵Ⅱ题目描述：\n螺旋矩阵 II\n\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\nexample 1:\n输入：n &#x3D; 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]\n\nexample 2:\n输入：n &#x3D; 1\n输出：[[1]]\n\n提示：\n\n1 &lt;= n &lt;= 20\n\n题目来源：\nhttps://leetcode.cn/problems/spiral-matrix-ii/\n题解：class Solution &#123;\n    public int[][] generateMatrix(int n) &#123;\n        int[][] ret&#x3D;new int[n][n];\n        int offset&#x3D;1;   &#x2F;&#x2F;每轮循环需要偏移的量，比如第一轮是要预留一个位置，offset&#x3D;1\n        int loop&#x3D;n&#x2F;2;   &#x2F;&#x2F;需要进行的圈数，比如n&#x3D;3只需要循环一次，n&#x3D;6需要循环3次\n        int mid&#x3D;n&#x2F;2;    &#x2F;&#x2F;矩阵的中心位置，比如n&#x3D;3，中心位置是(1,1)\n        int count&#x3D;1;    &#x2F;&#x2F;用于给各个位置赋值\n        int i&#x3D;0;\n        int j&#x3D;0;\n        int startx&#x3D;0;\n        int starty&#x3D;0;       &#x2F;&#x2F;用于记录每一圈的开始位置\n        for(;loop&gt;0;loop--)&#123;\n            i&#x3D;startx;\n            j&#x3D;starty;\n            &#x2F;&#x2F;从左向右移动，j小于n-offset，预留一个位置给后面            \n            for(;j&lt;n-offset;j++)&#123;\n                ret[i][j]&#x3D;count++;\n            &#125;\n            &#x2F;&#x2F;从上向下移动，预留一个位置给后面\n            for(;i&lt;n-offset;i++)&#123;\n                ret[i][j]&#x3D;count++;\n            &#125;\n            &#x2F;&#x2F;从右向左移动，预留一个位置给后面，注意这里j不是大于0，而是大于starty，因为每一圈的开始位置是在改变的，只有第一圈才是0\n            for(;j&gt;starty;j--)&#123;\n                ret[i][j]&#x3D;count++;\n            &#125;\n            &#x2F;&#x2F;从下向上移动，预留一个位置给后面，注意这里i不是大于0，而是大于startx，因为每一圈的开始位置是在移动的，只有第一圈才是0\n            for(;i&gt;startx;i--)&#123;\n                ret[i][j]&#x3D;count++;\n            &#125;\n            &#x2F;&#x2F;更新便宜量，因为每一圈是在不断缩小的，所以边界是在变化的，所以偏移量也在变化\n            offset++;\n            &#x2F;&#x2F;更新下一圈的开始位置\n            startx++;\n            starty++;\n\n\n        &#125;\n        &#x2F;&#x2F;若n为奇数，则中心会有一个多出的元素，需要进行赋值，其实就是最后一个元素n^2\n        if(n%2&#x3D;&#x3D;1)&#123;\n            ret[mid][mid]&#x3D;n*n;\n        &#125;\n        return ret;\n    &#125;\n&#125;\n\n","slug":"59-螺旋矩阵Ⅱ","date":"2022-08-19T12:59:09.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"3e8eaaf0906092af7ecd3983c1cdcff1","title":"209.长度最小的子数组","content":"209.长度最小的子数组题目描述：\n长度最小的子数组\n\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\nexample 1:\n输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\nexample 2:\n输入：target &#x3D; 4, nums &#x3D; [1,4,4]\n输出：1\n\nexample 3:\n输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]\n输出：0\n\n\n\n提示：\n\n1 &lt;= target &lt;= 109\n1 &lt;= nums.length &lt;= 105\n1 &lt;= nums[i] &lt;= 105\n\n题目来源：\nhttps://leetcode.cn/problems/minimum-size-subarray-sum/\n题解：class Solution &#123;\n    public int minSubArrayLen(int target, int[] nums) &#123;\n        &#x2F;&#x2F;滑动窗口\n        &#x2F;*\n        基本思想：\n            1.定义两个指针，初始值均为数组左边界\n            2.定义变量记录两个指针区域之间子序列的和，再定义一个变量记录当前满足条件的最小子序列长度，初始值为无穷大\n            3.不断右移右指针，并计算子区域元素之和，当子区域和满足条件时记录当前子区域长度并更新最小子区域长度，随后将左指针右移，若依旧满足条件则继续更新最小子区域长度，直到子区域之和不满足条件，之后重新开始右移右指针\n        *&#x2F;\n        &#x2F;&#x2F;判断参数是否合法\n        if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;初始化指针，j为右指针，i为左指针\n        int i&#x3D;0;\n        int j&#x3D;0;\n        &#x2F;&#x2F;sum表示i~j子序列之和\n        int sum&#x3D;0;\n        &#x2F;&#x2F;ret记录当前的最小子序列\n        int ret&#x3D;Integer.MAX_VALUE;\n        &#x2F;&#x2F;当遍历子序列之和没有超过target，则将j右移\n        while(j&lt;nums.length)&#123;\n            sum+&#x3D;nums[j];\n            &#x2F;&#x2F;若子序列之和满足条件，则计算子序列长度，并判断是否更新ret，并将左边界右移，更新子序列之和，循环右移并更新子序列长度。\n            while(sum&gt;&#x3D;target)&#123;\n                int sub_length&#x3D;j-i+1;\n                ret&#x3D;ret&gt;sub_length? sub_length:ret;\n                sum-&#x3D;nums[i++]; \n            &#125;\n            j++;\n        &#125;\n        &#x2F;&#x2F;若ret的值发生改变，则返回，否则返回0，表示没有满足条件的解\n        return ret&#x3D;&#x3D;Integer.MAX_VALUE? 0:ret;\n    &#125;\n&#125;\n\n","slug":"209-长度最小的子数组","date":"2022-08-19T12:21:28.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"34cb425e734202379d2ace9dc721620a","title":"ERROR 2003 (HY000) Can't connect to MySQL server on 'localhost:3306' (10061)","content":"ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost:3306’ (10061)问题描述：mysql -uroot -p\n\n\n输入上传命令之后，出现标题上的错误。\n数据库无法成功连接\n\n解决方案：\n打开win搜索栏，输入“计算机管理”\n选择服务\n找到mysql，并启动即可\n\n","slug":"连接mysql失败","date":"2022-08-18T04:11:34.000Z","categories_index":"后端开发","tags_index":"报错,MySQL","author_index":"LiuQuanZe"},{"id":"15073fb27fca9b3ab97a6db7836c4a4d","title":"977.有序数组的平方","content":"977.有序数组的平方题目描述：\n有序数组的平方\n\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\nexample 1:\n输入：nums &#x3D; [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]\n\nexample 2:\n输入：nums &#x3D; [-7,-3,2,3,11]\n输出：[4,9,9,49,121]\n\n提示：\n\n1 &lt;= nums.length &lt;= 104\n-104 &lt;= nums[i] &lt;= 104\nnums 已按 非递减顺序 排序\n\n题目来源：https://leetcode.cn/problems/squares-of-a-sorted-array\n题解：&#x2F;&#x2F;先计算平方，然后排序，时间复杂度O(nlogn)\nclass Solution &#123;\n    public int[] sortedSquares(int[] nums) &#123;\n        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;\n            nums[i]*&#x3D;nums[i];\n        &#125;\n        Arrays.sort(nums);\n        return nums;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;使用双指针，一个i从头开始，一个j从尾巴开始，分别计算平方，比较大小，放入一个新的数组，新数组的指针为k，从尾部开始\nclass Solution &#123;\n    public int[] sortedSquares(int[] nums) &#123;\n        int[] ret&#x3D;new int[nums.length];\n\n        for(int i&#x3D;0,j&#x3D;nums.length-1,k&#x3D;ret.length-1;i&lt;&#x3D;j;)&#123;\n            if(nums[i]*nums[i]&gt;&#x3D;nums[j]*nums[j])&#123;\n                ret[k--]&#x3D;nums[i]*nums[i];\n                i++;\n            &#125;else&#123;\n                ret[k--]&#x3D;nums[j]*nums[j];\n                j--;\n            &#125;\n        &#125;\n        return ret;\n    &#125;\n&#125;\n\n","slug":"977-有序数组的平方","date":"2022-08-17T22:41:02.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"dcd5a30d05960c310201068cc050e1d7","title":"01 bag","content":"01背包问题题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。\n这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？\n每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。\n所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！\n题解：public class bag01 &#123;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;物品重量\n        int[] weight &#x3D; &#123;1, 3, 4&#125;;\n        &#x2F;&#x2F;物品价值\n        int[] value &#x3D; &#123;15, 20, 30&#125;;\n        &#x2F;&#x2F;背包大小\n        int bagsize &#x3D; 4;\n        testweightbagproblem(weight, value, bagsize);\n    &#125;\n\n    public static void testweightbagproblem(int[] weight, int[] value, int bagsize)&#123;\n        &#x2F;&#x2F;创建dp数组\n        int[][] dp&#x3D;new int[weight.length][bagsize+1];\n        &#x2F;&#x2F;对dp数组进行初始化\n        &#x2F;*\n        * 对dp数组的第一行进行初始化，dp[i][j]表示的是容量为j的背包，前i个物品能获得的最大价值\n        * 第一行是指将第0个物品放入不同的容量0~bagsize的背包的最大价值，其实也就是看第0个物品可不可以放入背包中，如果可以则将dp[0][j]设置为value[0]即可\n        * ，若j&lt;weight[0]则表示第0个物品放不进容量为j的背包，则容量为j的背包的价值只能是0，所以下方的j从weight[0]开始遍历，因为j&lt;weight[0]时，dp[0][j]&#x3D;0\n        * *&#x2F;\n        for(int j&#x3D;weight[0];j&lt;&#x3D;bagsize;j++)&#123;\n            dp[0][j]&#x3D;value[0];\n        &#125;\n\n        &#x2F;&#x2F;状态转换公式\n        &#x2F;*\n        * 先遍历物品i&#x3D;1;i&lt;&#x3D;weight.length，再遍历背包容量j&#x3D;1;j&lt;&#x3D;bagsize\n        * 1.当背包容量小于当前的物品的重量j&lt;weight[i]时,表示物品i无法放进此时容量为j的背包，所以dp[i][j]：容量为j的背包在i个物品中所能获得的最大价值等于容量为j的背包\n        * 在i-1个物品中所能获得的最大价值；也就是不放入第i个物品的最大价值（因为背包容量不够嘛）\n        * 2.当背包容量大于等于当前物品的重量j&gt;&#x3D;weight[i]时，表示物品可以放进此时容量为j的背包，因此出现两种选择：\n        *   （1）将物品i放进背包\n        *   （2）不将物品i放进背包，\n        * 至于选择放还是不放，就需要分别计算放入物品i和不放入物品i的背包的价值并选择能使背包价值最大化的方式（通俗的说，放入i和不放入i，谁能使背包的价值大，就选谁）\n        * 所以dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i]+value[i]])\n        * 注：这里的dp[i-1][j-weight[i]表示的是容量为j-weight[j]的背包在0~i-1所能获得最大价值，之所以j-weight[j]就是要预留出物品i的空间，所以p[i-1][j-weight[i]也可以说是为物品i\n        * 预留出背包空间后的最大可以获得的价值，再然后加上value[i]就可以得到放入物品i后，容量为j的背包所能获得的最大价值。\n        *\n        * 重新梳理：\n        * （1）如果物品i可以放入背包（背包容量允许），则分别比较物品放入前后的背包价值，选取最大值\n        * （2）若物品i不可以放入背包（背包容量不允许），则选择不放入i时的最大价值。\n        * *&#x2F;\n        for(int i&#x3D;1;i&lt;weight.length;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;bagsize;j++)&#123;\n                if(j&lt;weight[i-1])&#123;\n                    dp[i][j]&#x3D;dp[i-1][j];\n                &#125;else&#123;\n                    dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i-1]]+value[i-1]);\n                &#125;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;输出dp数组查看运行结果\n        for (int i&#x3D;0;i&lt;weight.length;i++)&#123;\n            for(int j&#x3D;0;j&lt;&#x3D;bagsize;j++)&#123;\n                System.out.printf(dp[i][j]+&quot; &quot;);\n            &#125;\n            System.out.printf(&quot;\\n&quot;);\n        &#125;\n\n\n    &#125;\n&#125;\n\n\n","slug":"01-bag","date":"2022-08-17T03:09:15.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划","author_index":"LiuQuanZe"},{"id":"eea51d59bc355db9bbe09ae2654e00b2","title":"96.不同的二叉搜索树","content":"96.不同的二叉搜索树题目描述：\n不同的二叉搜索树\n\n给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。\nexample 1:\n输入：n &#x3D; 3\n输出：5\n\nexample 2:\n输入：n &#x3D; 1\n输出：1\n\n\n\n提示：\n\n1 &lt;= n &lt;= 19\n\n题目来源：https://leetcode.cn/problems/unique-binary-search-trees/\n题解：class Solution &#123;\n    public int numTrees(int n) &#123;\n        &#x2F;&#x2F;定义dp数组\n        int[] dp&#x3D;new int[n+1];\n        &#x2F;&#x2F;dp的初始值：当有0个节点时，看作一个空的二叉树，dp[0]&#x3D;1；当有一个节点时，dp[1]&#x3D;1;\n        dp[0]&#x3D;1;\n        dp[1]&#x3D;1;\n        &#x2F;&#x2F;状态公式：dp[i]+&#x3D;dp[j-1]*dp[i-j];\n        &#x2F;&#x2F;j表示当前二叉搜索树的头节点，dp[j-1]和dp[i-j]分别表示其左右子树的二叉搜索树个数\n        &#x2F;&#x2F;详情见https:&#x2F;&#x2F;gitee.com&#x2F;programmercarl&#x2F;leetcode-master&#x2F;blob&#x2F;master&#x2F;problems&#x2F;0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md\n        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;i;j++)&#123;\n                dp[i]+&#x3D;dp[j-1]*dp[i-j];\n            &#125;\n        &#125;\n        return dp[n];\n\n\n    &#125;\n&#125;\n\n","slug":"96-不同的二叉搜索树","date":"2022-08-16T03:04:40.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"6d961b2ba2212b262ffda24ad1b8896a","title":"343.整数拆分","content":"343.整数拆分题目描述：\n整数拆分\n\n给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。\n返回 你可以获得的最大乘积 。\nexample 1:\n输入: n &#x3D; 2\n输出: 1\n解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。\n\nexample 2:\n输入: n &#x3D; 10\n输出: 36\n解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。\n\n提示：\n\n2 &lt;= n &lt;= 58\n\n题目来源：https://leetcode.cn/problems/integer-break/\n题解:class Solution &#123;\n    public int integerBreak(int n) &#123;\n        &#x2F;&#x2F;参数是否合法，当n&#x3D;0 or 1的时候无法进行拆分\n        if(n&#x3D;&#x3D;0||n&#x3D;&#x3D;1)&#123;\n           return 0;\n        &#125;\n        &#x2F;&#x2F;定义dp数组，dp[i]表示的是给定i时可以获得的最大化乘积\n        int[] dp&#x3D;new int[n+1];\n        &#x2F;&#x2F;dp数组初始化，直接从dp[2]开始初始化，因为i&#x3D;1和0是没有意义的\n        dp[2]&#x3D;1;\n        &#x2F;&#x2F;对dp数组进行遍历，确定状态转换公式：\n        &#x2F;*\n            dp[i]可以通过两个公式得到，其中j从1到i-1\n                1.j*(i-j)\n                2.j*dp[i-j]\n                j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。\n                如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。\n                所以递推公式：dp[i] &#x3D; max(&#123;dp[i], (i - j) * j, dp[i - j] * j&#125;);\n            那么在取最大值的时候，为什么还要比较dp[i]呢？\n                因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。\n        *&#x2F;\n        for(int i&#x3D;3;i&lt;&#x3D;n;i++)&#123;\n            for(int j&#x3D;1;j&lt;i-1;j++)&#123;\n                dp[i]&#x3D;Math.max(dp[i],Math.max((j*(i-j)),j*dp[i-j]));\n            &#125;\n        &#125;\n        return dp[n];\n\n\n\n    &#125;\n&#125;\n\n","slug":"343-整数拆分","date":"2022-08-15T02:23:02.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"4c356b6b38bff815cbd4488ea4093633","title":"63.不同路径Ⅱ","content":"63.不同路径Ⅱ题目描述：\n不同路径 II\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n网格中的障碍物和空位置分别用 1 和 0 来表示。\nexample 1:\n输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]\n输出：2\n解释：3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右\n\nexample 2:\n输入：obstacleGrid &#x3D; [[0,1],[0,0]]\n输出：1\n\n提示：\nm &#x3D;&#x3D; obstacleGrid.lengthn &#x3D;&#x3D; obstacleGrid[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 100obstacleGrid[i][j] 为 0 或 1\n题目来源：https://leetcode.cn/problems/unique-paths-ii\n题解：class Solution &#123;\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;\n        if(obstacleGrid&#x3D;&#x3D;null||obstacleGrid.length&#x3D;&#x3D;0||obstacleGrid[0].length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        int m&#x3D;obstacleGrid.length;\n        int n&#x3D;obstacleGrid[0].length;\n        &#x2F;&#x2F;定义dp数组，dp[i][j]表示从(0,0)出发到达（i，j）所包含的路线数\n        int[][] dp&#x3D;new int[m][n];\n        &#x2F;&#x2F;对dp数组进行初始化，注意，dp[i][0]和dp[0][j]为1，若遇到障碍，则为0。\n        for(int i&#x3D;0;i&lt;m&amp;&amp;obstacleGrid[i][0]&#x3D;&#x3D;0;i++)&#123;\n            dp[i][0]&#x3D;1;\n        &#125;\n        for(int j&#x3D;0;j&lt;n&amp;&amp;obstacleGrid[0][j]&#x3D;&#x3D;0;j++)&#123;\n            dp[0][j]&#x3D;1;\n        &#125;\n        &#x2F;&#x2F;dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]\n        for(int i&#x3D;1;i&lt;m;i++)&#123;\n            for(int j&#x3D;1;j&lt;n;j++)&#123;\n                &#x2F;&#x2F;若当前遍历的位置（i,j）不是障碍时，才进行赋值\n                if(obstacleGrid[i][j]!&#x3D;1)&#123;\n                    dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];\n                &#125;\n            &#125;\n        &#125;\n        return dp[m-1][n-1];\n\n    &#125;\n&#125;\n\n","slug":"63-不同路径Ⅱ","date":"2022-08-14T02:53:19.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"0469ba4c963055a01468ddd6a005bdd0","title":"62.爬楼梯","content":"62.爬楼梯题目描述：\n不同路径\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\nexample 1:\n输入：m &#x3D; 3, n &#x3D; 7\n输出：28\n\nexample 2:\n输入：m &#x3D; 3, n &#x3D; 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右\n3. 向下 -&gt; 向右 -&gt; 向下\n\nexample 3：\n输入：m &#x3D; 7, n &#x3D; 3\n输出：28\n\nexample 4:\n输入：m &#x3D; 3, n &#x3D; 3\n输出：6\n\n提示：\n题目来源：https://leetcode.cn/problems/unique-paths\n题解：class Solution &#123;\n    public int uniquePaths(int m, int n) &#123;\n        &#x2F;&#x2F;检查参数合法性\n        if(m&#x3D;&#x3D;0||n&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;定义dp数组，其中dp[i][j]表示的是从(0,0)点到达(i,j)点所存在的路径的数量\n        int[][] dp&#x3D;new int[m][n];\n        &#x2F;&#x2F;对dp进行初始化，dp[i][0]和dp[0][i]都初始化为1，因为从（0，0）点出发都是一条路径，因为机器人只能向下或者向右移动。\n        for(int i&#x3D;0;i&lt;m;i++)&#123;\n            dp[i][0]&#x3D;1;\n        &#125;\n        for(int j&#x3D;0;j&lt;n;j++)&#123;\n            dp[0][j]&#x3D;1;\n        &#125;\n        &#x2F;&#x2F;确定状态变化公式：dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];因为到达i，j一共就两个方向\n        for(int i&#x3D;1;i&lt;m;i++)&#123;\n            for(int j&#x3D;1;j&lt;n;j++)&#123;\n                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];\n            &#125;\n        &#125;\n        return dp[m-1][n-1];\n    &#125;\n&#125;\n\n","slug":"62-爬楼梯","date":"2022-08-14T02:00:07.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"8680cdb46230a68df8607aa6423f9a66","title":"746.使用最小的花费爬楼梯","content":"746.花费最小的花费爬楼梯题目描述：\n使用最小花费爬楼梯\n\n给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n请你计算并返回达到楼梯顶部的最低花费。\nexample 1：\n输入：cost &#x3D; [10,15,20]\n输出：15\n解释：你将从下标为 1 的台阶开始。\n- 支付 15 ，向上爬两个台阶，到达楼梯顶部。\n总花费为 15 。\n\nexample 2:\n输入：cost &#x3D; [1,100,1,1,1,100,1,1,100,1]\n输出：6\n解释：你将从下标为 0 的台阶开始。\n- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。\n- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。\n- 支付 1 ，向上爬一个台阶，到达楼梯顶部。\n总花费为 6 。\n\n提示：\n\n2 &lt;= cost.length &lt;= 1000\n0 &lt;= cost[i] &lt;= 999\n\n题目来源：https://leetcode.cn/problems/min-cost-climbing-stairs\n题解：class Solution &#123;\n    public int minCostClimbingStairs(int[] cost) &#123;\n        &#x2F;&#x2F;检查参数的合法性\n        if(cost&#x3D;&#x3D;null||cost.length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;dp数组的长度和花费数组的长度一致\n        int[] dp&#x3D;new int[cost.length];\n        &#x2F;&#x2F;dp数组初始化，第0节台阶花费cost[0]（每次登上一节）,登上第1节台阶花费cost[1](每次登上两节)\n        dp[0]&#x3D;cost[0];\n        dp[1]&#x3D;cost[1];\n        &#x2F;&#x2F;递推直到cost.length-1节台阶\n        for(int i&#x3D;2;i&lt;cost.length;i++)&#123;\n            dp[i]&#x3D;Math.min(dp[i-1],dp[i-2])+cost[i];\n        &#125;\n        &#x2F;&#x2F;因为登上最后一节台阶是不费力的，所以选择dp末尾两个的最小值即可。\n        return Math.min(dp[cost.length-1],dp[cost.length-2]);\n    &#125;\n&#125;\n\n","slug":"746-使用最小的花费爬楼梯","date":"2022-08-13T04:38:58.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"51d051a502cdfcaa3007846e503519d5","title":"70.爬楼梯","content":"70.爬楼梯题目描述：\n爬楼梯\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\nexample 1:\n输入：n &#x3D; 2\n输出：2\n解释：有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\n\nexample 2:\n输入：n &#x3D; 3\n输出：3\n解释：有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n\n提示：\n\n1 &lt;= n &lt;= 45\n\n题目来源：https://leetcode.cn/problems/climbing-stairs/\n题解：class Solution &#123;\n    public int climbStairs(int n) &#123;\n        if(n&lt;&#x3D;2)&#123;\n            return n; \n        &#125;\n        &#x2F;&#x2F;定义dp数组\n        int[] dp&#x3D;new int[n+1];\n        dp[0]&#x3D;0;\n        dp[1]&#x3D;1;\n        dp[2]&#x3D;2;\n        for(int i&#x3D;3;i&lt;&#x3D;n;i++)&#123;\n            &#x2F;&#x2F;递推公式：dp[i]&#x3D;dp[i-1]+dp[i-2]\n            dp[i]&#x3D;dp[i-1]+dp[i-2];\n        &#125;\n        return dp[n];\n    &#125;\n&#125;\n\n","slug":"70-爬楼梯","date":"2022-08-13T04:05:38.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"084b6d4a3eb1719c740e694cde17f8e9","title":"509.斐波那契数列","content":"509.斐波那契数列\n斐波那契数\n\n斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\nF(0) &#x3D; 0，F(1) &#x3D; 1\nF(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1\n\n给定 n ，请计算 F(n) 。\n题目描述：example 1:\n输入：n &#x3D; 2\n输出：1\n解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1\n\nexample 2:\n输入：n &#x3D; 3\n输出：2\n解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2\n\nexample 3:\n输入：n &#x3D; 4\n输出：3\n解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3\n\n提示：\n\n0 &lt;= n &lt;= 30\n\n题目来源：https://leetcode.cn/problems/fibonacci-number/\n题解：class Solution &#123;\n    public int fib(int n) &#123;\n        if(n&lt;2)\n            return n;\n        &#x2F;&#x2F;确定dp数组，dp[i]\n        int[] dp&#x3D;new int[n+1];\n        &#x2F;&#x2F;确定递推公式，f(n)&#x3D;f(n-1)+f(n-2)\n        &#x2F;&#x2F;dp数组的初始化，dp[0]&#x3D;0,dp[1]&#x3D;1\n        dp[0]&#x3D;0;\n        dp[1]&#x3D;1;\n        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n            dp[i]&#x3D;dp[i-1]+dp[i-2];\n        &#125;\n        return dp[n];\n\n    &#125;\n&#125;\n\n","slug":"斐波那契数列","date":"2022-08-13T03:54:49.000Z","categories_index":"数据结构与算法","tags_index":"Java,动态规划,leetcode","author_index":"LiuQuanZe"},{"id":"401c664502fc1c05444b73fd7436e5f7","title":"1091.二进制矩阵中的最短路径","content":"1091.二进制矩阵中的最短路径题目描述：\n二进制矩阵中的最短路径\n\n难度中等214收藏分享切换为英文接收动态反馈\n给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。\n二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：\n\n路径途经的所有单元格都的值都是 0 。\n路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。\n\n畅通路径的长度 是该路径途经的单元格总数。\nexample:1\n输入：grid &#x3D; [[0,1],[1,0]]\n输出：2\n\nexample 2:\n输入：grid &#x3D; [[0,0,0],[1,1,0],[1,1,0]]\n输出：4\n\nexample 3:\n输入：grid &#x3D; [[1,0,0],[1,1,0],[1,1,0]]\n输出：-1\n\n提示：\n\nn == grid.length\nn == grid[i].length\n1 &lt;= n &lt;= 100\ngrid[i][j] 为 0 或 1\n\n题目来源：https://leetcode.cn/problems/shortest-path-in-binary-matrix/\n题解：\nclass Solution &#123;\n    public int shortestPathBinaryMatrix(int[][] grid) &#123;\n        &#x2F;&#x2F;判断参数是否合法\n        if(grid&#x3D;&#x3D;null||grid.length&#x3D;&#x3D;0||grid[0].length&#x3D;&#x3D;0)&#123;\n            return -1;\n        &#125;        \n        int m&#x3D;grid.length;\n        int n&#x3D;grid[0].length;\n        &#x2F;&#x2F;判断起点和终点是否合法\n        if(grid[0][0]&#x3D;&#x3D;1||grid[m-1][m-1]&#x3D;&#x3D;1)&#123;\n            return -1;\n        &#125;\n        &#x2F;&#x2F;定义8个移动方向\n        int[][] dirs&#x3D;&#123;&#123;1,1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;-1,-1&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;\n        &#x2F;&#x2F;创建队列，加入起点坐标\n        Queue&lt;int[]&gt; queue&#x3D;new LinkedList&lt;&gt;();\n        &#x2F;&#x2F;起点设为1，防止重复遍历,初始化层次计数\n        queue.offer(new int[]&#123;0,0&#125;);\n        grid[0][0]&#x3D;1;\n        int path&#x3D;1;\n        &#x2F;&#x2F;遍历队列\n        while(!queue.isEmpty())&#123;\n            &#x2F;&#x2F;这里获取队列大小的目的是为了区分当前遍历层次和下一个层次，若不记录size，则在队列加入新的元素后无法区分路径长度。\n            int size&#x3D;queue.size();\n            &#x2F;&#x2F;当该层的元素（size大小），全部遍历完毕，就path+1，然后进入下一层。\n            for(int i&#x3D;0;i&lt;size;i++)&#123;\n                int[] cur&#x3D;queue.poll();\n                int x&#x3D;cur[0];\n                int y&#x3D;cur[1];\n                if(x&#x3D;&#x3D;m-1&amp;&amp;y&#x3D;&#x3D;n-1)&#123;\n                    return path;\n                &#125;\n\t\t\t\t&#x2F;&#x2F;将与当前cur相邻的八个方向元素进行遍历，符合条件的入队\n                for(int[] dir:dirs)&#123;\n                    int x1&#x3D;x+dir[0];\n                    int y1&#x3D;y+dir[1];\n                    if(x1&gt;&#x3D;0&amp;&amp; x1&lt;m &amp;&amp; y1&gt;&#x3D;0&amp;&amp; y1&lt;n&amp;&amp; grid[x1][y1]&#x3D;&#x3D;0)&#123;\n                        queue.offer(new int[]&#123;x1,y1&#125;);\n                        grid[x1][y1]&#x3D;1;\n                    &#125;\n                &#125;\n\n            &#125;\n            path++;\n\n        &#125;\n\n        return -1;    \n    &#125;\n&#125;\n\n\n","slug":"1091-二进制矩阵中的最短路径","date":"2022-08-13T02:39:07.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"3a8637d28c1ed4973b1acb4bbd24e5f2","title":"不同的二叉搜索树Ⅱ","content":"95.不同的二叉搜索树Ⅱ题目描述：\n不同的二叉搜索树 II\n\n给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。\nexample 1:\n输入：n &#x3D; 3\n输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n\nexample 2:\n输入：n &#x3D; 1\n输出：[[1]]\n\n提示：\n1&lt;&#x3D;n&lt;&#x3D;8\n题目来源：https://leetcode.cn/problems/unique-binary-search-trees-ii/\n题解：&#x2F;**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val &#x3D; val;\n *         this.left &#x3D; left;\n *         this.right &#x3D; right;\n *     &#125;\n * &#125;\n *&#x2F;\nclass Solution &#123;\n    public List&lt;TreeNode&gt; generateTrees(int n) &#123;\n        &#x2F;&#x2F;若n&#x3D;0则直接返回一个空的列表\n        if(n&#x3D;&#x3D;0)&#123;\n            return new ArrayList&lt;TreeNode&gt;();\n        &#125;\n        &#x2F;&#x2F;递归生成二叉搜索树\n        return generateNodes(1,n);\n    &#125;\n\n    public List&lt;TreeNode&gt; generateNodes(int left,int right)&#123;\n        &#x2F;&#x2F;返回值，存放不同的头节点，（头节点包含子对象left和right，我们只管传入不同的二叉搜索树的头节点即可）\n        List&lt;TreeNode&gt; list&#x3D;new ArrayList&lt;TreeNode&gt;();\n        &#x2F;&#x2F;当left&gt;right表示左边或者右边没有节点了，返回null\n        if(left&gt;right)&#123;\n            list.add(null);\n            return list;\n        &#125;\n        &#x2F;&#x2F;循环所有的节点，将每个遍历的节点作为根节点\n        for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;\n            &#x2F;&#x2F;获取左子树和右子树的所有可能的组合\n            List&lt;TreeNode&gt; left_sub_tree&#x3D;generateNodes(left,i-1);\n            List&lt;TreeNode&gt; right_sub_tree&#x3D;generateNodes(i+1,right);\n            &#x2F;&#x2F;对根节点进行拼接。组成不同的二叉搜索树\n            for(TreeNode a:left_sub_tree)&#123;\n                for(TreeNode b:right_sub_tree)&#123;\n                    &#x2F;&#x2F;注意根节点在此处创建，因为左右子树不同代表不同的二叉搜索树\n                    TreeNode root&#x3D;new TreeNode(i);\n                    root.left&#x3D;a;\n                    root.right&#x3D;b;\n                    &#x2F;&#x2F;将该二叉搜索树存入list\n                    list.add(root);\n                &#125;\n            &#125;\n\n        &#125;\n        return list;\n\n    &#125;\n&#125;\n\n","slug":"不同的二叉搜索树Ⅱ","date":"2022-08-12T02:59:34.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"a2d24fc395bf8cf342e3b277c21f191b","title":"为运算表达式设计优先级","content":"241.为运算表达式设计优先级题目描述：\n为运算表达式设计优先级\n\n给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。\n生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104 。\nexample1:\n输入：expression &#x3D; &quot;2-1-1&quot;\n输出：[0,2]\n解释：\n((2-1)-1) &#x3D; 0 \n(2-(1-1)) &#x3D; 2\n\nexample2:\n输入：expression &#x3D; &quot;2*3-4*5&quot;\n输出：[-34,-14,-10,-10,10]\n解释：\n(2*(3-(4*5))) &#x3D; -34 \n((2*3)-(4*5)) &#x3D; -14 \n((2*(3-4))*5) &#x3D; -10 \n(2*((3-4)*5)) &#x3D; -10 \n(((2*3)-4)*5) &#x3D; 10\n\n提示：\n提示：\n1 &lt;&#x3D; expression.length &lt;&#x3D; 20expression 由数字和算符 ‘+’、’-‘ 和 ‘*’ 组成。输入表达式中的所有整数值在范围 [0, 99] \n题目来源：https://leetcode.cn/problems/different-ways-to-add-parentheses\n题解：class Solution &#123;\n    char[] cs;\n    public List&lt;Integer&gt; diffWaysToCompute(String s) &#123;\n        &#x2F;&#x2F;转化为字符数组\n        char[] chars&#x3D;s.toCharArray();\n        &#x2F;&#x2F;调用递归函数，初始边界是0~s.length()-1\n        return dfs(chars,0,chars.length-1);\n    &#125;\n\n    public List&lt;Integer&gt; dfs(char[] chars,int left,int right)&#123;\n        &#x2F;&#x2F;创建返回值列表\n        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();\n        &#x2F;&#x2F;循环遍历每一个字符\n        for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;\n            &#x2F;&#x2F;若为数字字符，则跳过\n            if(chars[i]&lt;&#x3D;&#39;9&#39;&amp;&amp;chars[i]&gt;&#x3D;&#39;0&#39;)\n                continue;\n            &#x2F;&#x2F;若为运算符字符，则递归左边的所有运算结果和右边的所有运算结果\n            List&lt;Integer&gt; left_ret&#x3D;dfs(chars,left,i-1);\n            List&lt;Integer&gt; right_ret&#x3D;dfs(chars,i+1,right);\n            &#x2F;&#x2F;遍历左边所有的运算结果和右边所有的运算结果，根据当前遇到的运算符进行相应的运算\n            for(int a:left_ret)&#123;\n                for(int b:right_ret)&#123;\n                    if(chars[i]&#x3D;&#x3D;&#39;+&#39;)&#123;\n                        list.add(a+b);\n                    &#125;else if(chars[i]&#x3D;&#x3D;&#39;-&#39;)&#123;\n                        list.add(a-b);\n                    &#125;else if(chars[i]&#x3D;&#x3D;&#39;*&#39;)&#123;\n                        list.add(a*b);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;若list为空，则表示全部为数字字符，则将数字字符加入到list中\n        if(list.isEmpty())&#123;\n            int ret&#x3D;0;\n            for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;\n                ret&#x3D;ret*10+(chars[i]-&#39;0&#39;);\n            &#125;\n            list.add(ret);\n        &#125;\n        return list;\n    &#125;\n\n&#125;\n\n","slug":"为运算表达式设计优先级","date":"2022-08-12T02:29:37.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"8d8d1a0d9f17dbec885c291446cece5c","title":"寻找旋转排序数组中的最小值","content":"153.寻找旋转排序数组中的最小值题目描述：153. 寻找旋转排序数组中的最小值已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：\n\n若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]\n若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]\n\n注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\nexample 1：\n输入：nums &#x3D; [3,4,5,1,2]\n输出：1\n解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n\nexample 2：\n输入：nums &#x3D; [4,5,6,7,0,1,2]\n输出：0\n解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n\nexample 3:\n输入：nums &#x3D; [11,13,15,17]\n输出：11\n解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n\n题目来源：https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/\n题解：class Solution &#123;\n    public int findMin(int[] nums) &#123;\n        int left&#x3D;0;\n        int right&#x3D;nums.length-1;\n        int ret&#x3D;0;\n        while(left&lt;right)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            &#x2F;&#x2F;在访问时需要访问mid以及右边的元素，所以至少访问两个元素，left&lt;right为循环结束的条件\n            if(nums[mid]&gt;nums[right])&#123;\n                left&#x3D;mid+1;\n            &#125;else&#123;\n                right&#x3D;mid;\n            &#125;\n        &#125;\n        return nums[right];\n    &#125;\n&#125;\n\n","slug":"寻找旋转排序数组中的最小值","date":"2022-08-08T03:56:07.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"d84518667e657cd3814bae0fb73c941b","title":"寻找峰值","content":"162. 寻找峰值题目描述：162. 寻找峰值峰值元素是指其值严格大于左右相邻值的元素。\n给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n你可以假设 nums[-1] = nums[n] = -∞ 。\n你必须实现时间复杂度为 O(log n) 的算法来解决此问题。\nexample 1:\n输入：nums &#x3D; [1,2,3,1]\n输出：2\n解释：3 是峰值元素，你的函数应该返回其索引 2。\n\nexample 2:\n输入：nums &#x3D; [1,2,1,3,5,6,4]\n输出：1 或 5 \n解释：你的函数可以返回索引 1，其峰值元素为 2；\n     或者返回索引 5， 其峰值元素为 6。\n\n\n\n题目来源：https://leetcode.cn/problems/find-peak-element/\n题解：class Solution &#123;\n    public int findPeakElement(int[] nums) &#123;\n        if(nums.length&#x3D;&#x3D;1)&#123;\n            return 0;\n        &#125;\n        int left&#x3D;0;\n        int right&#x3D;nums.length-1;\n        int ret&#x3D;0;\n        &#x2F;&#x2F;这里使用的是左开右闭区间，不可使用左闭右闭区间，因为在进行查找时需要和右边的元素进行比较，所以必须保证，搜索区间包含至少两个元素，因此left&lt;&#x3D;right时，是不满足条件的，当left&#x3D;&#x3D;right进行判断时，会发生数组越界异常，因此该题只可以使用左闭右开区间。\n        while(right&gt;left)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            if(nums[mid]&gt;nums[mid+1])&#123;\n\n                right&#x3D;mid;\n            &#125;else&#123;\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return right;\n    &#125;\n&#125;\n\n","slug":"寻找峰值","date":"2022-08-08T03:00:38.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"37fafcaad932621c324a857d69f2ce34","title":"第一个错误版本","content":"278.第一个错误版本题目描述：278. 第一个错误的版本你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\n你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\nexample 1:\n输入：n &#x3D; 5, bad &#x3D; 4\n输出：4\n解释：\n调用 isBadVersion(3) -&gt; false \n调用 isBadVersion(5) -&gt; true \n调用 isBadVersion(4) -&gt; true\n所以，4 是第一个错误的版本。\n\nexample 2:\n输入：n &#x3D; 1, bad &#x3D; 1\n输出：1\n\n题目来源：https://leetcode.cn/problems/first-bad-version/\n题解：\n&#x2F;&#x2F;左闭右闭区间，循环结束时left&gt;right，则此时最后一次得到的mid（即最后一次查找到的版本是没有保存的，所以需要ret变量进行保存）\n&#x2F;* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); *&#x2F;\n\npublic class Solution extends VersionControl &#123;\n    public int firstBadVersion(int n) &#123;\n        int left&#x3D;0;\n        int right&#x3D;n;\n        int ret&#x3D;-1;\n        while(left&lt;&#x3D;right)&#123;\n            int mid&#x3D;left+(right-left)&#x2F;2;\n            &#x2F;&#x2F;当前版本如果是错误版本，则当前版本可能是第一个出现错误的版本，需要暂存\n            if(isBadVersion(mid))&#123;\n                ret&#x3D;mid;\n                right&#x3D;mid-1;\n            &#125;else&#123;\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return ret;\n\n        \n    &#125;\n&#125;\n\n&#x2F;* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); *&#x2F;\n\npublic class Solution extends VersionControl &#123;\n    public int firstBadVersion(int n) &#123;\n        int left&#x3D;0;\n        int right&#x3D;n;\n        int ret&#x3D;-1;\n        &#x2F;&#x2F;循环的结束条件是left&#x3D;right，并且right&#x3D;最后一个mid，所以返回值也是最后一个mid&#x3D;right&#x3D;left\n        while(left&lt;right)&#123;\n            int mid&#x3D;left+(right-left)&#x2F;2;\n            &#x2F;&#x2F;左闭右开区间，循环结束条件是left&lt;right,下一轮循环是从left~right-1，右边是开区间\n            if(isBadVersion(mid))&#123;\n                &#x2F;&#x2F; ret&#x3D;mid;\n                right&#x3D;mid;\n            &#125;else&#123;\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return right;\n\n        \n    &#125;\n&#125;\n\n","slug":"第一个错误版本","date":"2022-08-08T02:00:30.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"ea76d2e3b8ba7df05f2a9007a5c4d57e","title":"搜索旋转排序数组","content":"33. 搜索旋转排序数组题目描述：33. 搜索旋转排序数组整数数组 nums 按升序排列，数组中的值 互不相同 。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\nexample 1:\n输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0\n输出：4\n\nexample 2:\n输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3\n输出：-1\n\nexample 3:\n输入：nums &#x3D; [1], target &#x3D; 0\n输出：-1\n\n题目来源：https://leetcode.cn/problems/search-in-rotated-sorted-array/\n题解：class Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        &#x2F;&#x2F;初始边界\n        int left&#x3D;0;\n        int right&#x3D;nums.length-1;\n        &#x2F;&#x2F;区间\n        while(left&lt;&#x3D;right)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            if(nums[mid]&#x3D;&#x3D;target) return mid;\n            &#x2F;&#x2F;mid位于左边的升序序列当中\n            if(nums[mid]&gt;&#x3D;nums[left])&#123;\n                &#x2F;&#x2F;target位于左侧有序序列中\n                if(target&lt;nums[mid]&amp;&amp;target&gt;&#x3D;nums[left])&#123;\n                    right&#x3D;mid-1;\n                &#125;else&#123;\n                    left&#x3D;mid+1;\n                &#125;\n\n            &#125;else&#123;              &#x2F;&#x2F;右侧为升序\n                &#x2F;&#x2F;target位于右侧有序序列中\n                if(target&gt;nums[mid]&amp;&amp;target&lt;&#x3D;nums[right])&#123;\n                    left&#x3D;mid+1;\n                &#125;else&#123;\n                    right&#x3D;mid-1;\n                &#125;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n\n","slug":"搜索旋转排序数组","date":"2022-08-07T02:54:15.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-08-07T02:30:53.375Z","categories_index":"","tags_index":"","author_index":"LiuQuanZe"},{"id":"03e1cda0baa3a649921c8af01fed4d68","title":"我的第一篇博客","content":"第一篇博客哈哈，我有自己的博客啦！\n","slug":"demo01","date":"2022-08-07T02:30:53.353Z","categories_index":"个人","tags_index":"记录,日常","author_index":"LiuQuanZe"},{"id":"5a834cb8bdd34deef00d023624eeeb11","title":"有序数组的单一元素","content":"540. 有序数组的单一元素题目描述：\n给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。\n请你找出并返回只出现一次的那个数。\n你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。\nexample 1：\n输入: nums &#x3D; [1,1,2,3,3,4,4,8,8]\n输出: 2\n\nexample 2:\n输入: nums &#x3D;  [3,3,7,7,10,11,11]\n输出: 10\n\n题目来源：https://leetcode.cn/problems/single-element-in-a-sorted-array\n题解：class Solution &#123;\n    public int singleNonDuplicate(int[] nums) &#123;\n        if(nums.length&#x3D;&#x3D;1)&#123;\n            return nums[0];\n        &#125;\n        int left&#x3D;0;\n        int right&#x3D;nums.length-1;\n        int result&#x3D;0;\n        while(right&gt;left)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            &#x2F;&#x2F;若mid为偶数，则判断mid与mid+1是否相等，若mid为奇数，则判断mid和mid-1是否相等\n            if(nums[mid]&#x3D;&#x3D;nums[mid^1])&#123;\n                &#x2F;&#x2F;若相等则表示单个数字x位于右边\n                &#x2F;&#x2F;并且因为相等，所以mid所指向的数字一定不是单个数字x\n                left&#x3D;mid+1;\n            &#125;else&#123;\n                &#x2F;&#x2F;若不相等，则表示单个数字x位于左边，并且因为不相等，所以当前mid所指向的数字可能就是我们要找的单个数字x,不能直接提剔除\n                right&#x3D;mid;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;直接返回right\n        return nums[right];\n\n    &#125;\n&#125;\n\n\n\n","slug":"有序数组的单一元素","date":"2022-08-06T02:23:53.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"bf9943093888157a40e49bab81aa424f","title":"Pycharm模块不存在","content":"Pycharm模块不存在问题描述：当运行Python文件时，出现以下报错：\npython中已经用pip安装了某模块，但pycharm中为什么仍然显示没有该模块\n\n出现原因：pycharm里面自带一个Python解释器，而这个里面是没有几个模块的。因为咱们在DOS命令行里面下载的模块是下载到Python的解释器里而不是pycharm里面的那个。\n解决方案：打开pycharm依次点击file-&gt;Settings-&gt;Project Interpreter；\n可以看到当前项目正在使用的Python解释器，即Project Interpreter那一栏。\n可以将其替换为本机上安装的Python解释器，即cmd中可以查看到的python解释器：\n1.查找本机Python的安装地址：\nC:\\Users\\26485&gt;where python\nC:\\Users\\26485\\AppData\\Local\\Programs\\Python\\Python39\\python.exe\nC:\\Users\\26485\\AppData\\Local\\Microsoft\\WindowsApps\\python.exe\n\n2.在Project Interpreter添加对应地址中新的解释器，添加完成后，可以看到我们在本机环境下已经安装的模块和工具包。\n","slug":"Pycharm模块不存在","date":"2022-08-05T02:33:06.000Z","categories_index":"Python","tags_index":"报错,Pycharm","author_index":"LiuQuanZe"},{"id":"d776ea82847944d1f9a7d73d3912befe","title":"寻找比目标字母大的最小字母","content":"744. 寻找比目标字母大的最小字母题目描述：给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。\n在比较时，字母是依序循环出现的。举个例子：\n如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’\nexample 1:\n输入: letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]，target &#x3D; &quot;a&quot;\n输出: &quot;c&quot;\n\nexample 2:\n输入: letters &#x3D; [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target &#x3D; &quot;c&quot;\n输出: &quot;f&quot;\n\nexample 3:\n输入: letters &#x3D; [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target &#x3D; &quot;d&quot;\n输出: &quot;f&quot;\n\n\n\n题目来源：https://leetcode.cn/problems/find-smallest-letter-greater-than-target\n题解：1.二分法：开区间\nclass Solution &#123;\n    public char nextGreatestLetter(char[] letters, char target) &#123;\n   \n        &#x2F;&#x2F;当target大于数组的最大值的时候，表示数组中所有元素均小于target，因为数组中字符是有序的。\n        if(target&gt;&#x3D;letters[letters.length-1])&#123;\n            return letters[0];\n        &#125;\n        &#x2F;&#x2F;若上述if语句不符合则表示该数组必定存在大于target的元素。\n        int left&#x3D;0;\n        int right&#x3D;letters.length-1;\n                &#x2F;&#x2F; 如果为左闭右闭那么while里面的判断语句是left&lt;&#x3D;right ；若为左闭右开或者左开右闭，则while的判断语句是left &lt; right\n        &#x2F;&#x2F;左开右闭：left&#x3D;mid;right&#x3D;mid-1;\n        &#x2F;&#x2F;左闭右开：left&#x3D;mid+1;right&#x3D;mid;\n        while(left&lt;right)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            if(letters[mid]&gt;target)&#123;    &#x2F;&#x2F;当mid指向的元素大于target时，则有可能是最小的大于target的元素\n                right&#x3D;mid;\n            &#125;else&#123;     &#x2F;&#x2F;当mid元素小于或等于target时，mid指向的元素必然不是我们最终要找的元素，可以直接跳过mid指向的元素，mid+1\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return letters[left];\n     \n\n    &#125;\n&#125;\n\n\n2.线性搜索：\nclass Solution &#123;\n    public char nextGreatestLetter(char[] letters, char target) &#123;\n        int min&#x3D;Integer.MAX_VALUE;\n        int min_index&#x3D;0;\n        for(int i&#x3D;0;i&lt;letters.length;i++)&#123;\n            &#x2F;&#x2F;i指向的元素在target后面，则比较当前维护的最短距离\n            if(letters[i]-target&gt;0)&#123;\n                min&#x3D;Math.min(min,letters[i]-target);\n                if(min&#x3D;&#x3D;letters[i]-target)&#123;\n                    min_index&#x3D;i;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;若target大于letters数组中的所有元素，则直接返回0号元素\n        if(min&#x3D;&#x3D;Integer.MAX_VALUE)&#123;\n            return letters[0];\n        &#125;\n        return letters[min_index];\n    &#125;\n&#125;\n\n3.二分法：闭区间\nclass Solution &#123;\n    public char nextGreatestLetter(char[] letters, char target) &#123;\n        if(letters[letters.length-1]&lt;&#x3D;target)&#123;\n            return letters[0];\n        &#125;\n        int right&#x3D;letters.length;\n        int left&#x3D;0;\n        int result&#x3D;0;\n        &#x2F;&#x2F;闭区间写法，left&lt;&#x3D;right；right&#x3D;mid-1;left&#x3D;mid+1;因为当mid指向的元素大于target时，该元素可能就是我们要找的目标元素，所以需要记录mid指向的元素result&#x3D;mid;，对比开区间，right&#x3D;mid；left&lt;right当left&#x3D;&#x3D;right时结束循环，不会漏掉这个解，但是闭区间更清楚一些\n        while(left&lt;&#x3D;right)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            if(letters[mid]&gt;target)&#123;\n                result&#x3D;mid;\n                right&#x3D;mid-1;\n            &#125;else&#123;\n                left&#x3D;mid+1;\n            &#125;\n        &#125;\n        return letters[result];\n    &#125;\n&#125;\n\n\n\n","slug":"寻找比目标字母大的最小字母","date":"2022-08-05T01:53:07.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"3b8822123bb08af7e60b15ed39819f81","title":"x的平方根","content":"69. x的平方根题目描述：给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\nexample 1:\n输入：x &#x3D; 4\n输出：2\n\nexample 2:\n输入：x &#x3D; 8\n输出：2\n解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n\n\n\n题目来源：https://leetcode.cn/problems/sqrtx\n题解：&#x2F;&#x2F;左开右闭区间\nclass Solution &#123;\n    public int mySqrt(int x) &#123;\n        if(x&#x3D;&#x3D;1)&#123;\n            return 1;\n        &#125;\n        int left&#x3D;0;\n        int right&#x3D;x;\n        int result&#x3D;0;\n        while(left&lt;right)&#123;\n            int mid&#x3D;(right-left)&#x2F;2+left;\n            if((long)mid*mid&lt;&#x3D;x)&#123;\n                result&#x3D;mid;\n                left&#x3D;mid+1;\n            &#125;else&#123;\n                right&#x3D;mid;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\nint mid &#x3D; (left + right) &#x2F; 2; 与 int mid &#x3D; left + (right - left) &#x2F; 2; 二者的区别\n    二者结果一样，但是left + right 可能会溢出\n\n&#x2F;&#x2F;左闭右闭区间\nclass Solution &#123;\n    public int mySqrt(int x) &#123;\n        &#x2F;&#x2F;闭区间\n        int left&#x3D;0;\n        int right&#x3D;x;\n        &#x2F;&#x2F;暂存符合条件的元素\n        int result&#x3D;0;\n        while(left&lt;&#x3D;right)&#123;\n            int mid&#x3D;left+(right-left)&#x2F;2;\n            if((long)mid*mid&lt;&#x3D;x)&#123;\n                result&#x3D;mid;\n                left&#x3D;mid+1;\n            &#125;else&#123;\n                right&#x3D;mid-1;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n","slug":"x的平方根","date":"2022-08-04T01:36:47.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"b3d8a41da3eeb7700876b944e097bd03","title":"划分字母区间","content":"763.划分字母区间题目描述：763. 划分字母区间字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。\nexample 1:\n输入：S &#x3D; &quot;ababcbacadefegdehijhklij&quot;\n输出：[9,7,8]\n解释：\n划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。\n每个字母最多出现在一个片段中。\n像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。\n\n题目来源：https://leetcode.cn/problems/partition-labels/\n题解：class Solution &#123;\n    public List&lt;Integer&gt; partitionLabels(String s) &#123;\n        &#x2F;** \n        贪心算法：\n            由于每个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。\n            在得到每个字母的最后一次出现的下标位置之后，可以使用贪心算法将字符串划分为尽可能多的片段，具体做法如下：\n            1.从左到右遍历字符串，遍历的同时维护当前片段的开始下标start和结束下标end，初始化start&#x3D;end&#x3D;0；\n            2.对于每一个访问到的字母c，得到当前字母的最后一次出现的下标位置endc，则当前片段的结束下标一定不会小于endc，因此令end&#x3D;max(end,endc);\n            3.当访问到下标end时，当前片段访问结束，当前片段的下标范围是[start,end]，长度为end-start+1，将当前片段的长度添加到返回值，然后令start&#x3D;end+1，继续寻找下一个片段；\n            4.重复上述过程，知道遍历完字符串\n        *&#x2F;\n        用于记录每个字母出现的最后位置\n        int[] chars&#x3D;new int[26];\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            &#x2F;&#x2F;将当前字母在s中出现的位置存入chars数组中对应字母的下标位置中\n            chars[s.charAt(i)-&#39;a&#39;]&#x3D;i;\n        &#125;\n        List&lt;Integer&gt; partition&#x3D;new ArrayList&lt;&gt;();\n        int start&#x3D;0;\n        int end&#x3D;0;\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            &#x2F;&#x2F;得到对应字母c的最迟出现位置，若endc&gt;end则更新end的值，表示出现了比之前end对应字母还晚的字母，如果endc&lt;end则表示字母c的end所对应的字母的最晚出现位置已经在c的最晚出现位置之后了\n            end&#x3D;Math.max(end,chars[s.charAt(i)-&#39;a&#39;]);\n            if(end&#x3D;&#x3D;i)&#123;\n                &#x2F;&#x2F;添加片段长度，更新start的值\n                partition.add(end-start+1);\n                start&#x3D;end+1;\n            &#125;\n        &#125;\n        return partition;\n\n\n    &#125;\n&#125;\n\n\n\n","slug":"划分字母区间","date":"2022-08-03T02:16:17.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"f6c56b941ed067956656bab8c3d0bb61","title":"最大子数组和","content":"最大子数组和题目描述：\n最大子数组和\n\n给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\nexample 1:\n输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\nexample 2:\n输入：nums &#x3D; [1]\n输出：1\n\nexample 3:\n输入：nums &#x3D; [5,4,-1,7,8]\n输出：23\n\n题目来源：https://leetcode.cn/problems/maximum-subarray/\n题解：class Solution &#123;\n    public int maxSubArray(int[] nums) &#123;\n        &#x2F;*\n        贪心算法：从左到右跌倒，一个一个遍历，遇到sum&lt;0,则重置sum，，return记录每次出现的sum的值的最大值。\n        *&#x2F;\n        &#x2F;&#x2F;return的初始大小为整型数据的最小值，为了和sum进行比较时可以接受任意小的sum\n        int result&#x3D;Integer.MIN_VALUE;\n        int sum&#x3D;0;\n        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;\n            &#x2F;&#x2F;加上当前的被遍历的元素\n            sum+&#x3D;nums[i];\n            &#x2F;&#x2F;和result维护的之前sum的最大值进行比较，更新sum最大值\n            result&#x3D;Math.max(result,sum);\n            &#x2F;&#x2F;若当前和小于0，则重置sum的值为0，重新开始找子序列\n            if(sum&lt;0)&#123;\n                sum&#x3D;0;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n","slug":"最大子数组和","date":"2022-08-02T01:22:15.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"ec406ffdb14348b593a8eaccf18d5ae3","title":"非递减数列","content":"非递减数列题目描述：665. 非递减数列难度中等681收藏分享切换为英文接收动态反馈\n给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。\n我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]\nexample 1:\n输入: nums &#x3D; [4,2,3]\n输出: true\n解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。\n\nexample 2:\n输入: nums &#x3D; [4,2,1]\n输出: false\n解释: 你不能在只改变一个元素的情况下将其变为非递减数列。\n\n\n\n题目来源：https://leetcode.cn/problems/non-decreasing-array/\n题解：class Solution &#123;\n    public boolean checkPossibility(int[] nums) &#123;\n        &#x2F;**\n        贪心算法：三种逆序情况\n        1.当i&#x3D;1时，与前一个元素发生逆序，则改变前一个元素的值，【4，2，5】，当遍历至2时发生逆序，将4改为2；\n        2.当i&gt;1,并且与i-1元素发生逆序时，需要查看i-2位置的元素，若i-2位置小于或者等于i位置元素，则依旧改变i-2位置元素，eg【1, 4, 2, 5】遍历至2时发生逆序，由于1&lt;2依旧是有序的，只需要改变4即可，将4改为2；\n        3.当i&gt;1,并且与i-1元素发生逆序时，需要查看i-2位置的元素，若i-2位置大于i位置元素，则此时仅改变i-1位置的元素依旧是无法实现递增的，此时只能将i位置的元素修改为i-1位置的元素。eg【3, 4, 2, 5】，此时2与4发生逆序，若仅仅修改4的值是无法实现递增的，因为3依旧是大于2的，所以只能将2修改为4实现递增。\n        总结：\n        当 nums[i] 破坏了数组的单调递增时，即 nums[i] &lt; nums[i - 1]  时，为了让数组有序，我们发现一个规律（在上面三个例子中， nums[i] 都为 2， nums[i -1] 都为 4）：\n\n如例①的情况，当 i &#x3D; 1 ，那么修改 num[i- 1] ，不要动 nums[i] ，因为nums[i]后面的元素是啥我们还不知道呢，少动它为妙。\n如例②的情况，当 i &gt; 1 时，我们应该优先考虑把 nums[i - 1] 调小到 &gt;&#x3D; nums[i - 2] 并且 &lt;&#x3D; nums[i]。同样尽量不去修改 nums[i] ，理由同上。\n如例③的情况，当 i &gt; 1 且 nums[i] &lt; nums[i - 2] 时，我们无法调整 nums[i - 1] ，我们只能调整 nums[i] 到 nums[i - 1] 。\n         *&#x2F;\n\n\n\n        &#x2F;&#x2F;用于记录改变元素的数量\n        int count&#x3D;0;\n        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;\n            &#x2F;&#x2F;发生逆序，即不是递增\n            if(nums[i]&lt;nums[i-1])&#123;\n                &#x2F;&#x2F;当逆序发生在1位置,改变前一个元素的位置\n                if(i&#x3D;&#x3D;1)&#123;\n                    nums[i-1]&#x3D;nums[i];\n                &#125;else if(nums[i]&lt;nums[i-2])&#123;    &#x2F;&#x2F;i位置元素小于i-2位置，则改变i的值\n                    nums[i]&#x3D;nums[i-1];\n                &#125;else if(nums[i]&gt;&#x3D;nums[i-2])&#123;   &#x2F;&#x2F;i位置元素大于等于i-2位置，改变i-1位置\n                    nums[i-1]&#x3D;nums[i];\n                &#125;\n                if(++count&gt;1)&#123;\n                    return false;\n                &#125;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n\n\n参考资料：https://leetcode.cn/problems/non-decreasing-array/solution/3-zhang-dong-tu-bang-zhu-ni-li-jie-zhe-d-06gi/\n\n","slug":"非递减数列","date":"2022-08-01T02:10:59.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"82a606d2417be24205d07d3a23121174","title":"判断子序列","content":"392.判断子序列题目描述：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。\nexample 1:\n输入：s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;\n输出：true\n\nexample 2:\n输入：s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;\n输出：false\n\n题目来源：https://leetcode.cn/problems/is-subsequence/\n题解：class Solution &#123;\n    public boolean isSubsequence(String s, String t) &#123;\n        &#x2F;&#x2F;定义分别指向两个字符串序列的指针\n        int index_s&#x3D;0;\n        int index_t&#x3D;0;\n        &#x2F;&#x2F;当匹配成功，子序列后移，匹配失败，主序列后移&#x3D;&#x3D;贪心算法\n        while(index_s&lt;s.length()&amp;&amp;index_t&lt;t.length())&#123;\n            if(s.charAt(index_s)&#x3D;&#x3D;t.charAt(index_t))&#123;\n                index_s++;\n            &#125;\n            index_t++;\n        &#125;\n        &#x2F;&#x2F;当子序列达到末尾，表示子序列匹配成功，返回true\n        if(index_s&#x3D;&#x3D;s.length())&#123;\n            return true;\n        &#125;\n        &#x2F;&#x2F;否则表示匹配失败，返回false\n        return false;\n    &#125;\n&#125;\n\n","slug":"判断子序列","date":"2022-07-31T03:01:34.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"17a5d31322fb6873ed3794c44302ea45","title":"种花问题","content":"605.种花问题题目描述：假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。\n给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。\nexample 1:\n输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1\n输出：true\n\nexample 2:\n输入：flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2\n输出：false\n\n\n\n题目来源：https://leetcode.cn/problems/can-place-flowers/\n题解：class Solution &#123;\n    public boolean canPlaceFlowers(int[] flowerbed, int n) &#123;\n        if(flowerbed.length&#x3D;&#x3D;0)&#123;\n            return false;\n        &#125;\n        for(int i&#x3D;0;i&lt;flowerbed.length;i++)&#123;\n            &#x2F;&#x2F;遇到的情况\n            &#x2F;&#x2F;1.当前元素为0，并且后续也为0，则插入花，并减少剩余数量，i++，向后跳两格\n            &#x2F;&#x2F;2.当前元素为0，且为最后一个元素，则插入花，向后跳两格子\n            &#x2F;&#x2F;3.当前元素为1，则继续向后跳两格，因为后一个位子必定没法插入\n            &#x2F;&#x2F;4.若当前元素为0，后续为1，则跳一格，进入第三种情况\n            &#x2F;&#x2F;每次只需要判断当前元素和后一个元素，无需考虑前一个元素，并且从第一个元素开始判断\n            if(flowerbed[i]&#x3D;&#x3D;0&amp;&amp;(i+1&#x3D;&#x3D;flowerbed.length||flowerbed[i+1]&#x3D;&#x3D;0))&#123;\n                i++;\n                n--;\n            &#125;else if(flowerbed[i]&#x3D;&#x3D;1)&#123;\n                i++;\n            &#125;\n\n        &#125;\n        return n&lt;&#x3D;0? true:false;\n    &#125;\n&#125;\n\n","slug":"种花问题","date":"2022-07-30T01:41:20.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"6b879bd90cb55e176f69ea7d49b28d19","title":"买卖股票的最佳时机2","content":"122. 买卖股票的最佳时机2题目描述：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\n在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n返回 你能获得的 最大 利润 。\nexample 1:\n输入：prices &#x3D; [7,1,5,3,6,4]\n输出：7\n解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。\n     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。\n     总利润为 4 + 3 &#x3D; 7 。\n\nexample 2:\n输入：prices &#x3D; [1,2,3,4,5]\n输出：4\n解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。\n     总利润为 4 。\n\n\n\n题目来源：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/\n题解：class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        &#x2F;&#x2F;贪心，只要股票能涨，就卖，只要能赚到钱，就卖\n        int max_profit&#x3D;0;\n        &#x2F;&#x2F;从第二天开始遍历，只要比前一天价格高，就卖掉\n        for(int i&#x3D;1;i&lt;prices.length;i++)&#123;\n            if(prices[i]&gt;prices[i-1])&#123;\n                max_profit+&#x3D;prices[i]-prices[i-1];\n            &#125;\n        &#125;\n        return max_profit;\n    &#125;\n&#125;\n\n","slug":"卖出股票的最佳时机2","date":"2022-07-29T02:18:33.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"5d7c6d0b72a0ac167a5663e12c3dcdf4","title":"买股票的最佳时机","content":"121. 买股票的最佳时机题目描述：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\nexample 1:\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。\n     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\nexample 2:\n输入：prices &#x3D; [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n\n题目来源：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/\n题解：&#x2F;*\n贪心：最大收益一定是在历史最低点买入\n\n*&#x2F;\npublic class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        \n        &#x2F;&#x2F;最大收益，初始化为0\n        int maxprofit &#x3D; 0;\n        &#x2F;&#x2F;最低买入点，初始化为最大值\n        int min_time&#x3D;Integer.MAX_VALUE;\n        &#x2F;&#x2F;遍历每天价格\n        for(int price:prices)&#123;\n            &#x2F;&#x2F;若出现了更低的买入点，则更新买入点\n            min_time&#x3D;Math.min(min_time,price);\n            &#x2F;&#x2F;若当前价格高于最低买入点，则计算收益，并更新最大收集\n            maxprofit&#x3D;Math.max(maxprofit,price-min_time);\n        &#125;\n        return maxprofit;\n    &#125;\n&#125;\n\n","slug":"买股票的最佳时机","date":"2022-07-29T01:41:19.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"3961e8d57cd72a6f65bba4c20e028616","title":"列表导出为数组","content":"Java中List集合的toArray方法1. toArray()\n当没有参数指定时，返回的数组中元素的类型是Object类型的。因为List在使用时一般会指定泛型，所以该方法是不常用的。\n\n2.toArray(T[] a)\nleetcode-406使用到了该方法将列表对象转化为二维数组\n可以导出数组为指定的类型\n\nList&lt;String&gt; list&#x3D;new List&lt;&gt;();\nlist.add(&quot;hello&quot;);\nlist.add(&quot;world&quot;);\nString[] strs&#x3D;list.toArray(new String[list.size()]);\n\nList&lt;int[]&gt; list&#x3D;new List&lt;&gt;();\nlist.add(new int[]&#123;0,1&#125;);\nlist.add(new int[]&#123;1,0&#125;);\nint[][] ret&#x3D;list.toArray(new int[list.size()][]);\n\n\n\n","slug":"ListtoArray","date":"2022-07-28T03:18:32.000Z","categories_index":"","tags_index":"Java,数据结构","author_index":"LiuQuanZe"},{"id":"17c36b5674ca98b6f74033f762d79de8","title":"根据身高重建队列","content":"406.根据身高重建队列题目描述：假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。\n请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\nexample 1:\n输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n解释：\n编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。\n编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。\n编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。\n编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。\n编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。\n\n\n\nexample 2:\n输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\n输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n\n\n\n题目来源：https://leetcode.cn/problems/queue-reconstruction-by-height/\n题解class Solution &#123;\n    public int[][] reconstructQueue(int[][] people) &#123;\n        &#x2F;*\n        第一个元素进行降序排序，即元素越小，排的越靠后，\n        对于第一个元素相同的数组，针对第二个元素进行升序排序，即越小越靠前，之所以这样排序，是因为，最后是按照第二个元素\n        进行插入的，也就是说，被插入的时间比较早的元素比较容易被挤到后面，也是因为这个原因，第一个元素是降序，越小的插入的时间越迟，越大的越有可能后移，这样是不会出错的。\n        同理第二个元素，越大的越靠后，因为后面元素的插入不会影响前面的元素，而前面元素的插入是会影响后面的，所以先插小，后插大\n\n         *&#x2F;\n         &#x2F;&#x2F;对第一个元素进行降序排序，在第一个元素相同时对第二个元素进行降序\n        Arrays.sort(people,(m,n)-&gt;&#123;\n            &#x2F;&#x2F;第一个元素不相等时，使用降序\n            if(m[0]!&#x3D;n[0])&#123;\n                return n[0]-m[0];\n                &#x2F;&#x2F;第一个元素相等时，使用升序\n            &#125;else&#123;\n                return m[1]-n[1];\n            &#125;\n        &#125;);\n        &#x2F;&#x2F;创建返回值\n        List&lt;int[]&gt; list&#x3D;new ArrayList&lt;&gt;();\n        &#x2F;&#x2F;将排序后的数组插入到返回值中\n        for(int[] person:people)&#123;\n            &#x2F;&#x2F;若返回值列表大小大于要插入位置，则直接插入\n            if(list.size()&gt; person[1])&#123;\n                list.add(person[1],person);\n            &#125;else&#123;      &#x2F;&#x2F;若返回值列表大小小于要插入位置，则将person插入列表末尾位置\n                list.add(list.size(),person);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;将列表转化为二维数组进行返回\n        return list.toArray(new int[list.size()][]);\n\n    &#125;\n&#125;\n\n","slug":"根据身高重建队列","date":"2022-07-28T03:13:52.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"8c8ee24da1a163a01cda5376a75169b1","title":"452.Minimum Number of Arrows to Burst Balloons","content":"452.Minimum Number of Arrows to Burst Balloons题目描述：There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] &#x3D; [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;&#x3D; x &lt;&#x3D; xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\n有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。\n一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。\n给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。\nexample 1:\n输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]\n输出：2\n解释：气球可以用2支箭来爆破:\n-在x &#x3D; 6处射出箭，击破气球[2,8]和[1,6]。\n-在x &#x3D; 11处发射箭，击破气球[10,16]和[7,12]。\n\nexample 2:\n输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]\n输出：4\n解释：每个气球需要射出一支箭，总共需要4支箭。\n\nexample 3:\n输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]\n输出：2\n解释：气球可以用2支箭来爆破:\n- 在x &#x3D; 2处发射箭，击破气球[1,2]和[2,3]。\n- 在x &#x3D; 4处射出箭，击破气球[3,4]和[4,5]。\n\n题目链接：https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/\n题解：&#x2F;*排序+贪心*&#x2F;\nclass Solution &#123;\n    public int findMinArrowShots(int[][] points) &#123;\n        &#x2F;&#x2F;检查数组是否合法\n        if(points.length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;依据右边界的大小进行升序排序\n        Arrays.sort(points,new Comparator&lt;&gt;()&#123;\n            public int compare(int[] m,int[] n)&#123;\n                &#x2F;&#x2F;m小n大则不用交换位置，因为我们要的就是升序排序\n                if(m[1]&lt;n[1])&#123;\n                    return -1;\n                    &#x2F;&#x2F;m大n小，则需要交换位置，保证升序\n                &#125;else if(m[1]&gt;n[1])&#123;\n                    return 1;\n                    &#x2F;&#x2F;若m&#x3D;n则不需要交换位置，【当返回值小于等于0时，不进行元素交换，仅当返回值大于0时才需要进行交换！】\n                &#125;else&#123;\n\n                    return 0;\n                &#125;\n            &#125;\n        &#125;);\n        &#x2F;&#x2F;获取第一个元素的右边界作为初始右边界\n        long right&#x3D;points[0][1];\n        &#x2F;&#x2F;用于箭矢计数，初始值为1\n        int num&#x3D;1;\n        &#x2F;&#x2F;对元素进行遍历，如果需要遇到了不重叠的气球（即左边界大于right），则需要增加箭矢的数量，并更新右边界的值\n        for(int[] b:points)&#123;\n            if(b[0]&gt;right)&#123;\n                num++;\n                right&#x3D;b[1];\n            &#125;\n        &#125;\n        &#x2F;&#x2F;返回箭矢的数量\n        return num;\n\n    &#125;\n&#125;\n\n","slug":"MinimumNumberofArrowstoBurstBalloons","date":"2022-07-27T02:11:15.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"0b469cb01192ec369bac9950f85cb59d","title":"Non—overlapping Intervals","content":"435. Non-overlapping Intervals题目描述：Given an array of intervals intervals where intervals[i] &#x3D; [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nexample 1:\nInput: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n\n\n\n\nexample 2:\nInput: intervals &#x3D; [[1,2],[1,2],[1,2]]\nOutput: 2\nExplanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n\nexample 3:\nInput: intervals &#x3D; [[1,2],[2,3]]\nOutput: 0\nExplanation: You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.\n\n来源：力扣（LeetCode）链接：https://leetcode.cn/problems/non-overlapping-intervals\n题解：&#x2F;*\n\t贪心法：\n\t1.首先对数组参数interval中的各个区间元素进行排序，下面是按照右边界升序排序的。\n\t2.选出排序后的第一个区间的右边界作为初始右边界，并初始化未重叠区间的数量。\n\t3.依次遍历数组中其他的区间元素，若遍历到的区间元素的左边界并未超过初始右边界，则表示两个区间不重叠，\n\t  则：可以将该区间加入到非重叠区间集合中，更新未重叠区间数量，更新初始右边界。\n\t4.最后遍历完成即可得到未重叠区间数量，最后获得需要删减的区间的数量作为返回值返回即可。\n*&#x2F;\nclass Solution &#123;\n    public int eraseOverlapIntervals(int[][] intervals) &#123;\n        &#x2F;&#x2F;检查参数是否合法,长度为0，则无需移除任何元素\n        if(intervals.length&#x3D;&#x3D;0)&#123;\n            return 0;\n        &#125;\n        &#x2F;&#x2F;对间隔数组进行排序，对右边界进行排序，进行升序排序，排序完成后，最靠左的元素的右边界最小\n        Arrays.sort(intervals,new Comparator&lt;int[]&gt;()&#123;\n            public int compare(int[] m,int[] n)&#123;\n                return m[1]-n[1];\n            &#125;\n        &#125;);\n        &#x2F;&#x2F;获取间隔数组的长度\n        int length&#x3D;intervals.length;\n        &#x2F;&#x2F;获取初始右边界，即具有最小右边界的元素\n        int right_bound&#x3D;intervals[0][1];\n        &#x2F;&#x2F;non_overlapping_num记录的是不重叠的间隔的数量,因为至少存在一个元素，所以初始化ans为1.\n        int non_overlapping_num&#x3D;1;\n        &#x2F;&#x2F;若找到不重叠的下一个间隔【因为这里的数组已经按照右边界进行排序了，替换的右边界是逐渐增加的】\n        for(int i&#x3D;1;i&lt;length;i++)&#123;\n            &#x2F;&#x2F;若当前间隔元素不重叠\n            if(intervals[i][0]&gt;&#x3D;right_bound)&#123;\n                non_overlapping_num++;\n                right_bound&#x3D;intervals[i][1];\n            &#125;\n        &#125;\n        &#x2F;&#x2F;数组长度减去ans（当前不重叠元素个数），得到的就是需要移除的元素的个数\n        return length-non_overlapping_num;\n\n    &#125;\n&#125;\n\n\n","slug":"NonoverlappingIntervals","date":"2022-07-25T07:05:31.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"db0cb7674f2527793ee34b531f627ef0","title":"Assign Cookies","content":"Assign Cookies题目描述：Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;&#x3D; g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\nexample1:\nInput: g &#x3D; [1,2,3], s &#x3D; [1,1]\nOutput: 1\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\nexample2:\nInput: g &#x3D; [1,2], s &#x3D; [1,2,3]\nOutput: 2\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n\n来源：力扣（LeetCode）链接：https://leetcode.cn/problems/assign-cookies\n题解：&#x2F;*排序+贪心*&#x2F;\nclass Solution &#123;\n    public int findContentChildren(int[] g, int[] s) &#123;\n        &#x2F;&#x2F;g是每个孩子需要的饼干尺寸\n        &#x2F;&#x2F;s是你有的饼干的尺寸\n        &#x2F;&#x2F;使用贪心算法，以孩子的胃口为基准，按照胃口大小从小到大进行满足。\n        Arrays.sort(s);\n        Arrays.sort(g);\n        int numberOfChildren&#x3D;g.length;\n        int numberOfCookie&#x3D;s.length;\n        int i&#x3D;0;\n        int j&#x3D;0;\n        int ret&#x3D;0;\n        \n        while(i&lt;numberOfChildren&amp;&amp;j&lt;numberOfCookie)&#123;\n            while(j&lt;numberOfCookie&amp;&amp;g[i]&gt;s[j])&#123;\n                j++;\n            &#125;\n            if(j&lt;numberOfCookie)&#123;\n                ret++;\n            &#125;\n            i++;\n            j++;\n        &#125;\n        return ret;\n    &#125;\n&#125;\n\n","slug":"Assign-Cookies","date":"2022-07-24T00:59:12.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"c37588bd65d4c5745225faacbe87ed1b","title":"平台开发所使用的前端组件工具","content":"平台开发中所使用到的Vue工具和组件vue-prism-editor1. 实现效果\n可输入代码，并且代码语法高亮\n支持编辑模式与不可编辑模式\n\n2. 使用步骤\n安装依赖\n\nnpm install vue-prism-editor\n\n\n由于vue-prism-editor需要prismjs依赖，所以需要导入prismjs依赖\n\nnpm install prismjs\n\n\n在需要使用的页面导入组件\n\nimport &#123; PrismEditor &#125; from &quot;vue-prism-editor&quot;;\nimport &quot;vue-prism-editor&#x2F;dist&#x2F;prismeditor.min.css&quot;;\nimport &#123; highlight, languages &#125; from &quot;prismjs&#x2F;components&#x2F;prism-core&quot;;\nimport &quot;prismjs&#x2F;components&#x2F;prism-clike&quot;;\nimport &quot;prismjs&#x2F;components&#x2F;prism-javascript&quot;;\nimport &quot;prismjs&#x2F;themes&#x2F;prism-tomorrow.css&quot;; \n\n\nhtml\n\n&lt;prism-editor\n   class&#x3D;&quot;my-editor height-300&quot;\n    v-model&#x3D;&quot;code&quot;\n    aria-disabled\n    :highlight&#x3D;&quot;highlighter&quot;\n    line-numbers\n    :readonly&#x3D;&quot;false&quot;\n    :tabSize&#x3D;&quot;4&quot;\n    &gt;&lt;&#x2F;prism-editor&gt;\n\n\njavascript\n\nexport default &#123;\n\t components: &#123;\n\t \t\tPrismEditor\n\t &#125;,\n\t data: () &#x3D;&gt; (&#123;\n\t \t\tcode: &#39; &#39;,\n\t &#125;),\n\t methods: &#123;\n\t\t \thighlighter(code) &#123;\n\t\t \t\treturn highlight(code, languages.js); &#x2F;&#x2F;returns html\n\t\t \t&#125;\n\t &#125;\n&#125;;\n\n\nCSS\n\n&lt;style lang&#x3D;&quot;scss&quot;&gt;\n\t.my-editor &#123;\n\t background: #2d2d2d;\n\t color: #ccc;\n\t font-family: Fira code, Fira Mono, Consolas, Menlo, Courier, monospace;\n\t font-size: 14px;\n\t line-height: 1.5;\n\t padding: 5px;\n\t&#125;\n\t\n\t.prism-editor__textarea:focus &#123;\n\t outline: none;\n\t&#125;\n\t\n\t&#x2F;* 非必须 *&#x2F;\n\t.height-300 &#123;\n\t \theight: 300px;\n\t&#125;\n&lt;&#x2F;style&gt;\n\n参考资料：https://blog.csdn.net/c_qianxia5040/article/details/124008768\nfile-saver1. 实现效果\n可以将一段字符串保存为一个文件\n\n2. 使用步骤\n安装依赖\n\nnpm install file-saver --save\n\n\n在需要使用文件保存的页面导入依赖\n\nimport &#123; saveAs &#125; from &#39;file-saver&#39;;\n\n\n保存文件demo\n\ndownloadTxt() &#123;\n    let str_file &#x3D; &#39;文件内的字符串内容&#39;\n    let strData &#x3D; new Blob([str_file], &#123; type: &#39;text&#x2F;plain;charset&#x3D;utf-8&#39; &#125;);\n    saveAs(strData, &quot;文件.py&quot;);\n&#125;,\n\n参考资料：https://wjw1014.blog.csdn.net/article/details/124320511\n","slug":"toolsInVue","date":"2022-07-22T13:14:49.000Z","categories_index":"Web前端","tags_index":"Vue,模块","author_index":"LiuQuanZe"},{"id":"7543ffbb46b57fc1881ab7a5290f7749","title":"75.颜色排序--单指针","content":"75. 颜色排序–单指针题目描述：Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library’s sort function.\nexample 1:\nInput: nums &#x3D; [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n\nexample 2:\nInput: nums &#x3D; [2,0,1]\nOutput: [0,1,2]\n\n\n\n题解：class Solution &#123;\n    public void sortColors(int[] nums) &#123;\n        int index&#x3D;0;\n        &#x2F;&#x2F;确定0的位置\n        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;\n            if(nums[i]&#x3D;&#x3D;0)&#123;\n                swap(nums,i,index++);\n            &#125;\n        &#125;\n        &#x2F;&#x2F;确定1的位置\n        for(int j&#x3D;index;j&lt;nums.length;j++)&#123;\n            if(nums[j]&#x3D;&#x3D;1)&#123;\n                swap(nums,j,index++);\n            &#125;\n        &#125;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n&#125;\n\n","slug":"75SortColors01","date":"2022-07-22T01:58:53.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"c4515973a08e01e147ab3e57422101e1","title":"Vue中localStorage的简单使用","content":"Vue中localStorage的简单使用localStorage主要作为本地存储来使用。下面记录三个主要用法：\n\n存储数据\n\nlocalStorage.setItem(&#39;key&#39;,&#39;value&#39;)\n\n\n取出数据\n\nlocalStorage.getItem(&#39;key&#39;)\n\n\n删除本地存储数据\n\nlocalStorage.removeItem(&#39;key&#39;)\n\n\n当存储的是json格式时，需要使用JSON.stringify()转化为字符串\n\n","slug":"localStorage","date":"2022-07-21T12:09:11.000Z","categories_index":"WEB前端","tags_index":"Vue","author_index":"LiuQuanZe"},{"id":"28e06c560ccb367ab8fe61d12d122120","title":"Sort Characters By Frequency_桶排序","content":"Sort Characters By Frequency——桶排序题目描述：Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.\nReturn the sorted string. If there are multiple answers, return any of them.\nexample 1:\nInput: s &#x3D; &quot;tree&quot;\nOutput: &quot;eert&quot;\nExplanation: &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.\nSo &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.\n\n\n\nexample 2:\nInput: s &#x3D; &quot;cccaaa&quot;\nOutput: &quot;aaaccc&quot;\nExplanation: Both &#39;c&#39; and &#39;a&#39; appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers.\nNote that &quot;cacaca&quot; is incorrect, as the same characters must be together.\n\n\n\n\n\n题解：class Solution &#123;\n    public String frequencySort(String s) &#123;\n        &#x2F;&#x2F;创建map存储字符及其出现次数\n        Map&lt;Character,Integer&gt; map&#x3D;new HashMap&lt;&gt;();\n        int max_frequency&#x3D;0;\n        int frequency&#x3D;0;\n        char ch&#x3D;&#39; &#39;;\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            ch&#x3D;s.charAt(i);\n            map.put(ch,map.getOrDefault(ch,0)+1);\n            max_frequency&#x3D;Math.max(max_frequency,map.get(ch));\n        &#125;\n\n        &#x2F;&#x2F;创建buckets，并初始化buckets\n        StringBuffer[] buckets&#x3D;new StringBuffer[max_frequency+1];\n        for(int i&#x3D;0;i&lt;max_frequency+1;i++)&#123;\n            buckets[i]&#x3D;new StringBuffer();\n        &#125;\n        for(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet())&#123;\n            ch&#x3D;entry.getKey();\n            frequency&#x3D;entry.getValue();\n            buckets[frequency].append(ch);\n        &#125;\n        &#x2F;&#x2F;创建返回值\n        StringBuffer ret&#x3D;new StringBuffer();\n        &#x2F;&#x2F;添加返回值\n        for(int i&#x3D;max_frequency;i&gt;&#x3D;1;i--)&#123;\n            StringBuffer bucket&#x3D;buckets[i];\n            for(int j&#x3D;0;j&lt;bucket.length();j++)&#123;\n                for(int k&#x3D;0;k&lt;i;k++)&#123;\n                    ret.append(bucket.charAt(j));\n                &#125;\n            &#125;\n\n        &#125;\n        return ret.toString();\n\n\n    &#125;\n&#125;\n\n","slug":"SortCharactersByFrequency-BucketSort","date":"2022-07-21T03:08:16.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"47c6968c5ee85e81112866938362b070","title":"Bucket Sort","content":"桶排序介绍：&#x2F;*\n桶排序是一个排序算法，工作原理是将数组分到有限数量的桶中。\n每个桶内再进行个别排序（可以使用其他不同的排序算法实现）。\n*&#x2F;\n\n基本步骤：\n设定一个基准，将待排序的数据按照一定的范围，从小到大平均分搭配N个桶中，此时，桶与桶之间已经排好序了，但是桶内是无序的。\n将桶内的元素进行排序\n将每个桶按照从小到大的编号，一次取出桶内元素，排序完成。\n\n","slug":"BucketSort","date":"2022-07-21T02:51:39.000Z","categories_index":"数据结构与算法","tags_index":"Java","author_index":"LiuQuanZe"},{"id":"95fb99a87b0934d93a7b934555997ee9","title":"Sort Characters By Frequency","content":"Sort Characters By Frequency题目描述：Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.\nReturn the sorted string. If there are multiple answers, return any of them.\nexample 1:\nInput: s &#x3D; &quot;tree&quot;\nOutput: &quot;eert&quot;\nExplanation: &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.\nSo &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.\n\n\n\nexample 2:\nInput: s &#x3D; &quot;cccaaa&quot;\nOutput: &quot;aaaccc&quot;\nExplanation: Both &#39;c&#39; and &#39;a&#39; appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers.\nNote that &quot;cacaca&quot; is incorrect, as the same characters must be together.\n\n\n\n\n\n题解：class Solution &#123;\n    public String frequencySort(String s) &#123;\n        &#x2F;&#x2F;创建map存储字符及其出现次数\n        Map&lt;Character,Integer&gt; map&#x3D;new HashMap&lt;&gt;();\n        char ch&#x3D;&#39; &#39;;\n        for(int i&#x3D;0;i&lt;s.length();i++)&#123;\n            ch&#x3D;s.charAt(i);\n            map.put(ch,map.getOrDefault(ch,0)+1);\n        &#125;\n\n        &#x2F;&#x2F;创建list列表存储字符\n        List&lt;Character&gt; list&#x3D;new ArrayList&lt;&gt;(map.keySet());\n        &#x2F;&#x2F;对list进行降序排序，根据出现次数\n        Collections.sort(list,(m,n)-&gt;map.get(n)-map.get(m));\n        &#x2F;&#x2F;创建返回值\n        StringBuffer ret&#x3D;new StringBuffer();\n        &#x2F;&#x2F;将结果存储返回值\n        for(int k&#x3D;0;k&lt;list.size();k++)&#123;\n            ch&#x3D;list.get(k);\n            int frequency&#x3D;map.get(ch);\n            for(int j&#x3D;0;j&lt;frequency;j++)&#123;\n                ret.append(ch);\n            &#125;\n        &#125;\n        return ret.toString();\n\n    &#125;\n&#125;\n\n","slug":"SortCharactersByFrequency","date":"2022-07-21T02:12:13.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"457fe231ac1330559343c50bbf83f171","title":"Top K Frequent Elements","content":"Top K Frequent Elements题目描述：Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\nexample 1:\nInput: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2\nOutput: [1,2]\n\nexample 2:\nInput: nums &#x3D; [1], k &#x3D; 1\nOutput: [1]\n\n\n\n题解：class Solution &#123;\n    public int[] topKFrequent(int[] nums, int k) &#123;\n        &#x2F;&#x2F;创建map，记录元素及其出现次数\n       Map&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;Integer,Integer&gt;();\n       for(int num:nums)&#123;\n           map.put(num,map.getOrDefault(num,0)+1);\n       &#125;\n       &#x2F;&#x2F;创建结构为小根堆的优先队列，队列元素为一个大小为2的数组，[0]表示元素，[1]表示出现次数\n       &#x2F;&#x2F;这里创建优先队列时，由于队列中的元素类型并非整型，所以需要传入比较器，规定比较规则\n       PriorityQueue&lt;int[]&gt; queue&#x3D;new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;()&#123;\n           public int compare(int[] m,int[] n)&#123;\n               return m[1]-n[1];\n           &#125;\n       &#125;);\n        &#x2F;&#x2F;将map中的键值对存入优先队列\n       for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;\n           int key&#x3D;entry.getKey();\n           int value&#x3D;entry.getValue();\n           &#x2F;&#x2F;若队列已满，则需要判断是否需要替换\n           if(k&#x3D;&#x3D;queue.size())&#123;\n               &#x2F;&#x2F;若当前元素出现次数小于堆顶元素，则表示堆内元素出现次数均大于key，则无需替换，否则需要替换堆顶元素\n               if(value&gt;queue.peek()[1])&#123;\n                   queue.poll();\n                   queue.offer(new int[]&#123;key,value&#125;);\n               &#125;\n           &#125;else&#123;   &#x2F;&#x2F;若队列元素个数小于k，则直接加入队列中\n               \n               queue.offer(new int[]&#123;key,value&#125;);\n           &#125;\n       &#125;\n       &#x2F;&#x2F;将队列中维护的元素存入ret数组并返回\n        int[] ret&#x3D;new int[k];\n       for(int i&#x3D;0;i&lt;k;i++)&#123;\n           ret[i]&#x3D;queue.poll()[0];\n       &#125;\n       return ret;\n       \n\n    &#125;\n\n\n   \n&#125;\n\n\n\n\n\n","slug":"TopKFrequentElements","date":"2022-07-21T01:11:44.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"b11e16d08ad1418b22f0f4722489b2fa","title":"Kth Largest Element in an Array——堆排序","content":"Kth Largest Element in an Array——堆排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nYou must solve it in O(n) time complexity.\n题解：class Solution &#123;\n    public int findKthLargest(int[] nums, int k) &#123;\n        &#x2F;&#x2F;堆的大小\n        int heapSize&#x3D;nums.length;\n        &#x2F;&#x2F;初始建立大根堆\n        buildMaxHeap(nums,heapSize);\n        &#x2F;&#x2F;取出堆顶元素，置换到堆底，再对置换完成的堆进行调整\n        for(int i&#x3D;nums.length-1;i&gt;&#x3D;nums.length-k+1;i--)&#123;\n            swap(nums,0,i);\n            adjustHeap(nums,0,--heapSize);\n        &#125;\n        &#x2F;&#x2F;返回第k次调整的堆顶元素\n        return nums[0];\n    &#125;\n    &#x2F;&#x2F;初始建堆\n    public void buildMaxHeap(int[] nums,int heapSize)&#123;\n        &#x2F;&#x2F;找到第一个非叶节点，不断下坠\n        for(int i&#x3D;heapSize&#x2F;2;i&gt;&#x3D;0;i--)&#123;\n            adjustHeap(nums,i,heapSize);\n        &#125;\n    &#125;\n\t&#x2F;&#x2F;堆调整\n    public void adjustHeap(int[] nums,int i,int heapSize)&#123;\n        &#x2F;&#x2F;创建指针分别指向i节点的左右孩子节点\n        int left&#x3D;i*2+1;\n        int right&#x3D;i*2+2;\n        int largest&#x3D;i;\n        &#x2F;&#x2F;通过两次判断，将largest指针指向最大节点\n        if(left&lt;heapSize&amp;&amp;nums[left]&gt;nums[largest])&#123;\n            largest&#x3D;left;\n        &#125;\n        if(right&lt;heapSize&amp;&amp;nums[right]&gt;nums[largest])&#123;\n            largest&#x3D;right;\n        &#125;\n        &#x2F;&#x2F;若不符合大根堆要求，则进行调整\n        if(largest!&#x3D;i)&#123;\n            swap(nums,largest,i);\n            adjustHeap(nums,largest,heapSize);\n        &#125;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n\n&#125;\n\n\n\n","slug":"FindKthLargest01","date":"2022-07-21T00:45:06.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"124012fd83870b9daa284761d75f9454","title":"找到第k大的元素——快速排序","content":"Kth Largest Element in an Array——快速排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nYou must solve it in O(n) time complexity.\n题解：class Solution &#123;\n    public int findKthLargest(int[] nums, int k) &#123;\n        return fastSelection(nums,0,nums.length-1,k-1);\t&#x2F;&#x2F;注意，传入的参数是nums.length-1和k-1\n    &#125;\n\t&#x2F;&#x2F;快速排序，递归\n    public int fastSelection(int[] nums,int start,int end,int kth)&#123;\n        &#x2F;&#x2F;划分并确定一个元素的位置\n        int cur&#x3D;partition(nums,start,end);\n        &#x2F;&#x2F;若为第k个元素，则直接返回\n        if(cur&#x3D;&#x3D;kth)&#123;\n            return nums[cur];\n        &#125;else if(cur&lt;kth)&#123;\t\t&#x2F;&#x2F;否则对右边区域进行划分\n            return fastSelection(nums,cur+1,end,kth);\n        &#125;else&#123;\t\t\t\t&#x2F;&#x2F;对左边区域进行划分\n            return fastSelection(nums,start,cur-1,kth);\n        &#125;\n    &#125;\n\t&#x2F;&#x2F;划分区间\n    public int partition(int[] nums,int start,int end)&#123;\n       \t &#x2F;&#x2F;随机选择枢轴元素\n        int pivot&#x3D;start+(int)(Math.random()*(end-start+1));\n        &#x2F;&#x2F;将枢轴元素调换至右边界\n        swap(nums,pivot,end);\n        &#x2F;&#x2F;双指针index和i用于进行划分，确定枢轴元素的最终位置\n        int index&#x3D;start-1;\n        for(int i&#x3D;start;i&lt;end;i++)&#123;\n            if(nums[i]&gt;nums[end])&#123;\n                swap(nums,i,++index);\n            &#125;\n        &#125;\n        swap(nums,++index,end);\n        return index;\n    &#125;\n\n    public void swap(int[] nums,int left,int right)&#123;\n        int temp&#x3D;nums[left];\n        nums[left]&#x3D;nums[right];\n        nums[right]&#x3D;temp;\n    &#125;\n\n&#125;\n\n\n\n","slug":"FindKthLargest","date":"2022-07-21T00:24:42.000Z","categories_index":"数据结构与算法","tags_index":"Java,leetcode","author_index":"LiuQuanZe"},{"id":"2233f52546249f8733475a932932ac4d","title":"PriorityQueue的简单使用","content":"Java中的优先队列Java中的PriorityQueue默认是小顶堆，逻辑上是堆，物理上是数组，每次取出的元素是最小的。【可以通过比较器的方式传入不同的比较规则】\n特点：\n实现了Queue接口\n不允许放入null元素\n插入方法：\nadd()和offer(),前者插入失败抛出异常，后者插入失败返回false。\n\n\n获取堆顶元素：\nelement()和peek():都是获取堆顶元素，前者获取失败抛出异常，后者返回null\n\n\n获取并删除队首元素：\nremove()和poll()都是获取并删除队首元素，前者失败抛出异常，后者失败返回null。\n\n\n\n构造：\n构造小顶堆\n\nPriorityQueue small&#x3D;new PriorityQueue&lt;&gt;();\n\n\n构造大顶堆\n\nPriorityQueue big&#x3D;new PriorityQueue&lt;&gt;(Collections.reverseOrder());\n&#x2F;&#x2F;使用比较器构造大顶堆\nPriorityQueue&lt;int[]&gt; queue&#x3D;new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123;\n\tpublic int compare(int[] m, int[] n) &#123;\n\t\treturn m[1] - n[1];\n\t&#125;\n&#125;);\n   \n","slug":"PriorityQueue_SimpleUse","date":"2022-07-20T03:10:24.000Z","categories_index":"","tags_index":"Java,数据结构","author_index":"LiuQuanZe"},{"id":"0147aaa7b5bc889d40916e1f2d1d947a","title":"Hexo添加标签和分类","content":"如何在Hexo中添加分类和标签？分类：\n创建分类选项：\n生成【分类页】，并添加type属性\n\n\n\nhexo new page categories\n\n\n执行成功：\n\nINFO  Created: H:\\blog\\source\\categories\\index.md\n\n\n根据上述路径，找到index.md,添加type和layout：\n\ntitle: categories\ndate: 2022-07-19 16:16:46\ntype: &quot;categories&quot;\nlayout: &quot;categories&quot;\n\n\n保存并关闭index.md\n使用categories：\n\ntitle: Console失效\ndate: 2022-07-19 16:02:42\ncategories: \n- web前端\ntags:\n- Vue\n- 报错\n\n\n\n标签：\n创建标签选项：\n生成【标签页】，并添加type属性\n\n\n\nhexo new page tags\n\n\n执行成功：\n\nINFO  Created: H:\\blog\\source\\tags\\index.md\n\n\n根据上述路径，找到index.md,添加type和layout：\n\ntitle: 文章分类\ndate: 2022-01-07 22:53:43\ntype: &quot;tags&quot;\nlayout: &quot;tags&quot;\n\n\n保存并关闭index.md\n使用tags：\n\ntitle: Console失效\ndate: 2022-07-19 16:02:42\ncategories: \n- web前端\ntags:\n- Vue\n- 报错\n\n\n\n\n\n\n\n","slug":"HexoTagsAndCategories","date":"2022-07-19T08:18:19.000Z","categories_index":"个人博客","tags_index":"Hexo,使用说明","author_index":"LiuQuanZe"},{"id":"85d7f0ee0105da9c47f8cfa58c2659ee","title":"Console失效","content":"console.log()失效问题描述：当使用console.log()想要打印到控制台时，发现idea出现下滑红线，并且num run serve也通不过。\n错误信息：ESLint: Unexpected console statement.(no-console)\n\n\n\n解决办法：进行简单的配置即可：\n在package.json的eslintConfig:{}中的”rules”:{}，增加一行代码【”no-console”: “off”】\n&quot;rules&quot;: &#123;\n  &quot;no-console&quot;:&quot;off&quot;\n&#125;,\n\n","slug":"CannotUseConsole","date":"2022-07-19T08:02:42.000Z","categories_index":"web前端","tags_index":"Vue,报错","author_index":"LiuQuanZe"},{"id":"ea91dec26a5ee2422c404ab47e32c3f7","title":"Ryu的Rest API初体验","content":"ryu.app.ofctl_restryu.app.ofctl_rest provides REST APIs for retrieving the switch stats and Updating the switch stats. This application helps you debug your application and get various statistics.\n【其实就是ryu自己提供的一个应用程序，提供了获取交换机状态以及更新交换机状态的REST APIs。该应用可以帮助我们debug自己创建的应用并获取各种统计数据】\n \n\n\n\n\nThis application supports OpenFlow version 1.0, 1.2, 1.3, 1.4 and 1.5.\n【支持OpenFlow版本 1.0 1.2 1.3 1.4和1.5】\n使用\n将ofctl_rest和simple_switch_13.py一起启动\n\n\n\n启动拓扑\n\n\n\n另起一个终端，进行请求发送，测试接口\n\n\n\n其余接口尚未测试，该接口响应成功，响应结果是否正确要看具体实验情况。\n\n【注】使用的是python3，则需要修改ofctl_rest源码：\n\n第133行：\n\n#原本\nbody&#x3D;json.dumps(dps)\n#改为\nbody &#x3D; json.dumps(list(dps)).encode(&quot;utf-8&quot;)\n\n\n若是python2，则应该不需要修改，运行时不会报错\n\n","slug":"ofctlrest","date":"2022-07-18T03:52:22.000Z","categories_index":"SDN","tags_index":"使用方法,科研","author_index":"LiuQuanZe"}]