<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>Tag: 二叉树 - Hexo</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">





    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


<meta name="generator" content="Hexo 6.2.0"></head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">Archives</a>
            
            <a class="navbar-item "
               href="/categories/Music">Music</a>
            
            <a class="navbar-item "
               href="/categories/Technology">Technology</a>
            
            <a class="navbar-item "
               href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" target="_blank" rel="noopener" href="https://github.com/liuquanze">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section section-heading">
    <div class="container">
        <div class="content">
            <h5>#二叉树</h5>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/post/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html" itemprop="url">700.二叉搜索树中的搜索</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-10-06T01:18:40.000Z" itemprop="datePublished">Oct 6 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 minutes read (About 234 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="700">
<li>二叉搜索树中的搜索</li>
</ol>
<p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p>
<p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p>
<p>example 1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2
输出：[2,1,3]</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5
输出：[]</code></pre>

<p>提示：</p>
<ul>
<li>数中节点数在 <code>[1, 5000]</code> 范围内</li>
<li><code>1 &lt;= Node.val &lt;= 107</code></li>
<li><code>root</code> 是二叉搜索树</li>
<li><code>1 &lt;= val &lt;= 107</code></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">https://leetcode.cn/problems/search-in-a-binary-search-tree/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public TreeNode findTree(TreeNode node,int val)&#123;
        if(node&#x3D;&#x3D;null)
            return null;
        if(node.val&#x3D;&#x3D;val)
            return node;
        if(node.val&lt;val)&#123;
            return findTree(node.right,val);
        &#125;
        return findTree(node.left,val);
    &#125;

    public TreeNode searchBST(TreeNode root, int val) &#123;
        return findTree(root,val);
    &#125;
&#125;</code></pre>


    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/post/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html" itemprop="url">617.合并二叉树</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-10-05T01:34:50.000Z" itemprop="datePublished">Oct 5 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 minutes read (About 364 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="617">
<li>合并二叉树</li>
</ol>
<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root1 &#x3D; [1], root2 &#x3D; [1,2]
输出：[2,2]</code></pre>

<p>提示：</p>
<ul>
<li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public TreeNode buildTree(TreeNode node1,TreeNode node2)&#123;
        if(node1&#x3D;&#x3D;null&amp;&amp;node2&#x3D;&#x3D;null)
            return null;
        TreeNode node;
        if(node1&#x3D;&#x3D;null&amp;&amp;node2!&#x3D;null)&#123;
            &#x2F;&#x2F;若node1为空，则构造出的树和node2相同，直接返回node2
            return node2;
        &#125;else if(node1!&#x3D;null&amp;&amp;node2&#x3D;&#x3D;null)&#123;
            return node1;
        &#125;else&#123;
            node&#x3D;new TreeNode(node1.val+node2.val);
        
            node.left&#x3D;buildTree(node1.left,node2.left);
            node.right&#x3D;buildTree(node1.right,node2.right);
        &#125;
        return node;
    &#125;

    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;
        return buildTree(root1,root2);
    &#125;
&#125;</code></pre>


    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/post/654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html" itemprop="url">654.最大二叉树</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-10-04T01:34:03.000Z" itemprop="datePublished">Oct 4 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 minutes read (About 519 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="654">
<li>最大二叉树</li>
</ol>
<p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p>
<ol>
<li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li>
<li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li>
<li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li>
</ol>
<p>返回 <em><code>nums</code> 构建的</em> *<strong>最大二叉树*</strong> 。</p>
<p>example 1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums &#x3D; [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：nums &#x3D; [3,2,1]
输出：[3,null,2,null,1]</code></pre>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree">https://leetcode.cn/problems/maximum-binary-tree</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    &#x2F;&#x2F;递归函数
    public TreeNode buildTree(int[] nums,int start,int end)&#123;
        &#x2F;&#x2F;若超出范围，则表示没有节点，则返回null
        if(start&gt;&#x3D;end)&#123;
            return null;
        &#125;
        &#x2F;&#x2F;循环找出当前数组范围内的最大值及其下标
        int max&#x3D;-1;
        int index_max&#x3D;-1;
        for(int i&#x3D;start;i&lt;end;i++)&#123;
            if(nums[i]&gt;max)&#123;
                max&#x3D;nums[i];
                index_max&#x3D;i;
            &#125;
        &#125;
        &#x2F;&#x2F;构造节点
        TreeNode node&#x3D;new TreeNode(max);
        &#x2F;&#x2F;递归构造左子树，注意传入的区间参数，左闭右开
        node.left&#x3D;buildTree(nums,start,index_max);
        &#x2F;&#x2F;左闭右开
        node.right&#x3D;buildTree(nums,index_max+1,end);
        return node;
    &#125;

    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;
        if(nums&#x3D;&#x3D;null)
            return null;
        &#x2F;&#x2F;左闭右开
        return buildTree(nums,0,nums.length);
    &#125;
&#125;</code></pre>


    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/post/106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html" itemprop="url">106. 从中序与后序遍历序列构造二叉树</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-10-03T12:53:13.000Z" itemprop="datePublished">Oct 3 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 minutes read (About 505 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h2><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="106">
<li>从中序与后序遍历序列构造二叉树</li>
</ol>
<p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：inorder &#x3D; [-1], postorder &#x3D; [-1]
输出：[-1]</code></pre>

<p>提示：</p>
<p>1 &lt;&#x3D; inorder.length &lt;&#x3D; 3000<br>postorder.length &#x3D;&#x3D; inorder.length<br>-3000 &lt;&#x3D; inorder[i], postorder[i] &lt;&#x3D; 3000<br>inorder 和 postorder 都由 不同 的值组成<br>postorder 中每一个值都在 inorder 中<br>inorder 保证是树的中序遍历<br>postorder 保证是树的后序遍历</p>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
 
 class Solution &#123;
     &#x2F;&#x2F;为了更加方便的找到中序序列中节点下标
    Map&lt;Integer, Integer&gt; map;  &#x2F;&#x2F; 方便根据数值查找位置
    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;
        map &#x3D; new HashMap&lt;&gt;();
        &#x2F;&#x2F;将中序序列存入map，key为节点val，value为节点val所在的下标
        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置
            map.put(inorder[i], i);
        &#125;
        &#x2F;&#x2F;注意，右边界是数组长度，是最后一个元素下标的后一个位置    
        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  &#x2F;&#x2F; 前闭后开
    &#125;
    
    
    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) &#123;
        &#x2F;&#x2F; 参数里的范围都是前闭后开
        if (inBegin &gt;&#x3D; inEnd || postBegin &gt;&#x3D; postEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树
            return null;
        &#125;
        
        int rootIndex &#x3D; map.get(postorder[postEnd - 1]);  &#x2F;&#x2F; 找到后序遍历的最后一个元素在中序遍历中的位置
        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点
        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定后序数列的个数
        &#x2F;&#x2F;递归构造左子树
        root.left &#x3D; findNode(inorder, inBegin, rootIndex,
                            postorder, postBegin, postBegin + lenOfLeft);
        &#x2F;&#x2F;递归构造右子树
        root.right &#x3D; findNode(inorder, rootIndex + 1, inEnd,
                            postorder, postBegin + lenOfLeft, postEnd - 1);

        return root;
    &#125;
&#125;</code></pre>


    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/post/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html" itemprop="url">105. 从前序与中序遍历序列构造二叉树</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-10-03T12:52:58.000Z" itemprop="datePublished">Oct 3 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 minutes read (About 409 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="105">
<li>从前序与中序遍历序列构造二叉树</li>
</ol>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: preorder &#x3D; [-1], inorder &#x3D; [-1]
输出: [-1]</code></pre>

<p>提示：</p>
<p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    Map&lt;Integer, Integer&gt; map;
    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;
        map &#x3D; new HashMap&lt;&gt;();
        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置
            map.put(inorder[i], i);
        &#125;

        return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);  &#x2F;&#x2F; 前闭后开
    &#125;

    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) &#123;
        &#x2F;&#x2F; 参数里的范围都是前闭后开
        if (preBegin &gt;&#x3D; preEnd || inBegin &gt;&#x3D; inEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树
            return null;
        &#125;
        int rootIndex &#x3D; map.get(preorder[preBegin]);  &#x2F;&#x2F; 找到前序遍历的第一个元素在中序遍历中的位置
        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点
        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定前序数列的个数
        root.left &#x3D; findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,  
                            inorder, inBegin, rootIndex);
        root.right &#x3D; findNode(preorder, preBegin + lenOfLeft + 1, preEnd,
                            inorder, rootIndex + 1, inEnd);

        return root;
    &#125;
&#125;</code></pre>


    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/post/112-%E8%B7%AF%E5%BE%84%E7%BB%BC%E5%90%88.html" itemprop="url">112.路径综合</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-10-01T15:19:03.000Z" itemprop="datePublished">Oct 1 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            4 minutes read (About 637 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="112-路径综合"><a href="#112-路径综合" class="headerlink" title="112.路径综合"></a>112.路径综合</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="112">
<li>路径总和</li>
</ol>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --&gt; 2): 和为 3
(1 --&gt; 3): 和为 4
不存在 sum &#x3D; 5 的根节点到叶子节点的路径。</code></pre>

<p>example 3:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [], targetSum &#x3D; 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。</code></pre>

<p>提示：</p>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum">https://leetcode.cn/problems/path-sum</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    &#x2F;&#x2F;递归，传入三个参数，第一个是当前节点，一个是从根节点到当前节点的父节点路径上的val之和，targetNum是目标路径上的节点val之和
    public boolean traverse(TreeNode node,int count,int targetSum)&#123;
        &#x2F;&#x2F;加上当前节点的val，表示根节点到当前节点这条路径上的所有节点的val之和
        count+&#x3D;node.val;
        &#x2F;&#x2F;如果当前节点是叶子节点，则判断当前路径节点的val之和是否等于目标路径的节点val之和，如果等于，则返回true，否则返回false
        if(node.left&#x3D;&#x3D;null&amp;&amp;node.right&#x3D;&#x3D;null)&#123;
            if(count&#x3D;&#x3D;targetSum)&#123;
                return true;
            &#125;else&#123;
                return false;
            &#125;
        &#125;
        &#x2F;&#x2F;如果当前节点不是叶子节点，则分别判断左右子树中是否存在目标路径，下面两个变量分别存储左右子树是否存在目标路径
        boolean left&#x3D;false;
        boolean right&#x3D;false;
        &#x2F;&#x2F;若左子树非空，则对左子树进行递归
        if(node.left!&#x3D;null)&#123;
            left&#x3D;traverse(node.left,count,targetSum);
        &#125;
        &#x2F;&#x2F;对右子树进行递归
        if(node.right!&#x3D;null)&#123;
            right&#x3D;traverse(node.right,count,targetSum);
        &#125;
        &#x2F;&#x2F;当左子树或者右子树中存在一条目标路径则表示该树存在目标路径，这里使用||
        return left||right;

    &#125;

    public boolean hasPathSum(TreeNode root, int targetSum) &#123;
        if(root&#x3D;&#x3D;null)
            return false;
        return traverse(root,0,targetSum);
    &#125;
&#125;</code></pre>


    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/post/513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html" itemprop="url">513.找树左下角的值</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-09-30T15:03:56.000Z" itemprop="datePublished">Sep 30 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 minutes read (About 240 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="513">
<li>找树左下角的值</li>
</ol>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p>example 1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: root &#x3D; [2,1,3]
输出: 1</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7</code></pre>

<p>提示：</p>
<ul>
<li>二叉树的节点个数的范围是 <code>[1,104]</code></li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<p>题目来源：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public int findBottomLeftValue(TreeNode root) &#123;
        if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)&#123;
            return root.val;
        &#125;
        int[] deepest&#x3D;new int[2];
        
        deepest[0]&#x3D;0;
        deepest[1]&#x3D;0;
        findAllLeftLeaf(root,deepest,1);
        return deepest[1];
    &#125;
    public void findAllLeftLeaf(TreeNode root,int[] deepest,int depth)&#123;
        if(root&#x3D;&#x3D;null)
            return ;
        if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)
            return ;
        if(root.left!&#x3D;null&amp;&amp;root.left.left&#x3D;&#x3D;null&amp;&amp;root.left.right&#x3D;&#x3D;null)&#123;
            &#x2F;&#x2F;若深度更深
            if(depth+1&gt;deepest[0])&#123;
                deepest[0]&#x3D;depth+1;
                deepest[1]&#x3D;root.left.val;
            &#125;
        &#125;
        findAllLeftLeaf(root.left,deepest,depth+1);
        findAllLeftLeaf(root.right,deepest,depth+1);

            
    &#125;
&#125;</code></pre>


    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/post/404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html" itemprop="url">404.左叶子之和</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-09-30T14:44:06.000Z" itemprop="datePublished">Sep 30 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 minutes read (About 280 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="404">
<li>左叶子之和</li>
</ol>
<p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p>
<p>example 1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: root &#x3D; [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入: root &#x3D; [1]
输出: 0</code></pre>

<p>提示：</p>
<ul>
<li>节点数在 <code>[1, 1000]</code> 范围内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves">https://leetcode.cn/problems/sum-of-left-leaves</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public int sumOfLeftLeaves(TreeNode root) &#123;
        &#x2F;&#x2F;若当前节点为空，则返回0
        if(root&#x3D;&#x3D;null)
            return 0;
        &#x2F;&#x2F;若当前节点为叶子节点，则返回0
        if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)
            return 0;
        &#x2F;&#x2F;记录左子树的所有叶子节点的值
        int leftValue&#x3D;0;
        &#x2F;&#x2F;如果左孩子节点就是叶子节点，则leftValue就是左孩子节点的值
        if(root.left!&#x3D;null&amp;&amp;root.left.left&#x3D;&#x3D;null&amp;&amp;root.left.right&#x3D;&#x3D;null)
            leftValue&#x3D;root.left.val;
        &#x2F;&#x2F;返回当前节点左子树和右子树的所有左叶子节点的值之和
        return leftValue+sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right);
    &#125;
&#125;</code></pre>


    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/post/257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html" itemprop="url">257.二叉树的所有路径</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-09-29T13:48:25.000Z" itemprop="datePublished">Sep 29 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            3 minutes read (About 477 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="257">
<li>二叉树的所有路径</li>
</ol>
<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [1,2,3,null,5]
输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [1]
输出：[&quot;1&quot;]</code></pre>

<p>提示：</p>
<ul>
<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;

    &#x2F;&#x2F;递归+回溯的方法
    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;
        &#x2F;&#x2F;创建结果列表，列表元素是字符串，字符串表示的是路径
        List&lt;String&gt; result&#x3D;new ArrayList&lt;&gt;();
        if(root&#x3D;&#x3D;null)
            return result;
        &#x2F;&#x2F;用于存储路径，列表元素是整型变量，变量表示的是每一个节点的值
        List&lt;Integer&gt; paths&#x3D;new ArrayList&lt;&gt;();
        &#x2F;&#x2F;进行递归和回溯
        traverse(root,paths,result);
        &#x2F;&#x2F;返回搜索的路径结果
        return result;
    &#125;

    public void traverse(TreeNode node,List&lt;Integer&gt; paths,List&lt;String&gt; result)&#123;
        &#x2F;&#x2F;将该节点加入路径
        paths.add(node.val);

        &#x2F;&#x2F;判断是否为叶子节点，如果是叶子节点，则将paths列表转化为路径字符串，并加入到result中，并返回
        if(node.left&#x3D;&#x3D;null&amp;&amp;node.right&#x3D;&#x3D;null)&#123;
            StringBuffer temp&#x3D;new StringBuffer();
            for(int i&#x3D;0;i&lt;paths.size()-1;i++)&#123;
                temp.append(paths.get(i)).append(&quot;-&gt;&quot;);
            &#125;
            temp.append(paths.get(paths.size()-1));
            result.add(temp.toString());
            return;
        &#125;
        &#x2F;&#x2F;如果该节点存在左孩子，则将左孩子进行递归
        &#x2F;&#x2F;注意，这里需要将paths列表的最后一个元素弹出，
        &#x2F;&#x2F;若该元素的左孩子就是叶子节点，则paths最后一个元素就是左孩子节点，因为后续要继续寻找路径，所以这里的叶节点需要弹出。
        if(node.left!&#x3D;null)&#123;
            traverse(node.left,paths,result);
            paths.remove(paths.size()-1);
        &#125;
        if(node.right!&#x3D;null)&#123;
            traverse(node.right,paths,result);
            paths.remove(paths.size()-1);
        &#125;
    &#125;
&#125;</code></pre>


    
    </div>
    
    
</article>




    
        <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            <a href="/post/110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html" itemprop="url">110.平衡二叉树</a>
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2022-09-27T14:53:38.000Z" itemprop="datePublished">Sep 27 2022</time>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            2 minutes read (About 331 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ol start="110">
<li>平衡二叉树</li>
</ol>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote>
<p>example 1:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [3,9,20,null,null,15,7]
输出：true</code></pre>

<p>example 2:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]
输出：false</code></pre>

<p>example 3:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：root &#x3D; []
输出：true</code></pre>

<p>提示：</p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public int is_balanced(TreeNode node)&#123;
        &#x2F;&#x2F;若节点为空，则返回高度为0
        if(node&#x3D;&#x3D;null)
            return 0;
        &#x2F;&#x2F;左子树高度，并检查是否左子树是否平衡
        int left_depth&#x3D;is_balanced(node.left);
        if(left_depth&#x3D;&#x3D;-1)  return -1;
        &#x2F;&#x2F;右子树高度，并检查是否右子树是否平衡
        int right_depth&#x3D;is_balanced(node.right);
        if(right_depth&#x3D;&#x3D;-1) return -1;
        &#x2F;&#x2F;如果左子树和右子树高度差大于1，则不平衡，若平衡，则返回当前节点为根节点的树高度
        return Math.abs(left_depth-right_depth)&gt;1?-1:1+Math.max(right_depth,left_depth);
    &#125;

    public boolean isBalanced(TreeNode root) &#123;
        return is_balanced(root)&#x3D;&#x3D;-1?false:true;
    &#125;
&#125;</code></pre>


    
    </div>
    
    
</article>




    
    
        
<nav class="pagination is-centered is-rounded" role="navigation" aria-label="pagination">
    <div class="pagination-previous">
        <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">Prev</a>
    </div>
    <div class="pagination-next">
        <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/page/3/">Next</a>
    </div>
    <ul class="pagination-list is-hidden-mobile">
        
        <li><a class="pagination-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">1</a></li>
        
        <li><a class="pagination-link is-current" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/page/2/">2</a></li>
        
        <li><a class="pagination-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/page/3/">3</a></li>
        
    </ul>
</nav>
    
    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2023 John Doe&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("en-AU");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery > p > .gallery-item').unwrap();
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="/js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="/js/insight.js"></script>

    
</body>
</html>