{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"打招呼！","text":"Hello, I’am LiuQuanZe! (｡･∀･)ﾉﾞWelcome to my blog！( ＾∀＾）／欢迎＼( ＾∀＾）","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"01 bag","text":"01背包问题题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？ 每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。 所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！ 题解：public class bag01 { public static void main(String[] args) { //物品重量 int[] weight = {1, 3, 4}; //物品价值 int[] value = {15, 20, 30}; //背包大小 int bagsize = 4; testweightbagproblem(weight, value, bagsize); } public static void testweightbagproblem(int[] weight, int[] value, int bagsize){ //创建dp数组 int[][] dp=new int[weight.length][bagsize+1]; //对dp数组进行初始化 /* * 对dp数组的第一行进行初始化，dp[i][j]表示的是容量为j的背包，前i个物品能获得的最大价值 * 第一行是指将第0个物品放入不同的容量0~bagsize的背包的最大价值，其实也就是看第0个物品可不可以放入背包中，如果可以则将dp[0][j]设置为value[0]即可 * ，若j&lt;weight[0]则表示第0个物品放不进容量为j的背包，则容量为j的背包的价值只能是0，所以下方的j从weight[0]开始遍历，因为j&lt;weight[0]时，dp[0][j]=0 * */ for(int j=weight[0];j&lt;=bagsize;j++){ dp[0][j]=value[0]; } //状态转换公式 /* * 先遍历物品i=1;i&lt;=weight.length，再遍历背包容量j=1;j&lt;=bagsize * 1.当背包容量小于当前的物品的重量j&lt;weight[i]时,表示物品i无法放进此时容量为j的背包，所以dp[i][j]：容量为j的背包在i个物品中所能获得的最大价值等于容量为j的背包 * 在i-1个物品中所能获得的最大价值；也就是不放入第i个物品的最大价值（因为背包容量不够嘛） * 2.当背包容量大于等于当前物品的重量j&gt;=weight[i]时，表示物品可以放进此时容量为j的背包，因此出现两种选择： * （1）将物品i放进背包 * （2）不将物品i放进背包， * 至于选择放还是不放，就需要分别计算放入物品i和不放入物品i的背包的价值并选择能使背包价值最大化的方式（通俗的说，放入i和不放入i，谁能使背包的价值大，就选谁） * 所以dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-weight[i]+value[i]]) * 注：这里的dp[i-1][j-weight[i]表示的是容量为j-weight[j]的背包在0~i-1所能获得最大价值，之所以j-weight[j]就是要预留出物品i的空间，所以p[i-1][j-weight[i]也可以说是为物品i * 预留出背包空间后的最大可以获得的价值，再然后加上value[i]就可以得到放入物品i后，容量为j的背包所能获得的最大价值。 * * 重新梳理： * （1）如果物品i可以放入背包（背包容量允许），则分别比较物品放入前后的背包价值，选取最大值 * （2）若物品i不可以放入背包（背包容量不允许），则选择不放入i时的最大价值。 * */ for(int i=1;i&lt;weight.length;i++){ for(int j=1;j&lt;=bagsize;j++){ if(j&lt;weight[i-1]){ dp[i][j]=dp[i-1][j]; }else{ dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-weight[i-1]]+value[i-1]); } } } //输出dp数组查看运行结果 for (int i=0;i&lt;weight.length;i++){ for(int j=0;j&lt;=bagsize;j++){ System.out.printf(dp[i][j]+&quot; &quot;); } System.out.printf(&quot;\\n&quot;); } } }","link":"/post/01-bag.html"},{"title":"01背包理论基础01","text":"01背包理论基础01题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 确定dp数组以及下标的含义 对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 确定递推公式 再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 那么可以有两个方向推出来dp[i][j]， 不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。) 放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值 所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); dp数组如何初始化 状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。 dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。 那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。 当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。 确定遍历顺序 那么问题来了，先遍历 物品还是先遍历背包重量呢？ 其实都可以！！ 但是先遍历物品更好理解。 那么我先给出先遍历物品，然后遍历背包重量的代码。 题解：public int 01bag(int[] weight,int[] value,int bagsize){ //创建dp数组 int goods=weight.length;//获取物品的数量 int[][] dp=new int[goods][bagSize+1]; //初始化dp数组 //创建数组后，初始值均为0，dp[0][j]=value[0],其中j&gt;=weight[0] for(int j=weight[0];j&lt;=bagSize;j++){ dp[0][j]=value[0]; } //填充dp数组,先遍历物品再遍历背包容量 for(int i=0;i&lt;weight.length;i++){ for(int j=1;j&lt;=bagSize;j++){ //如果当前遍历的背包容量小于当前物品重量，表示根本放不下物品i，则前i-1个物品能放下的最大价值就是当前情况下的最大价值 if(j&lt;weight[i]){ dp[i][j]=dp[i-1][j]; }else{ //如果可以放下，则在两种情况下取最大值 dp[j][j]=Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]); } } } return dp[goods-1][bagSize]; }","link":"/post/01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001.html"},{"title":"01背包理论基础02","text":"01背包理论基础02题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 背包问题（一维数组d实现，滚动数组）对于背包问题其实状态都是可以压缩的。 在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]); 与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。 这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。 读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。 dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 确定dp数组的定义 在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。 一维dp数组的递推公式 dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？ dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。 dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]） 此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值， 所以递归公式为： dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 可以看出相对于二维dp数组的写法，就是把dp[i] [j]中i的维度去掉了。 一维dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。 那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？ 看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。 一维dp数组遍历顺序 for(int i=0;i&lt;weight.size();i++){ for(int j=bagWeight;j&gt;=weight[i];j--){ dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]); } } 注意两点： 背包容量从大到小遍历：因为如果是从小到大遍历，则一件物品会被放入多次，从大到小遍历可以避免这个问题。 先遍历物品再遍历背包：如果先遍历背包再遍历物品，则会导致背包最多只能放入一个物品，先遍历物品再遍历背包可以避免这个问题 题解：public int test(int[] weight,int[] value,int bagSize){ int length=weight.length; //定义dp数组，采用滚动数组实现，其中dp[i]表示背包容量为i时放入物品的最大价值 int[] dp=new int[bagSize+1]; for(int i=0;i&lt;length;i++){ for(int j=bagSize;j&gt;=weight[i];j--){ dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]); } } return dp[bagSize]; }","link":"/post/01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8002.html"},{"title":"05.替换空格","text":"05.替换空格题目描述：剑指 Offer 05. 替换空格 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 example 1: 输入：s = &quot;We are happy.&quot; 输出：&quot;We%20are%20happy.&quot; 提示： 0 &lt;= s 的长度 &lt;= 10000 题目来源：https://leetcode.cn/problems/ti-huan-kong-ge-lcof/ 题解：//常规方法：从前向后遍历，遇到空格则替换为&quot;02%&quot;，可以使用StringBuilder实现，但是每次替换，后面的字符串需要向后移动 //使用一个新的对象，复制 str，复制的过程对其判断，是空格则替换，否则直接复制，类似于数组复制 public static String replaceSpace(StringBuffer str) { if (str == null) { return null; } //选用 StringBuilder 单线程使用，比较快，选不选都行 StringBuilder sb = new StringBuilder(); //使用 sb 逐个复制 str ，碰到空格则替换，否则直接复制 for (int i = 0; i &lt; str.length(); i++) { //str.charAt(i) 为 char 类型，为了比较需要将其转为和 &quot; &quot; 相同的字符串类型 //if (&quot; &quot;.equals(String.valueOf(str.charAt(i)))){ if (s.charAt(i) == ' ') { sb.append(&quot;%20&quot;); } else { sb.append(str.charAt(i)); } } return sb.toString(); } //从后向前遍历，使用双指针的方法进行实现，速度更快beat 100% class Solution { public String replaceSpace(String s) { //判断参数是否合法 if(s.length()==0||s==null){ return s; } //拼接字符串 StringBuilder tail=new StringBuilder(); //每遍历到一个空格，拼接字符串扩大两个空格大小 for(int i=0;i&lt;s.length();i++){ if(s.charAt(i)==' '){ tail.append(&quot; &quot;); } } //若不存在空格，则直接返回 if(tail.length()==0){ return s; } //记录左右指针 int left=s.length()-1; s+=tail; int right=s.length()-1; char[] chars=s.toCharArray(); //左指针i从后向前遍历 while(left&gt;=0){ if(chars[left]==' '){ chars[right--]='0'; chars[right--]='2'; chars[right]='%'; }else{ chars[right]=chars[left]; } left--; right--; } return new String(chars); } }","link":"/post/05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html"},{"title":"1005.K次取反后最大化的数组和","text":"1005.K次取反后最大化的数组和题目描述： K 次取反后最大化的数组和 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组： 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。 以这种方式修改数组后，返回数组 可能的最大和 。 example 1： 输入：nums = [4,2,3], k = 1 输出：5 解释：选择下标 1 ，nums 变为 [4,-2,3] 。 example 2: 输入：nums = [3,-1,0,2], k = 3 输出：6 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。 example 3: 输入：nums = [2,-3,-1,5,-4], k = 2 输出：13 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。 提示： 1 &lt;= nums.length &lt;= 104 -100 &lt;= nums[i] &lt;= 100 1 &lt;= k &lt;= 104 题目来源：https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/ 题解：class Solution { public int largestSumAfterKNegations(int[] nums, int K) { //首先将最小的负数转为正数，即可实现数据组之和最大，若所有的数已经变为正数后，k依旧大于0，则将最小的正数变为负数，此时可以获得数组之和的最大值 // 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小 nums = IntStream.of(nums) .boxed() .sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1)) .mapToInt(Integer::intValue).toArray(); int len = nums.length; for (int i = 0; i &lt; len; i++) { //从前向后遍历，遇到负数将其变为正数，同时K-- if (nums[i] &lt; 0 &amp;&amp; K &gt; 0) { nums[i] = -nums[i]; K--; } } // 如果K还大于0，那么反复转变数值最小的元素，将K用完 if (K % 2 == 1) nums[len - 1] = -nums[len - 1]; return Arrays.stream(nums).sum(); } }","link":"/post/1005-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html"},{"title":"101.对称二叉树","text":"101.对称二叉树题目描述：example 1： 1 | | 2 2 | | | | 3 4 4 3 输入：root = [1,2,2,3,4,4,3] 输出：true example 2: 1 | | 2 2 | | 3 3 输入：root = [1,2,2,null,3,null,3] 输出：false 提示： 树中节点数目在范围 [1, 1000] 内 -100 &lt;= Node.val &lt;= 100 题目来源：https://leetcode.cn/problems/symmetric-tree/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSymmetric(TreeNode root) { return check(root.left,root.right); } public boolean check(TreeNode left,TreeNode right){ //当一个空，一个不空，则不对称 if(left==null&amp;&amp;right!=null) return false; if(left!=null&amp;&amp;right==null) return false; //若两个都为空，则对称 if(left==null&amp;&amp;right==null) return true; //若两个值不一致，则不对称 if(left.val!=right.val) return false; //若两个值一致，继续判断下一层节点是否对称 boolean left_check=check(left.left,right.right); boolean right_check=check(left.right,right.left); //仅当下层所有的节点都对称时，才对称，否则都不对称 return left_check&amp;&amp;right_check; } }","link":"/post/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{"title":"102二叉树的层次遍历","text":"102.二叉树的层次遍历题目描述： 二叉树的层序遍历 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 example 1: 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] example 2: 输入：root = [1] 输出：[[1]] example 3: 输入：root = [] 输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 &lt;= Node.val &lt;= 1000 题目来源：https://leetcode.cn/problems/binary-tree-level-order-traversal/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { //若树为空，返回空列表 if(root==null) return new LinkedList(); Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); //根节点入队 queue.offer(root); //每次遍历都将同一层次的所有节点出队，并将节点的左右孩子分别入队。 while(!queue.isEmpty()){ //记录队列长度，即该层节点个数 int level_size=queue.size(); //创建列表存储该层节点的值 List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); //遍历该层所有节点，size就是用来确定该层的元素个数，将该层节点左右孩子依次入队 for(int i=0;i&lt;level_size;i++){ TreeNode temp=queue.poll(); list.add(temp.val); if(temp.left!=null) queue.offer(temp.left); if(temp.right!=null) queue.offer(temp.right); } result.add(list); } return result; } }","link":"/post/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html"},{"title":"1047.删除字符串中所有相邻重复项","text":"1047.删除字符串中所有相邻重复项题目描述： 删除字符串中的所有相邻重复项 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 example 1: 输入：&quot;abbaca&quot; 输出：&quot;ca&quot; 解释： 例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。 提示： 1 &lt;= S.length &lt;= 20000 S 仅由小写英文字母组成。 题目来源：https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string 题解：class Solution { public String removeDuplicates(String S) { //创建deque ArrayDeque&lt;Character&gt; deque = new ArrayDeque&lt;&gt;(); char ch; //遍历字符串，检查栈顶元素是否与当前遍历元素相同，如果相同，则栈顶元素出栈，否则当前遍历元素入栈。，若栈为空，则直接入栈 for (int i = 0; i &lt; S.length(); i++) { ch = S.charAt(i); if (deque.isEmpty() || deque.peek() != ch) { deque.push(ch); } else { deque.pop(); } } String str = &quot;&quot;; //剩余的元素即为不重复的元素，注意这里是出栈元素拼接str，不要搞反，因为出栈的字符是逆序的 while (!deque.isEmpty()) { str = deque.pop() + str; } return str; } }","link":"/post/1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html"},{"title":"105. 从前序与中序遍历序列构造二叉树","text":"105.从前序与中序遍历序列构造二叉树题目描述： 从前序与中序遍历序列构造二叉树 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 example 1: 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7] example 2: 输入: preorder = [-1], inorder = [-1] 输出: [-1] 提示： 1 &lt;= preorder.length &lt;= 3000inorder.length == preorder.length-3000 &lt;= preorder[i], inorder[i] &lt;= 3000preorder 和 inorder 均 无重复 元素inorder 均出现在 preorderpreorder 保证 为二叉树的前序遍历序列inorder 保证 为二叉树的中序遍历序列 题目来源：https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { Map&lt;Integer, Integer&gt; map; public TreeNode buildTree(int[] preorder, int[] inorder) { map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; inorder.length; i++) { // 用map保存中序序列的数值对应位置 map.put(inorder[i], i); } return findNode(preorder, 0, preorder.length, inorder, 0, inorder.length); // 前闭后开 } public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) { // 参数里的范围都是前闭后开 if (preBegin &gt;= preEnd || inBegin &gt;= inEnd) { // 不满足左闭右开，说明没有元素，返回空树 return null; } int rootIndex = map.get(preorder[preBegin]); // 找到前序遍历的第一个元素在中序遍历中的位置 TreeNode root = new TreeNode(inorder[rootIndex]); // 构造结点 int lenOfLeft = rootIndex - inBegin; // 保存中序左子树个数，用来确定前序数列的个数 root.left = findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1, inorder, inBegin, rootIndex); root.right = findNode(preorder, preBegin + lenOfLeft + 1, preEnd, inorder, rootIndex + 1, inEnd); return root; } }","link":"/post/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{"title":"106. 从中序与后序遍历序列构造二叉树","text":"106.从中序与后序遍历序列构造二叉树题目描述： 从中序与后序遍历序列构造二叉树 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 example 1: 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] 输出：[3,9,20,null,null,15,7] example 2: 输入：inorder = [-1], postorder = [-1] 输出：[-1] 提示： 1 &lt;= inorder.length &lt;= 3000postorder.length == inorder.length-3000 &lt;= inorder[i], postorder[i] &lt;= 3000inorder 和 postorder 都由 不同 的值组成postorder 中每一个值都在 inorder 中inorder 保证是树的中序遍历postorder 保证是树的后序遍历 题目来源：https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { //为了更加方便的找到中序序列中节点下标 Map&lt;Integer, Integer&gt; map; // 方便根据数值查找位置 public TreeNode buildTree(int[] inorder, int[] postorder) { map = new HashMap&lt;&gt;(); //将中序序列存入map，key为节点val，value为节点val所在的下标 for (int i = 0; i &lt; inorder.length; i++) { // 用map保存中序序列的数值对应位置 map.put(inorder[i], i); } //注意，右边界是数组长度，是最后一个元素下标的后一个位置 return findNode(inorder, 0, inorder.length, postorder,0, postorder.length); // 前闭后开 } public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) { // 参数里的范围都是前闭后开 if (inBegin &gt;= inEnd || postBegin &gt;= postEnd) { // 不满足左闭右开，说明没有元素，返回空树 return null; } int rootIndex = map.get(postorder[postEnd - 1]); // 找到后序遍历的最后一个元素在中序遍历中的位置 TreeNode root = new TreeNode(inorder[rootIndex]); // 构造结点 int lenOfLeft = rootIndex - inBegin; // 保存中序左子树个数，用来确定后序数列的个数 //递归构造左子树 root.left = findNode(inorder, inBegin, rootIndex, postorder, postBegin, postBegin + lenOfLeft); //递归构造右子树 root.right = findNode(inorder, rootIndex + 1, inEnd, postorder, postBegin + lenOfLeft, postEnd - 1); return root; } }","link":"/post/106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{"title":"108. 将有序数组转换为二叉搜索树","text":"108.将有序数组转换为二叉搜索树题目描述： 将有序数组转换为二叉搜索树 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。 example 1: 输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： example 2: 输入：nums = [1,3] 输出：[3,1] 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 按 严格递增 顺序排列 题目来源： https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode build(int[] nums,int left,int right){ if(left&gt;right) return null; int mid=left+((right-left)/2); TreeNode node=new TreeNode(nums[mid]); node.left=build(nums,left,mid-1); node.right=build(nums,mid+1,right); return node; } public TreeNode sortedArrayToBST(int[] nums) { return build(nums,0,nums.length-1); } }","link":"/post/108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"},{"title":"1091.二进制矩阵中的最短路径","text":"1091.二进制矩阵中的最短路径题目描述： 二进制矩阵中的最短路径 难度中等214收藏分享切换为英文接收动态反馈 给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。 二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求： 路径途经的所有单元格都的值都是 0 。 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。 畅通路径的长度 是该路径途经的单元格总数。 example:1 输入：grid = [[0,1],[1,0]] 输出：2 example 2: 输入：grid = [[0,0,0],[1,1,0],[1,1,0]] 输出：4 example 3: 输入：grid = [[1,0,0],[1,1,0],[1,1,0]] 输出：-1 提示： n == grid.length n == grid[i].length 1 &lt;= n &lt;= 100 grid[i][j] 为 0 或 1 题目来源：https://leetcode.cn/problems/shortest-path-in-binary-matrix/ 题解： class Solution { public int shortestPathBinaryMatrix(int[][] grid) { //判断参数是否合法 if(grid==null||grid.length==0||grid[0].length==0){ return -1; } int m=grid.length; int n=grid[0].length; //判断起点和终点是否合法 if(grid[0][0]==1||grid[m-1][m-1]==1){ return -1; } //定义8个移动方向 int[][] dirs={{1,1},{1,-1},{1,0},{-1,0},{-1,1},{-1,-1},{0,1},{0,-1}}; //创建队列，加入起点坐标 Queue&lt;int[]&gt; queue=new LinkedList&lt;&gt;(); //起点设为1，防止重复遍历,初始化层次计数 queue.offer(new int[]{0,0}); grid[0][0]=1; int path=1; //遍历队列 while(!queue.isEmpty()){ //这里获取队列大小的目的是为了区分当前遍历层次和下一个层次，若不记录size，则在队列加入新的元素后无法区分路径长度。 int size=queue.size(); //当该层的元素（size大小），全部遍历完毕，就path+1，然后进入下一层。 for(int i=0;i&lt;size;i++){ int[] cur=queue.poll(); int x=cur[0]; int y=cur[1]; if(x==m-1&amp;&amp;y==n-1){ return path; } //将与当前cur相邻的八个方向元素进行遍历，符合条件的入队 for(int[] dir:dirs){ int x1=x+dir[0]; int y1=y+dir[1]; if(x1&gt;=0&amp;&amp; x1&lt;m &amp;&amp; y1&gt;=0&amp;&amp; y1&lt;n&amp;&amp; grid[x1][y1]==0){ queue.offer(new int[]{x1,y1}); grid[x1][y1]=1; } } } path++; } return -1; } }","link":"/post/1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.html"},{"title":"110.平衡二叉树","text":"110.平衡二叉树题目描述： 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 example 1: 输入：root = [3,9,20,null,null,15,7] 输出：true example 2: 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false example 3: 输入：root = [] 输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 &lt;= Node.val &lt;= 104 题目来源：https://leetcode.cn/problems/balanced-binary-tree/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int is_balanced(TreeNode node){ //若节点为空，则返回高度为0 if(node==null) return 0; //左子树高度，并检查是否左子树是否平衡 int left_depth=is_balanced(node.left); if(left_depth==-1) return -1; //右子树高度，并检查是否右子树是否平衡 int right_depth=is_balanced(node.right); if(right_depth==-1) return -1; //如果左子树和右子树高度差大于1，则不平衡，若平衡，则返回当前节点为根节点的树高度 return Math.abs(left_depth-right_depth)&gt;1?-1:1+Math.max(right_depth,left_depth); } public boolean isBalanced(TreeNode root) { return is_balanced(root)==-1?false:true; } }","link":"/post/110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{"title":"111.二叉树的最小深度","text":"111.二叉树的最小深度问题描述： 二叉树的最小深度 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 example 1: 输入：root = [3,9,20,null,null,15,7] 输出：2 example 2: 输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 提示： 树中节点数的范围在 [0, 105] 内 -1000 &lt;= Node.val &lt;= 1000 题目来源： https://leetcode.cn/problems/minimum-depth-of-binary-tree/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { /** 层序遍历，和最大深度不同，最大深度是记录二叉树拥有的层次，而最小深度，是寻找距离根节点最近的叶子节点，即层序遍历遇到的第一个叶子节点（没有左孩子和右孩子的节点）。 */ public int minDepth(TreeNode root) { if(root==null) return 0; Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;(); int deep=0; queue.offer(root); while(!queue.isEmpty()){ int size=queue.size(); deep++; for(int i=0;i&lt;size;i++){ TreeNode temp=queue.poll(); if(temp.left==null&amp;&amp;temp.right==null){ return deep; } if(temp.left!=null){ queue.offer(temp.left); } if(temp.right!=null) { queue.offer(temp.right); } } } return deep; } }","link":"/post/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html"},{"title":"112.路径综合","text":"112.路径综合题目描述： 路径总和 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 example 1: 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。 example 2: 输入：root = [1,2,3], targetSum = 5 输出：false 解释：树中存在两条根节点到叶子节点的路径： (1 --&gt; 2): 和为 3 (1 --&gt; 3): 和为 4 不存在 sum = 5 的根节点到叶子节点的路径。 example 3: 输入：root = [], targetSum = 0 输出：false 解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示： 树中节点的数目在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 题目来源：https://leetcode.cn/problems/path-sum 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { //递归，传入三个参数，第一个是当前节点，一个是从根节点到当前节点的父节点路径上的val之和，targetNum是目标路径上的节点val之和 public boolean traverse(TreeNode node,int count,int targetSum){ //加上当前节点的val，表示根节点到当前节点这条路径上的所有节点的val之和 count+=node.val; //如果当前节点是叶子节点，则判断当前路径节点的val之和是否等于目标路径的节点val之和，如果等于，则返回true，否则返回false if(node.left==null&amp;&amp;node.right==null){ if(count==targetSum){ return true; }else{ return false; } } //如果当前节点不是叶子节点，则分别判断左右子树中是否存在目标路径，下面两个变量分别存储左右子树是否存在目标路径 boolean left=false; boolean right=false; //若左子树非空，则对左子树进行递归 if(node.left!=null){ left=traverse(node.left,count,targetSum); } //对右子树进行递归 if(node.right!=null){ right=traverse(node.right,count,targetSum); } //当左子树或者右子树中存在一条目标路径则表示该树存在目标路径，这里使用|| return left||right; } public boolean hasPathSum(TreeNode root, int targetSum) { if(root==null) return false; return traverse(root,0,targetSum); } }","link":"/post/112-%E8%B7%AF%E5%BE%84%E7%BB%BC%E5%90%88.html"},{"title":"131.分割回文串","text":"131.分割回文串题目描述： 分割回文串 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 example 1： 输入：s = &quot;aab&quot; 输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]] example 2: 输入：s = &quot;a&quot; 输出：[[&quot;a&quot;]] 提示： 1 &lt;= s.length &lt;= 16 s 仅由小写英文字母组成 题目来源： https://leetcode.cn/problems/palindrome-partitioning/description/ 题解：class Solution { List&lt;List&lt;String&gt;&gt; result=new ArrayList&lt;&gt;(); LinkedList&lt;String&gt; combination=new LinkedList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) { getCombination(s,0); return result; } //切割问题转化为组合问题 public void getCombination(String s,int startIndex){ //当前元素下标超过字符串长度时，表示一次切割已经完成，将本次切割结果进行存储 if(startIndex&gt;=s.length()){ result.add(new ArrayList(combination)); return; } //从startIndex的位置开始切割，也就是水平位置 for(int i=startIndex;i&lt;s.length();i++){ //若当前切割子串是回文串，则进行切割，并加入组合集合，若切割下来的不是回文串，则进行下一次切割【因为每次切割必须保证是回文串】 if(isHuiWen(s,startIndex,i)){ combination.add(s.substring(startIndex,i+1)); }else{ continue; } //对剩余子串继续切割 getCombination(s,i+1); //回溯完成，准备更换切割位置 combination.removeLast(); } } //判断是否为回文串 public boolean isHuiWen(String s,int startIndex,int endIndex){ int i=startIndex; int j=endIndex; while(i&lt;j){ if(s.charAt(i)!=s.charAt(j)){ return false; } i++; j--; } return true; } }","link":"/post/131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html"},{"title":"134.加油站","text":"134.加油站题目描述： 加油站 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 example 1: 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2] 输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 example 2: 输入: gas = [2,3,4], cost = [3,4,3] 输出: -1 解释: 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。 因此，无论怎样，你都不可能绕环路行驶一周。 提示： gas.length == n cost.length == n 1 &lt;= n &lt;= 105 0 &lt;= gas[i], cost[i] &lt;= 104 题目来源：https://leetcode.cn/problems/gas-station/ 题解：/** 若cost之和大于gas之和，则必定没有起点可以完成绕圈任务。 这里使用的是贪心算法，我们从0开始行驶，并在行驶途中计算剩余汽油量，若在位置i处出现没有油的情况，则直接忽略0到当前位置i之间0-i的所有位置，因为他们都不可能成为起点，直接将当前位置的后一个位子i+1作为起点。别问为什么0-i之间就不存在起点了，这就是贪心，举不出反例就是真理。 */ class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { //行驶途中的汽油剩余量 int curSum=0; //总加油量与总耗油量的差值 int totalSum=0; //当前汽车的起始位置 int start=0; for(int i=0;i&lt;cost.length;i++){ //计算此时的汽油剩余量 curSum+=gas[i]-cost[i]; //继续更新总的汽油剩余量 totalSum+=gas[i]-cost[i]; //若当前的汽车的汽油剩余量已经小于0，则更新起始位置为下一个位置，并将当前汽油量置为0 if(curSum&lt;0){ start=i+1; curSum=0; } } //若cost之和大于gas之和，则必定没有起点可以完成绕圈任务。 if(totalSum&gt;=0) return start; return -1; } }","link":"/post/134-%E5%8A%A0%E6%B2%B9%E7%AB%99.html"},{"title":"135.分发糖果","text":"135.分发糖果问题描述： 分发糖果 n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 example 1: 输入：ratings = [1,0,2] 输出：5 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 example 2: 输入：ratings = [1,2,2] 输出：4 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 提示： n == ratings.length 1 &lt;= n &lt;= 2 * 104 0 &lt;= ratings[i] &lt;= 2 * 104 题目来源：https://leetcode.cn/problems/candy/description/ 题解：class Solution { public int candy(int[] ratings) { int[] candyArray=new int[ratings.length]; //计算所需的糖果总数 int result=0; //对糖果数组进行初始化 for(int k=0;k&lt;ratings.length;k++){ candyArray[k]=1; } //首先从左向右遍历，如果后一个元素大于当前元素，则后一个元素的糖果数量为当前糖果数量+1 for(int i=1;i&lt;ratings.length;i++){ if(ratings[i]&gt;ratings[i-1]){ candyArray[i]=candyArray[i-1]+1; } } //从后向前遍历，如果前一个元素大于后一个元素，则分为两种处理情况，如果前一个元素拥有的糖果数已经大于当前位置的糖果数量，则前一个元素保持原样，否则更新为当前位置糖果数量+1 for(int j=ratings.length-2;j&gt;=0;j--){ if(ratings[j]&gt;ratings[j+1]){ candyArray[j]=Math.max(candyArray[j],candyArray[j+1]+1); } } for(int n=0;n&lt;candyArray.length;n++){ result+=candyArray[n]; } return result; } }","link":"/post/135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html"},{"title":"142.环形链表Ⅱ","text":"142.环形链表Ⅱ题目描述： 环形链表 II 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 example 1： 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 example 2: 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 example 3: 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 &lt;= Node.val &lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 题目来源：https://leetcode.cn/problems/linked-list-cycle-ii/submissions/ 题解：/* 判断是否有环：可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。 此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。 首先判断是否有环，如果有环，则记录相遇节点，然后下一步寻找环的入口节点：从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。 */ /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) {// 有环 ListNode index1 = fast; ListNode index2 = head; // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口 while (index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; } }","link":"/post/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1.html"},{"title":"15.三数之和","text":"15.三数之和题目描述： 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 example 1: 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 解释： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 example 2: 输入：nums = [0,1,1] 输出：[] 解释：唯一可能的三元组和不为 0 。 example 3: 输入：nums = [0,0,0] 输出：[[0,0,0]] 解释：唯一可能的三元组和为 0 。 提示： 3 &lt;= nums.length &lt;= 3000 -105 &lt;= nums[i] &lt;= 105 题目来源：https://leetcode.cn/problems/3sum 题解：class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); //对数组进行排序 Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) { //因为已经排序了，如果第i个元素大于0，则之后的元素均大于0， 不能满足和为0，直接退出 if (nums[i] &gt; 0) { return result; } //去重，如果i和i-1的元素相同，则遍历下一个 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } //left初始指向i+1，right指向数组末尾 int left = i + 1; int right = nums.length - 1; //寻找满足条件的三个数 while (right &gt; left) { //获取三个指针指向的值 int sum = nums[i] + nums[left] + nums[right]; //如果sum大于0，表示和太大，right指针左移，将和减小 if (sum &gt; 0) { right--; //若sum小于0，则表示太小，left右移，扩大sum } else if (sum &lt; 0) { left++; //当sum==0，则表示满足条件 } else { //将该组合加入结果集合 result.add(Arrays.asList(nums[i], nums[left], nums[right])); //寻找下一组满足条件的和，但是需要去重 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; right--; left++; } } } return result; } }","link":"/post/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html"},{"title":"150. 逆波兰表达式求值","text":"150.逆波兰表达式求值题目描述： 逆波兰表达式求值 根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 注意 两个整数之间的除法只保留整数部分。 可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 example 1: 输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 example 2: 输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 example 3: 输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;] 输出：22 解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 提示： 1 &lt;= tokens.length &lt;= 104 tokens[i] 是一个算符（”+”、”-“、”*” 或 “/“），或是在范围 [-200, 200] 内的一个整数 题目来源：https://leetcode.cn/problems/evaluate-reverse-polish-notation 题解：class Solution { /** 如果是遍历到数字，则进站，如果遍历到运算符，则将栈顶的两个元素出栈，然后经过该运算符运算，将运算结果入栈。遍历完成后将栈顶元素出栈，该元素就是最终的运算结果 */ public int evalRPN(String[] tokens) { Deque&lt;Integer&gt; stack = new LinkedList(); for (String s : tokens) { if (&quot;+&quot;.equals(s)) { // leetcode 内置jdk的问题，不能使用==判断字符串是否相等 stack.push(stack.pop() + stack.pop()); // 注意 - 和/ 需要特殊处理 } else if (&quot;-&quot;.equals(s)) { stack.push(-stack.pop() + stack.pop()); } else if (&quot;*&quot;.equals(s)) { stack.push(stack.pop() * stack.pop()); } else if (&quot;/&quot;.equals(s)) { int temp1 = stack.pop(); int temp2 = stack.pop(); stack.push(temp2 / temp1); } else { stack.push(Integer.valueOf(s)); } } return stack.pop(); } }","link":"/post/150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html"},{"title":"151.反转字符串中的单词","text":"151.反转字符串中的单词题目描述： 反转字符串中的单词 给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 example 1: 输入：s = &quot;the sky is blue&quot; 输出：&quot;blue is sky the&quot; example 2: 输入：s = &quot; hello world &quot; 输出：&quot;world hello&quot; 解释：反转后的字符串中不能存在前导空格和尾随空格。 example 3: 输入：s = &quot;a good example&quot; 输出：&quot;example good a&quot; 解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。 提示： 1 &lt;= s.length &lt;= 104 s 包含英文大小写字母、数字和空格 ' ' s 中 至少存在一个 单词 题目来源：https://leetcode.cn/problems/reverse-words-in-a-string 题解：class Solution { public String reverseWords(String s) { //源字符数组 char[] s_char=s.toCharArray(); //创建新的字符数组 char[] new_str=new char[s_char.length+1]; //新字符数组指针 int newStr_index=0; //源字符数组指针，从末尾开始 int i=s_char.length-1; //从后向前遍历 while(i&gt;=0){ //找到最后一个单词的末尾位置并记录 while(i&gt;=0&amp;&amp;s_char[i]==' ') i--; int right=i; //找到最后一个单词的起始位置并记录 while(i&gt;=0&amp;&amp;s_char[i]!=' ') i--; int left=i+1; //将原字符数组的最后一个单词，存入新字符数组的第一个单词位置 for(int j=left;j&lt;=right;j++){ new_str[newStr_index++]=s_char[j]; //若遍历到单词末尾，则添加空格 if(j==right){ new_str[newStr_index++]=' '; } } } //若原数组没有单词，则返回空字符串 if(newStr_index==0){ return &quot;&quot;; //否则返回反转后的字符串 }else{ return new String(new_str,0,newStr_index-1); } } }","link":"/post/151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D.html"},{"title":"17.电话号码的字母组合","text":"17.电话号码的字母组合题目描述： 电话号码的字母组合 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 example 1： 输入：digits = &quot;23&quot; 输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;] example 2: 输入：digits = &quot;&quot; 输出：[] example 3: 输入：digits = &quot;2&quot; 输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 提示： 0 &lt;= digits.length &lt;= 4 digits[i] 是范围 ['2', '9'] 的一个数字。 题目来源：https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/ 题解：class Solution { //设置全局列表存储最后的结果 List&lt;String&gt; list = new ArrayList&lt;&gt;(); public List&lt;String&gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return list; } //初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串&quot;&quot; String[] numString = {&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;}; //迭代处理，参数1：输入的数字；参数2：所有数字对应的字符串；参数3：当前选取字符的数字 backTracking(digits, numString, 0); return list; } //每次迭代获取一个字符串，所以会设计大量的字符串拼接，所以这里选择更为高效的 StringBuild StringBuilder temp = new StringBuilder(); //比如digits如果为&quot;23&quot;,num 为0，则str表示2对应的 abc public void backTracking(String digits, String[] numString, int num) { //遍历全部一次记录一次得到的字符串 if (num == digits.length()) { list.add(temp.toString()); return; } //str 表示当前num对应的字符串 String str = numString[digits.charAt(num) - '0']; for (int i = 0; i &lt; str.length(); i++) { temp.append(str.charAt(i)); //c backTracking(digits, numString, num + 1); //剔除末尾的继续尝试 temp.deleteCharAt(temp.length() - 1); } } }","link":"/post/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html"},{"title":"20.有效的括号","text":"20.有效的括号题目描述： 有效的括号 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 example 1: 输入：s = &quot;()&quot; 输出：true example 2: 输入：s = &quot;()[]{}&quot; 输出：true example 3: 输入：s = &quot;(]&quot; 输出：false 提示： 1 &lt;= s.length &lt;= 104 s 仅由括号 '()[]{}' 组成 题目来源：https://leetcode.cn/problems/valid-parentheses/ 题解：class Solution { public boolean isValid(String s) { Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;(); char ch; for (int i = 0; i &lt; s.length(); i++) { ch = s.charAt(i); //碰到左括号，就把相应的右括号入栈 if (ch == '(') { deque.push(')'); }else if (ch == '{') { deque.push('}'); }else if (ch == '[') { deque.push(']'); } else if (deque.isEmpty() || deque.peek() != ch) { return false; }else {//如果是右括号判断是否和栈顶元素匹配 deque.pop(); } } //最后判断栈中元素是否匹配 return deque.isEmpty(); } }","link":"/post/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html"},{"title":"202.快乐数","text":"202.快乐数题目描述： 快乐数 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 example 1： 输入：n = 19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 example 2: 输入：n = 2 输出：false 提示： 1 &lt;= n &lt;= 231 - 1 题目来源：https://leetcode.cn/problems/happy-number/ 题解：class Solution { public boolean isHappy(int n) { //存储替换过的数字，因为题目说了可能会出现无限循环的情况，会重复出现某个数字，比如 //2，4，16，37，58，89，145，42，20，2 HashSet&lt;Integer&gt; set=new HashSet&lt;Integer&gt;(); while(n!=1&amp;&amp;!set.contains(n)){ set.add(n); n=getNextNumber(n); } return n==1; } //计算下一个数字 public int getNextNumber(int n){ int res=0; while(n&gt;0){ int temp=n%10; res+=temp*temp; n=n/10; } return res; } }","link":"/post/202-%E5%BF%AB%E4%B9%90%E6%95%B0.html"},{"title":"203.移除链表元素","text":"203.移除链表元素题目描述： 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 example 1: 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] example 2: 输入：head = [], val = 1 输出：[] example 3: 输入：head = [7,7,7,7], val = 7 输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 题目来源： https://leetcode.cn/problems/remove-linked-list-elements/ 题解：/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { if(head==null){ return null; } //创建一个虚拟头节点，目的是为了统一头结点的处理操作 ListNode fake_head=new ListNode(-1,head); //左指针 ListNode pre=fake_head; //右指针 ListNode sec=head; while(sec!=null){ //若当前右指针元素需要移除 if(sec.val==val){ //丢弃该元素,并将右指针向后移动一位 pre.next=sec.next; sec=sec.next; }else{ //若该元素无须移除，则左右指针均向后移动一位 pre=pre.next; sec=sec.next; } } return fake_head.next; } }","link":"/post/203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html"},{"title":"206.反转链表","text":"206.反转链表题目描述： 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 example 1: 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] example 2: 输入：head = [1,2] 输出：[2,1] example 3: 输入：head = [] 输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 题目来源：https://leetcode.cn/problems/reverse-linked-list/ 题解：/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode head_node=new ListNode(); ListNode p=head; while(p!=null){ ListNode q=p.next; p.next=head_node.next; head_node.next=p; p=q; } return head_node.next; } }","link":"/post/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html"},{"title":"209.长度最小的子数组","text":"209.长度最小的子数组题目描述： 长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 example 1: 输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 example 2: 输入：target = 4, nums = [1,4,4] 输出：1 example 3: 输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 题目来源： https://leetcode.cn/problems/minimum-size-subarray-sum/ 题解：class Solution { public int minSubArrayLen(int target, int[] nums) { //滑动窗口 /* 基本思想： 1.定义两个指针，初始值均为数组左边界 2.定义变量记录两个指针区域之间子序列的和，再定义一个变量记录当前满足条件的最小子序列长度，初始值为无穷大 3.不断右移右指针，并计算子区域元素之和，当子区域和满足条件时记录当前子区域长度并更新最小子区域长度，随后将左指针右移，若依旧满足条件则继续更新最小子区域长度，直到子区域之和不满足条件，之后重新开始右移右指针 */ //判断参数是否合法 if(nums==null||nums.length==0){ return 0; } //初始化指针，j为右指针，i为左指针 int i=0; int j=0; //sum表示i~j子序列之和 int sum=0; //ret记录当前的最小子序列 int ret=Integer.MAX_VALUE; //当遍历子序列之和没有超过target，则将j右移 while(j&lt;nums.length){ sum+=nums[j]; //若子序列之和满足条件，则计算子序列长度，并判断是否更新ret，并将左边界右移，更新子序列之和，循环右移并更新子序列长度。 while(sum&gt;=target){ int sub_length=j-i+1; ret=ret&gt;sub_length? sub_length:ret; sum-=nums[i++]; } j++; } //若ret的值发生改变，则返回，否则返回0，表示没有满足条件的解 return ret==Integer.MAX_VALUE? 0:ret; } }","link":"/post/209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html"},{"title":"216.组合总和Ⅲ","text":"216.组合总和Ⅲ题目描述： 组合总和 III 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 example 1: 输入: k = 3, n = 7 输出: [[1,2,4]] 解释: 1 + 2 + 4 = 7 没有其他符合的组合了。 example 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 解释: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 没有其他符合的组合了。 example 3: 输入: k = 4, n = 1 输出: [] 解释: 不存在有效的组合。 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。 提示： 2 &lt;= k &lt;= 9 1 &lt;= n &lt;= 60 题目来源：https://leetcode.cn/problems/combination-sum-iii/description/ 题解：class Solution { List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path=new LinkedList&lt;&gt;(); int sum=0; public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) { getPathes(k,n,1); return result; } public void getPathes(int k,int n,int index){ //若当前的元素之和已经超过了目标sum，则直接跳出本次递归，就是剪枝操作 if(sum&gt;n){ return; } if(path.size()==k){ if(sum==n){ result.add(new ArrayList(path)); } return; } //遍历该层所有可能的元素情况 for(int i=index;i&lt;=9-(k-path.size())+1;i++){ //该层元素进入path，更新sum sum+=i; path.add(i); //对下层进行递归，判断下一个元素 getPathes(k,n,i+1); //回溯操作，弹出当前元素，并恢复sum值 sum-=i; path.removeLast(); } } }","link":"/post/216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A2.html"},{"title":"222.完全二叉树的节点个数","text":"222.完全二叉树的节点个数题目描述： 完全二叉树的节点个数 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 example 1: 输入：root = [1,2,3,4,5,6] 输出：6 example 2: 输入：root = [] 输出：0 example 3: 输入：root = [1] 输出：1 提示： 树中节点的数目范围是[0, 5 * 104] 0 &lt;= Node.val &lt;= 5 * 104 题目数据保证输入的树是 完全二叉树 题目来源： https://leetcode.cn/problems/count-complete-tree-nodes/ 题解：//解法1：层序遍历，记录节点个数 class Solution { //迭代法 public int countNodes(TreeNode root) { if(root==null) return 0; int node_count=0; Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()){ TreeNode temp=queue.poll(); node_count++; if(temp.left!=null) queue.offer(temp.left); if(temp.right!=null) queue.offer(temp.right); } return node_count; } } //解法2：利用二叉树性质 class Solution { //利用完全二叉树的性质，使用递归，查看左遍历深度left_depth，和右深度right_depth,若左右深度相同，则该二叉树为完全二叉树，返回节点个数2^depth-1 //若左右深度不同，则递归左孩子，求出左子树的节点个数，递归右子树，求出右子树的节点个数，再加上1为根节点。 public int countNodes(TreeNode root) { if(root==null) return 0; TreeNode left_child=root.left; TreeNode right_child=root.right; int left_depth=0; int right_depth=0; while(left_child!=null){ left_child=left_child.left; left_depth++; } System.out.println(left_depth); while(right_child!=null){ right_child=right_child.right; right_depth++; } System.out.println(right_depth); // 若左右深度相同，则该二叉树为完全二叉树，返回节点个数2^depth-1 if(right_depth==left_depth){ return (2&lt;&lt;right_depth)-1; } else{ // 若左右深度不同，则递归左孩子，求出左子树的节点个数，递归右子树，求出右子树的节点个数，再加上1为根节点。 return countNodes(root.right)+countNodes(root.left)+1; } } }","link":"/post/222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html"},{"title":"225.用队列实现栈","text":"225.用队列实现栈问题描述： 用队列实现栈 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意： 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 example 1: 输入： [&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;] [[], [1], [2], [], [], []] 输出： [null, null, null, 2, 2, false] 解释： MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // 返回 2 myStack.pop(); // 返回 2 myStack.empty(); // 返回 False 提示： 1 &lt;= x &lt;= 9 最多调用100 次 push、pop、top 和 empty 每次调用 pop 和 top 都保证栈不为空 题目来源：https://leetcode.cn/problems/implement-stack-using-queues 题解：class MyStack { /** 队列模拟栈，其实一个队列就够了，那么我们先说一说两个队列来实现栈的思路。 队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。 所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。 但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是另一个队列完全用又来备份的！ 如下面动画所示，用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。 */ // Deque 接口继承了 Queue 接口 // 所以 Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst Deque&lt;Integer&gt; que1; /** Initialize your data structure here. */ public MyStack() { que1 = new ArrayDeque&lt;&gt;(); } /** Push element x onto stack. */ public void push(int x) { que1.addLast(x); } /** Removes the element on top of the stack and returns that element. */ public int pop() { int size = que1.size(); size--; // 将 que1 除了最后一个元素之外的所有元素从队头移到队尾，相当于暴露最后一个元素，用以满足栈的先进后出的特性，同时将元素从队头移到队尾的操作可以替换原先的使用另一个辅助队列的方式，降低了时间复杂度 while (size-- &gt; 0) { que1.addLast(que1.peekFirst()); que1.pollFirst(); } int res = que1.pollFirst(); return res; } /** Get the top element. */ public int top() { return que1.peekLast(); } /** Returns whether the stack is empty. */ public boolean empty() { return que1.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */","link":"/post/225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html"},{"title":"226.翻转二叉树","text":"226. 翻转二叉树题目描述：example 1: 4 | | 2 7 | | | | 1 3 6 9 4 | | 7 2 | | | | 9 6 3 1 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] example 2: 2 | | 1 3 2 | | 1 3 输入：root = [2,1,3] 输出：[2,3,1] example 3: 输入：root = [] 输出：[] 提示： 树中节点数目范围在 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 题目来源:https://leetcode.cn/problems/invert-binary-tree/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { //后序遍历，若将遍历节点的左右孩子互换 public void postOrder(TreeNode root){ if(root==null) return; if(root.left!=null) postOrder(root.left); if(root.right!=null) postOrder(root.right); TreeNode temp=root.left; root.left=root.right; root.right=temp; } public TreeNode invertTree(TreeNode root) { if(root==null) return null; postOrder(root); return root; } }","link":"/post/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{"title":"232.用栈实现队列","text":"232.用栈实现队列题目描述： 用栈实现队列 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 example 1: 输入： [&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false 提示： 1 &lt;= x &lt;= 9最多调用 100 次 push、pop、peek 和 empty假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） 题目来源：https://leetcode.cn/problems/implement-queue-using-stacks 题解：class MyQueue { Stack&lt;Integer&gt; in; Stack&lt;Integer&gt; out; public MyQueue() { in=new Stack&lt;&gt;(); out=new Stack&lt;&gt;(); } public void push(int x) { in.push(x); } //输出栈为空，则将输入栈的元素全部存入输出栈，然后pop输出栈；若输出栈不为空，则直接pop输出栈 public int pop() { if(out.isEmpty()){ while(!in.isEmpty()){ int temp=in.pop(); out.push(temp); } } return out.pop(); } //输出栈为空，则将输入栈的元素全部存入输出栈，然后peek输出栈；若输出栈不为空，则直接peek输出栈 public int peek() { if(out.isEmpty()){ while(!in.isEmpty()){ int temp=in.pop(); out.push(temp); } } return out.peek(); } //输入输出栈均为空时，队列为空 public boolean empty() { return in.isEmpty()&amp;&amp;out.isEmpty(); } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */","link":"/post/232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html"},{"title":"236.二叉搜索树的最近公共祖先","text":"236.二叉搜索树的最近公共祖先题目描述： 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] example 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6 example 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 提示： 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 题目来源：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { return findNode(root,p,q); } //因为是二叉搜索树，所以和普通二叉树的递归有所不同，之后还需要对比看，还没理解透 public TreeNode findNode(TreeNode root,TreeNode p,TreeNode q){ if(root==null) return null; //若该节点值大于pq，搜索左边， if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val){ TreeNode left=lowestCommonAncestor(root.left,p,q); if(left!=null){ return left; } } //若该节点值小于pq，则搜索右边 if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val){ TreeNode right=lowestCommonAncestor(root.right,p,q); if(right!=null){ return right; } } return root; } }","link":"/post/236-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html"},{"title":"236.二叉树的最近公共祖先","text":"236.二叉树的最近公共祖先题目描述： 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” example 1： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 example 2: 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 example 3: 输入：root = [1,2], p = 1, q = 2 输出：1 提示： 树中节点数目在范围 [2, 105] 内。-109 &lt;= Node.val &lt;= 109所有 Node.val 互不相同 。p != qp 和 q 均存在于给定的二叉树中。 题目来源:https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { //递归，回溯，使用后序遍历 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { //若当前节点为其中一个指定节点，或者当前节点为null，则返回 if(root==p||root==q||root==null){ return root; } //左子树是否存在公共祖先 TreeNode left=lowestCommonAncestor(root.left,p,q); TreeNode right=lowestCommonAncestor(root.right,p,q); if(left==null&amp;&amp;right==null){ return null; }else if(left!=null&amp;&amp;right==null){ return left; }else if(left==null&amp;&amp;right!=null){ return right; } return root; } }","link":"/post/236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html"},{"title":"239.滑动窗口的最大值","text":"239.滑动窗口的最大值题目描述： 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 example 1: 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length 题目来源：https://leetcode.cn/problems/sliding-window-maximum 题解：//自定义数组 class MyQueue { Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); //弹出元素时，比较当前要弹出的数值是否等于队列出口的数值； //仅有两种可能，1.要弹出的元素等于队列出口元素，那么就弹出，因为表示该元素是上一个滑动窗口的最大值，下一个滑动窗口中不包含该元素，需要新的最大值 //2.需要弹出的元素小于队列出口元素，则不进行处理，因为对下一个滑动窗口的最大值选取没有影响 //同时判断队列当前是否为空 void poll(int val) { if (!deque.isEmpty() &amp;&amp; val == deque.peek()) { deque.poll(); } } //添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出 //保证队列元素单调递减 //比如此时队列元素【4,2,1】，3将要入队，比1大，所以1弹出，此时队列：【4,2】，循环再次判断，3和2进行比较，3大于2，所以2弹出，此时队列【4】，再次和4比较，3小于4，跳出循环，将3加入队尾，此时队列变为【4,3】 void add(int val) { while (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) { deque.removeLast(); } deque.add(val); } //队列队顶元素始终为最大值[获取队头元素，因为队列是有序的，因此队头元素是最大值，即当前滑动窗口的最大值] int peek() { return deque.peek(); } } class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if (nums.length == 1) { return nums; } int len = nums.length - k + 1; //存放结果元素的数组 int[] res = new int[len]; int num = 0; //自定义队列 MyQueue myQueue = new MyQueue(); //先将前k的元素放入队列，也就是第一个滑动窗口中的所有元素放入队列中 for (int i = 0; i &lt; k; i++) { myQueue.add(nums[i]); } //由于add方法是自动会对插入元素进行排序的，因此当将第一个滑动窗口的元素放入队列中后，队头元素就已经是最大元素了，即第一滑动窗口的元素 res[num++] = myQueue.peek(); //开始将窗口进行滑动，即再次从第二个滑动窗口进行遍历 for (int i = k; i &lt; nums.length; i++) { //弹出上一个滑动窗口的元素，加入该滑动窗口的新元素，然后获取该滑动窗口的最大值 //滑动窗口移除最前面的元素，移除是判断该元素是否放入队列 myQueue.poll(nums[i - k]); //滑动窗口加入最后面的元素 myQueue.add(nums[i]); //记录对应的最大值 res[num++] = myQueue.peek(); } return res; } }","link":"/post/239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.html"},{"title":"24.两两交换链表中的节点","text":"24.两两交换链表中的节点题目描述： 两两交换链表中的节点 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 example1: 输入：head = [1,2,3,4] 输出：[2,1,4,3] example 2: 输入：head = [] 输出：[] example 3: 输入：head = [1] 输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 题目来源：https://leetcode.cn/problems/swap-nodes-in-pairs/ 题解：https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E6%80%9D%E8%B7%AF 题解：/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { ListNode head_node=new ListNode(); head_node.next=head; //活动指针，指向的是当前需要交换的节点的前一个节点，方便交换，这里之所以采用虚拟头节点，是为了统一化处理 ListNode p=head_node; while(p.next!=null&amp;&amp;p.next.next!=null){ //指向需要交换的第一个节点 ListNode temp=p.next; //指向需要交换的第二个节点 ListNode temp_next=p.next.next; //首先将p指向第二个节点 p.next=temp_next; //第一个节点指向第二个节点原本指向的后续链表 temp.next=temp_next.next; //第二个节点指向一个节点 temp_next.next=temp; //将活动节点后移，指向下一对需要交换的节点的前一个节点， p=p.next.next; } //返回调整后的链表 return head_node.next; } }","link":"/post/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html"},{"title":"242.有效的字母异位词","text":"242.有效的字母异位词题目描述： 有效的字母异位词 给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。 注意：若 *s* 和 *t* 中每个字符出现的次数都相同，则称 *s* 和 *t* 互为字母异位词。 example 1： 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true example 2: 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false 提示： 1 &lt;= s.length, t.length &lt;= 5 * 104 s 和 t 仅包含小写字母 题目来源：https://leetcode.cn/problems/valid-anagram/ 题解：/* 定义一个数组，来记录字符串s里字符出现的次数。 需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。 再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了。 那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。 那么最后检查一下，record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。 最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。 时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。 */ class Solution { public boolean isAnagram(String s, String t) { int[] record = new int[26]; for (char c : s.toCharArray()) { record[c - 'a'] += 1; } for (char c : t.toCharArray()) { record[c - 'a'] -= 1; } for (int i : record) { if (i != 0) { return false; } } return true; } }","link":"/post/242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html"},{"title":"257.二叉树的所有路径","text":"257.二叉树的所有路径题目描述： 二叉树的所有路径 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 example 1: 输入：root = [1,2,3,null,5] 输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;] example 2: 输入：root = [1] 输出：[&quot;1&quot;] 提示： 树中节点的数目在范围 [1, 100] 内 -100 &lt;= Node.val &lt;= 100 题目来源：https://leetcode.cn/problems/binary-tree-paths/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { //递归+回溯的方法 public List&lt;String&gt; binaryTreePaths(TreeNode root) { //创建结果列表，列表元素是字符串，字符串表示的是路径 List&lt;String&gt; result=new ArrayList&lt;&gt;(); if(root==null) return result; //用于存储路径，列表元素是整型变量，变量表示的是每一个节点的值 List&lt;Integer&gt; paths=new ArrayList&lt;&gt;(); //进行递归和回溯 traverse(root,paths,result); //返回搜索的路径结果 return result; } public void traverse(TreeNode node,List&lt;Integer&gt; paths,List&lt;String&gt; result){ //将该节点加入路径 paths.add(node.val); //判断是否为叶子节点，如果是叶子节点，则将paths列表转化为路径字符串，并加入到result中，并返回 if(node.left==null&amp;&amp;node.right==null){ StringBuffer temp=new StringBuffer(); for(int i=0;i&lt;paths.size()-1;i++){ temp.append(paths.get(i)).append(&quot;-&gt;&quot;); } temp.append(paths.get(paths.size()-1)); result.add(temp.toString()); return; } //如果该节点存在左孩子，则将左孩子进行递归 //注意，这里需要将paths列表的最后一个元素弹出， //若该元素的左孩子就是叶子节点，则paths最后一个元素就是左孩子节点，因为后续要继续寻找路径，所以这里的叶节点需要弹出。 if(node.left!=null){ traverse(node.left,paths,result); paths.remove(paths.size()-1); } if(node.right!=null){ traverse(node.right,paths,result); paths.remove(paths.size()-1); } } }","link":"/post/257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html"},{"title":"28.实现 strStr()","text":"28.实现 strStr()题目描述： 实现 strStr() 实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 example 1: 输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出：2 example 2: 输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出：-1 提示： 1 &lt;= haystack.length, needle.length &lt;= 104 haystack 和 needle 仅由小写英文字符组成 题目来源：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/ 题解：// 方法一 class Solution { //求出next数组 public void getNext(int[] next,String s){ int j=-1; next[0]=j; //j指向前缀的末尾，i指向后缀的末尾 for(int i=1;i&lt;next.length;i++){ //若前缀的末尾和后缀的末尾不匹配，则将前缀的末尾进行回退 while(j&gt;=0&amp;&amp;s.charAt(i)!=s.charAt(j+1)){ j=next[j]; } //若匹配成功，则i和j都向后移动 if(s.charAt(i)==s.charAt(j+1)){ j++; } //求得最大前后缀长度 next[i]=j; } } public int strStr(String haystack, String needle) { int[] next=new int[needle.length()]; //j为模式串指针 int j=-1; //求next数组 getNext(next,needle); //i为匹配串指针 for(int i=0;i&lt;haystack.length();i++){ //若匹配失败，则模式串指针回退 while(j&gt;=0&amp;&amp;haystack.charAt(i)!=needle.charAt(j+1)){ j=next[j]; } //匹配成功继续向后匹配 if(needle.charAt(j+1)==haystack.charAt(i)){ j++; } //判断模式串是否匹配成功，若j到达模式串末尾，则返回匹配成功位置 if(j==needle.length()-1){ return i-needle.length()+1; } } //匹配失败 return -1; } }","link":"/post/28-%E5%AE%9E%E7%8E%B0-strStr.html"},{"title":"343.整数拆分","text":"343.整数拆分题目描述： 整数拆分 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。 example 1: 输入: n = 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 example 2: 输入: n = 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 提示： 2 &lt;= n &lt;= 58 题目来源：https://leetcode.cn/problems/integer-break/ 题解: 2023/1/23 class Solution { public int integerBreak(int n) { //dp数组表示每个元素拆分后的乘积最大值 int[] dp=new int[n+1]; //由于拆分元素个数必须大于2，所以从2开始，拆分为1+1，乘积为1 dp[2]=1; //求出3-n之间的每一个数拆分后的乘积最大值 for(int i=3;i&lt;=n;i++){ //从1开始拆分，1+(i-1);2+(i-2);....;(i/2)*(i/2) for(int j=1;j&lt;=i/2;j++){ //取乘积的最大值，有三种情况，(i-j)*j;dp[i-j]*j;j取其他值时的乘积最大值，三者取最大值作为当前的乘积最大值 dp[i]=Math.max(dp[i],Math.max(dp[i-j]*j,(i-j)*j)); } } return dp[n]; } } 之前 class Solution { public int integerBreak(int n) { //参数是否合法，当n=0 or 1的时候无法进行拆分 if(n==0||n==1){ return 0; } //定义dp数组，dp[i]表示的是给定i时可以获得的最大化乘积 int[] dp=new int[n+1]; //dp数组初始化，直接从dp[2]开始初始化，因为i=1和0是没有意义的 dp[2]=1; //对dp数组进行遍历，确定状态转换公式： /* dp[i]可以通过两个公式得到，其中j从1到i-1 1.j*(i-j) 2.j*dp[i-j] j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。 如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。 所以递推公式：dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j}); 那么在取最大值的时候，为什么还要比较dp[i]呢？ 因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。 */ for(int i=3;i&lt;=n;i++){ for(int j=1;j&lt;i-1;j++){ dp[i]=Math.max(dp[i],Math.max((j*(i-j)),j*dp[i-j])); } } return dp[n]; } }","link":"/post/343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html"},{"title":"344.反转字符串","text":"344.反转字符串题目描述： 反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。 example 1: 输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;] 输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] example 2: 输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;] 输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 提示： 1 &lt;= s.length &lt;= 105 s[i] 都是 ASCII 码表中的可打印字符 题目来源：https://leetcode.cn/problems/reverse-string/ 题解：class Solution { public void reverseString(char[] s) { int left=0; int right=s.length-1; while(left&lt;right){ swap(s,left,right); left++; right--; } } public void swap(char[] s,int left,int right){ char temp=s[left]; s[left]=s[right]; s[right]=temp; } }","link":"/post/344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{"title":"349.两个数组的交集","text":"349.两个数组的交集题目描述： 两个数组的交集 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 example 1: 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] example 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 解释：[4,9] 也是可通过的 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 题目来源：https://leetcode.cn/problems/intersection-of-two-arrays/ 题解：class Solution { public int[] intersection(int[] nums1, int[] nums2) { if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) { return new int[0]; } //存储数组元素 Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(); //存储结果 Set&lt;Integer&gt; resSet = new HashSet&lt;&gt;(); //遍历数组1 for (int i : nums1) { set1.add(i); } //遍历数组2的过程中判断哈希表中是否存在该元素，若存在，则存入resSet中，因为输出结果是唯一的，因此并集的结果使用set集合来存储 for (int i : nums2) { if (set1.contains(i)) { resSet.add(i); } } //将结果集合转为数组 return resSet.stream().mapToInt(x -&gt; x).toArray(); } }","link":"/post/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html"},{"title":"376.摆动序列","text":"376.摆动序列题目描述： 摆动序列 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。 example 1: 输入：nums = [1,7,4,9,2,5] 输出：6 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。 example 2: 输入：nums = [1,17,5,10,13,15,10,5,16,8] 输出：7 解释：这个序列包含几个长度为 7 摆动序列。 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。 example 3: 输入：nums = [1,2,3,4,5,6,7,8,9] 输出：2 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 题目来源：https://leetcode.cn/problems/wiggle-subsequence/description/ 题解：class Solution { public int wiggleMaxLength(int[] nums) { if(nums.length&lt;=1){ return nums.length; } //当前差值 int cur=0; //上一个差值 int pre=0; //默认最右侧元素即为一个序列 int top=1; for(int i=0;i&lt;nums.length-1;i++){ cur=nums[i+1]-nums[i]; //仅当cur为峰值或者cur为峰值的后一个元素时，才记录top并更新pre，略过了中间的连续递增或者递减的过程 if((cur&lt;0&amp;&amp;pre&gt;=0)||(pre&lt;=0&amp;&amp;cur&gt;0)){ top++; pre=cur; } } return top; } }","link":"/post/376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html"},{"title":"39.组合总和","text":"39.组合总和题目描述： 组合总和 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 example 1: 输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]] 解释： 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。 7 也是一个候选， 7 = 7 。 仅有这两种组合。 example 2: 输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]] example 3: 输入: candidates = [2], target = 1 输出: [] 提示： 1 &lt;= candidates.length &lt;= 30 2 &lt;= candidates[i] &lt;= 40 candidates 的所有元素 互不相同 1 &lt;= target &lt;= 40 题目来源：https://leetcode.cn/problems/combination-sum/description/ 题解：class Solution { List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path=new LinkedList&lt;&gt;(); Integer sum=0; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { getPaths(candidates,target,0); return result; } public void getPaths(int[] candidates,int target,int index){ //当前总和大于目标，结束递归 if(sum&gt;target){ return; } //当前总和等于目标，将路径存储，并结束递归 if(sum==target){ result.add(new ArrayList(path)); return; } //寻找下一个元素 for(int i=index;i&lt;candidates.length;i++){ sum+=candidates[i]; path.add(candidates[i]); //这里传入的下一个元素位置是i，不是i+1，因为可以重复选取当前元素 getPaths(candidates,target,i); //回溯 sum-=candidates[i]; path.removeLast(); } } }","link":"/post/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html"},{"title":"40.组合总和Ⅱ","text":"40.组合总和Ⅱ题目描述： 组合总和 II 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含重复的组合。 【注】：和组合总和Ⅲ的区别在于，三中的元素是不重复的，而二中的元素是重复的，并且都要求组合不能重复，因此解法具有差异 example 1： 输入: candidates = [10,1,2,7,6,1,5], target = 8, 输出: [ [1,1,6], [1,2,5], [1,7], [2,6] ] example 2： 输入: candidates = [2,5,2,1,2], target = 5, 输出: [ [1,2,2], [5] ] 提示： 1 &lt;= candidates.length &lt;= 100 1 &lt;= candidates[i] &lt;= 50 1 &lt;= target &lt;= 30 题目来源：https://leetcode.cn/problems/combination-sum-ii/description/ 题解：class Solution { LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); boolean[] used; int sum = 0; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { used = new boolean[candidates.length]; // 加标志数组，用来辅助判断同层节点是否已经遍历 Arrays.fill(used, false); // 为了将重复的数字都放到一起，所以先进行排序 Arrays.sort(candidates); backTracking(candidates, target, 0); return ans; } private void backTracking(int[] candidates, int target, int startIndex) { if (sum == target) { ans.add(new ArrayList(path)); } for (int i = startIndex; i &lt; candidates.length; i++) { if (sum + candidates[i] &gt; target) { break; } // 出现重复节点，同层的第一个节点已经被访问过，所以直接跳过 if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !used[i - 1]) { continue; } used[i] = true; sum += candidates[i]; path.add(candidates[i]); // 每个节点仅能选择一次，所以从下一位开始 backTracking(candidates, target, i + 1); used[i] = false; sum -= candidates[i]; path.removeLast(); } } }","link":"/post/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1.html"},{"title":"404.左叶子之和","text":"404.左叶子之和题目描述： 左叶子之和 给定二叉树的根节点 root ，返回所有左叶子之和。 example 1： 输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 example 2: 输入: root = [1] 输出: 0 提示： 节点数在 [1, 1000] 范围内 -1000 &lt;= Node.val &lt;= 1000 题目来源：https://leetcode.cn/problems/sum-of-left-leaves 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int sumOfLeftLeaves(TreeNode root) { //若当前节点为空，则返回0 if(root==null) return 0; //若当前节点为叶子节点，则返回0 if(root.left==null&amp;&amp;root.right==null) return 0; //记录左子树的所有叶子节点的值 int leftValue=0; //如果左孩子节点就是叶子节点，则leftValue就是左孩子节点的值 if(root.left!=null&amp;&amp;root.left.left==null&amp;&amp;root.left.right==null) leftValue=root.left.val; //返回当前节点左子树和右子树的所有左叶子节点的值之和 return leftValue+sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right); } }","link":"/post/404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html"},{"title":"406.根据身高重建队列","text":"406.根据身高重建队列题目描述 根据身高重建队列 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 example 1： 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 解释： 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 example 2: 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示： 1 &lt;= people.length &lt;= 2000 0 &lt;= hi &lt;= 106 0 &lt;= ki &lt; people.length 题目数据确保队列可以被重建 题目来源： https://leetcode.cn/problems/queue-reconstruction-by-height/description/ 题解：class Solution { public int[][] reconstructQueue(int[][] people) { //先对数组元素进行排序，先按照身高排序，从高到低排序，高度相同的元素按照第二个元素从低到高排列 Arrays.sort(people,(a,b)-&gt;{ if(a[0]==b[0])return a[1]-b[1]; return b[0]-a[0]; }); LinkedList&lt;int[]&gt; que=new LinkedList&lt;&gt;(); //将排序完成的数组从左至右开始按照插入到一个新的数组中，被插入位置的元素及其之后的元素集体后移，因此这里使用链表实现。插入的位置依照元素的第二个下标元素的大小。比如[x,1]插入一号位置。之所以从左至右选择元素进行插入是因为，后面插入的小元素不会影响前面大元素的相对位置要求 for(int[] p:people){ que.add(p[1],p); } return que.toArray(new int[people.length][]); } }","link":"/post/406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html"},{"title":"416.分割等和子集","text":"416.分割等和子集题目描述： 分割等和子集 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 example 1: 输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 example 2: 输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 题目来源：https://leetcode.cn/problems/partition-equal-subset-sum/ 题解：//滚动数组，一维的dp数组 class Solution { public boolean canPartition(int[] nums) { if(nums==null||nums.length==0){ return false; } int sum=0; for(int num:nums){ sum+=num; } //是奇数，必无法分割成两个等和的子数组 if(sum%2==1){ return false; } //背包大小即为和 //物品重量为nums[i],物品价值为nums[i] int target=sum/2; int[] dp=new int[target+1]; for(int i=nums[0];i&lt;=target;i++){ dp[i]=nums[0]; } for(int i=1;i&lt;nums.length;i++){ for(int j=target;j&gt;=nums[i];j--){ //为了防止覆盖问题，背包容量从后往前遍历 dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]); } } return dp[target]==target; } } //01背包，二维dp数组 class Solution { public boolean canPartition(int[] nums) { if(nums==null||nums.length==0){ return false; } int sum=0; for(int num:nums){ sum+=num; } if(sum%2==1){ return false; } int target=sum/2; int[][] dp=new int[nums.length][target+1]; //dp数组初始化 for(int i=nums[0];i&lt;=target;i++){ dp[0][i]=nums[0]; } //遍历物品从第一个开始，因为初始化的时候第0个已经遍历过了 for(int i=1;i&lt;nums.length;i++){ for(int j=1;j&lt;=target;j++){ if(j&lt;nums[i]){ dp[i][j]=dp[i-1][j]; }else{ dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]); } } } return dp[nums.length-1][target]==target; } }","link":"/post/416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html"},{"title":"42.接雨水","text":"题目描述： 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水 example1: 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 example 2: 输入：height = [4,2,0,3,2,5] 输出：9 提示： n == height.length 1 &lt;= n &lt;= 2 * 104 0 &lt;= height[i] &lt;= 105 题目来源： https://leetcode.cn/problems/trapping-rain-water/description/ 题解：//动态规划，若不使用动态规划，则在每一次求左右最大柱子高度的时候都需要在两边进行遍历，时间复杂度较高 class Solution { public int trap(int[] height) { int length = height.length; if (length &lt;= 2) return 0; //相当于两个dp数组，dp[i]表示i位置当前位置及其左边元素中的最大元素 int[] maxLeft = new int[length]; int[] maxRight = new int[length]; // 记录每个柱子左边柱子最大高度 maxLeft[0] = height[0]; for (int i = 1; i&lt; length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]); // 记录每个柱子右边柱子最大高度 maxRight[length - 1] = height[length - 1]; for(int i = length - 2; i &gt;= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]); // 求和 //根据列来求总的雨水量，每一列的雨水量=（min(左边最大柱子高度，右边最高的柱子高度)-当前位置的柱子高度）*柱子宽度 //从头遍历每一列，然后求出每一列的雨水量进行累加即可 int sum = 0; for (int i = 0; i &lt; length; i++) { int count = Math.min(maxLeft[i], maxRight[i]) - height[i]; if (count &gt; 0) sum += count; } return sum; } }","link":"/post/42-%E6%8E%A5%E9%9B%A8%E6%B0%B4.html"},{"title":"435.无重叠区间","text":"435.无重叠区间题目描述： 无重叠区间 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。 example 1： 输入: intervals = [[1,2],[2,3],[3,4],[1,3]] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 example 2: 输入: intervals = [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 example 3: 输入: intervals = [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 提示： 1 &lt;= intervals.length &lt;= 105 intervals[i].length == 2 -5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104 题目来源： https://leetcode.cn/problems/non-overlapping-intervals/ 题解：class Solution { public int eraseOverlapIntervals(int[][] intervals) { //对数组元素按照下标一号元素进行升序排序 Arrays.sort(intervals,(a,b)-&gt;{ return Integer.compare(a[0],b[0]); }); int num=1; for(int i=1;i&lt;intervals.length;i++){ if(intervals[i-1][1]&lt;=intervals[i][0]){ num++; }else{ intervals[i][1]=Math.min(intervals[i-1][1],intervals[i][1]); } } return intervals.length-num; } }","link":"/post/435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html"},{"title":"45.跳跃游戏Ⅱ","text":"45.跳跃游戏Ⅱ题目描述： 跳跃游戏 II 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 假设你总是可以到达数组的最后一个位置。 example1 ： 输入: nums = [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 example 2: 输入: nums = [2,3,0,1,4] 输出: 2 提示： 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 1000 题目来源：https://leetcode.cn/problems/jump-game-ii/description/ 题解：class Solution { public int jump(int[] nums) { if(nums==null||nums.length==0||nums.length==1) return 0; //当前的已经跳跃的次数 int count=0; //当前可覆盖的最大区域 int curD=0; //目前可覆盖的最大区域 int maxD=0; for(int i=0;i&lt;nums.length;i++){ //更新最大可覆盖范围 maxD=Math.max(maxD,i+nums[i]); //当前可直接跳到末尾，则跳数加一，并结束循环 if(maxD&gt;=nums.length-1){ count++; break; } //若已经走到当前可覆盖区域的末尾，则更新下一步的可达最大区域 if(i==curD){ curD=maxD; count++; } } return count; } }","link":"/post/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E2%85%A1.html"},{"title":"450.删除二叉搜索树中的节点","text":"450.删除二叉搜索树中的节点题目描述： 删除二叉搜索树中的节点 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 example 1： 输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 另一个正确答案是 [5,2,6,null,4,null,7]。 example 2: 输入: root = [5,3,6,2,4,null,7], key = 0 输出: [5,3,6,2,4,null,7] 解释: 二叉树不包含值为 0 的节点 example 3: 输入: root = [], key = 0 输出: [] 提示： 节点数的范围 [0, 104]. -105 &lt;= Node.val &lt;= 105 节点值唯一 root 是合法的二叉搜索树 -105 &lt;= key &lt;= 105 题目来源：https://leetcode.cn/problems/delete-node-in-a-bst/description/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode deleteNode(TreeNode root, int key) { //节点为空 if(root==null) return null; //若节点大于待删除节点，则更新左子树 if(root.val&gt;key) root.left=deleteNode(root.left,key); //若节点小于待删除节点，则更新右子树 else if(root.val&lt;key) root.right=deleteNode(root.right,key); //当前节点就是待删除节点 else{ //待删除节点为叶子节点，则直接返回null if(root.left==null&amp;&amp;root.right==null) return null; //左孩子为空，右孩子不空，则右孩子覆盖待删除节点 else if(root.left==null&amp;&amp;root.right!=null){ root=root.right; //右孩子为空，左孩子不空，则左孩子覆盖待删除节点 }else if(root.right==null&amp;&amp;root.left!=null){ root=root.left; //左孩子不空，右孩子不空，则将左孩子放到右子树的最左下位置，然后将待删除节点替换为右孩子 }else{ TreeNode temp=root.right; while(temp.left!=null){ temp=temp.left; } temp.left=root.left; root=root.right; } } return root; } }","link":"/post/450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html"},{"title":"452.用最少数量的箭引爆气球","text":"452.用最少数量的箭引爆气球题目描述： 用最少数量的箭引爆气球 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x``start，x``end， 且满足 xstart ≤ x ≤ x``end，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。 example 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：气球可以用2支箭来爆破: -在x = 6处射出箭，击破气球[2,8]和[1,6]。 -在x = 11处发射箭，击破气球[10,16]和[7,12]。 example 2： 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 解释：每个气球需要射出一支箭，总共需要4支箭。 example 3: 输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 解释：气球可以用2支箭来爆破: - 在x = 2处发射箭，击破气球[1,2]和[2,3]。 - 在x = 4处射出箭，击破气球[3,4]和[4,5]。 提示： 1 &lt;= points.length &lt;= 105 points[i].length == 2 -231 &lt;= xstart &lt; xend &lt;= 231 - 1 题目来源： https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/ 题解：class Solution { public int findMinArrowShots(int[][] points) { Arrays.sort(points,(a,b)-&gt;Integer.compare(a[0],b[0])); //初始状态最少需要一根箭 int arrowNum=1; for(int i=1;i&lt;points.length;i++){ //若两个气球没有交集，则需要加一根箭，因为之前那根箭只能射穿之前重叠的所有气球 if(points[i][0]&gt;points[i-1][1]){ arrowNum++; }else{ //若两个气球是有交集的，那么就需要改变一下当前遍历气球的右边界，右边界取当前右边界和上一个气球右边界的最小值，之所以这么选是因为，取最小值可以保证这一支箭可以把所有重叠的气球都射穿，如果不对右边界进行更新，则只能保证气球之间两两重叠，无法保证所有发生重叠的气球都可以使用一只箭矢射穿 points[i][1]=Math.min(points[i-1][1],points[i][1]); } } return arrowNum; } }","link":"/post/452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html"},{"title":"454.四数相加Ⅱ","text":"454.四数相加Ⅱ题目描述： 四数相加 II 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 example 1： 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2] 输出：2 解释： 两个元组如下： 1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 example 2: 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0] 输出：1 提示： n == nums1.lengthn == nums2.lengthn == nums3.lengthn == nums4.length1 &lt;= n &lt;= 200-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228 题目来源：https://leetcode.cn/problems/4sum-ii 题解：class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { HashMap&lt;Integer,Integer&gt; hashMap=new HashMap&lt;&gt;(); //记录可以满足四数相加为0的组合的个数 int res=0; //遍历nums1和nums2元素相加之和，存入map中，key为两数之和，value是key两数之和出现的次数 for(int num1:nums1){ for(int num2:nums2){ int temp=num1+num2; if(hashMap.containsKey(temp)){ hashMap.put(temp,hashMap.get(temp)+1); }else{ hashMap.put(temp,1); } } } //遍历nums3和nums4元素相加之和，检查map中是否存在0-两数之和，如果存在，则表示存在一组满足条件的解，并将res加上map中的value，表示 //存在多个解 for(int num3:nums3){ for(int num4:nums4){ int temp=num3+num4; if(hashMap.containsKey(0-temp)){ res+=hashMap.get(0-temp); } } } return res; } }","link":"/post/454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A1.html"},{"title":"459.重复的子字符串","text":"459.重复的子字符串题目描述： 重复的子字符串 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 example 1: 输入: s = &quot;abab&quot; 输出: true 解释: 可由子串 &quot;ab&quot; 重复两次构成。 example 2: 输入: s = &quot;aba&quot; 输出: false example 3: 输入: s = &quot;abcabcabcabc&quot; 输出: true 解释: 可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。) 提示： 1 &lt;= s.length &lt;= 104 s 由小写英文字母组成 题目来源：https://leetcode.cn/problems/repeated-substring-pattern/ 题解：/* 将两个 ss 连在一起，并移除第一个和最后一个字符。如果 ss 是该字符串的子串，那么 ss 就满足题目要求。 注意到我们证明的是如果 ss 满足题目要求，那么 ss 有这样的性质，而我们使用的方法却是如果 ss 有这样的性质，那么 ss 满足题目要求。因此，只证明了充分性是远远不够的，我们还需要证明必要性。 */ class Solution { public boolean repeatedSubstringPattern(String s) { //将字符串进行拼接，查看拼接完后第二个字符串的位置， return (s+s).indexOf(s,1)!=s.length(); } }","link":"/post/459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{"title":"496.下一个更大元素Ⅰ","text":"496.下一个更大元素Ⅰ问题描述： 下一个更大元素 I nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。 给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。 对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。 返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。 example 1: 输入：nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出：[-1,3,-1] 解释：nums1 中每个值的下一个更大元素如下所述： - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。 - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 example 2: 输入：nums1 = [2,4], nums2 = [1,2,3,4]. 输出：[3,-1] 解释：nums1 中每个值的下一个更大元素如下所述： - 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。 - 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。 提示： 1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 104 nums1和nums2中所有整数 互不相同 nums1 中的所有整数同样出现在 nums2 中 题目来源： https://leetcode.cn/problems/next-greater-element-i/description/ 题解：class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { //先构造单调栈，再构造nums2对应的每个元素下一个最大元素数组，temp_nums2 //存放的是nums2中元素的下标 Deque&lt;Integer&gt; stack=new LinkedList&lt;&gt;(); int[] temp_nums2=new int[nums2.length]; for(int i=0;i&lt;nums2.length;i++){ while(!stack.isEmpty()&amp;&amp;nums2[i]&gt;nums2[stack.peek()]){ temp_nums2[stack.peek()]=nums2[i]; stack.pop(); } stack.push(i); } //根据nums1和temp_nums2构造结果数组，存放nums1中每一个元素的下一个更大元素 int[] res=new int[nums1.length]; for(int m=0;m&lt;nums1.length;m++){ for(int n=0;n&lt;nums2.length;n++){ if(nums1[m]==nums2[n]){ res[m]=temp_nums2[n]; } } } for(int j=0;j&lt;res.length;j++){ if(res[j]==0){ res[j]=-1; } } return res; } }","link":"/post/496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%E2%85%A0.html"},{"title":"501.二叉搜索树中的众数","text":"501.二叉搜索树中的众数题目描述： 二叉搜索树中的众数 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。 如果树中有不止一个众数，可以按 任意顺序 返回。 假定 BST 满足如下定义： 结点左子树中所含节点的值 小于等于 当前节点的值 结点右子树中所含节点的值 大于等于 当前节点的值 左子树和右子树都是二叉搜索树 example 1: 输入：root = [1,null,2,2] 输出：[2] example 2: 输入：root = [0] 输出：[0] 提示： 树中节点的数目在范围 [1, 104] 内 -105 &lt;= Node.val &lt;= 105 题目来源：https://leetcode.cn/problems/find-mode-in-binary-search-tree/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { //存储出现最大次数的元素有哪些 public List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); //记录当前出现次数最多的元素的个数 public int maxCount=0; //记录当前节点元素出现的次数 public int count=0; //记录上一个节点 public TreeNode pre=null; public int[] findMode(TreeNode root) { findMode_1(root); int[] res=new int[list.size()]; for(int i=0;i&lt;list.size();i++){ res[i]=list.get(i); } return res; } //进行中序遍历，并在遍历到该节点时更新当前元素的count，并检查是否需要更新maxCount，如果需要更新maxCount（当前元素Count大于maxCount）则将返回值列表中元素全部清除，若小于maxCount，则不进行更新，若等于maxCount，则将元素加入到resList，即返回列表中。 public void findMode_1(TreeNode node){ if(node==null) return ; findMode_1(node.left); if(pre==null||pre.val!=node.val){ count=1; }else{ count++; } if(count&gt;maxCount){ maxCount=count; list.clear(); list.add(node.val); }else if(count==maxCount){ list.add(node.val); } pre=node; findMode_1(node.right); } }","link":"/post/501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html"},{"title":"509.斐波那契数列","text":"509.斐波那契数列题目描述： 斐波那契数 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给定 n ，请计算 F(n) 。 example 1: 输入：n = 2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 example 2: 输入：n = 3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 example 3: 输入：n = 4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 &lt;= n &lt;= 30 题目来源： https://leetcode.cn/problems/fibonacci-number/description/ 题解：//动态规划 class Solution { public int fib(int n) { if(n&lt;=1) return n; //创建dp数组，用于存储每一次的推导结果 int[] dp=new int[n+1]; dp[0]=0; dp[1]=1; for(int i=2;i&lt;=n;i++){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; } } //递归 class Solution { public int fib(int n) { if(n&lt;=1){ return n; } return fib(n-1)+fib(n-2); } }","link":"/post/509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html"},{"title":"513.找树左下角的值","text":"513.找树左下角的值题目描述： 找树左下角的值 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 example 1： 输入: root = [2,1,3] 输出: 1 example 2: 输入: [1,2,3,4,null,5,6,null,null,7] 输出: 7 提示： 二叉树的节点个数的范围是 [1,104] -231 &lt;= Node.val &lt;= 231 - 1 题目来源： https://leetcode.cn/problems/find-bottom-left-tree-value/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int findBottomLeftValue(TreeNode root) { if(root.left==null&amp;&amp;root.right==null){ return root.val; } int[] deepest=new int[2]; deepest[0]=0; deepest[1]=0; findAllLeftLeaf(root,deepest,1); return deepest[1]; } public void findAllLeftLeaf(TreeNode root,int[] deepest,int depth){ if(root==null) return ; if(root.left==null&amp;&amp;root.right==null) return ; if(root.left!=null&amp;&amp;root.left.left==null&amp;&amp;root.left.right==null){ //若深度更深 if(depth+1&gt;deepest[0]){ deepest[0]=depth+1; deepest[1]=root.left.val; } } findAllLeftLeaf(root.left,deepest,depth+1); findAllLeftLeaf(root.right,deepest,depth+1); } }","link":"/post/513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html"},{"title":"53.最大子数组和","text":"53.最大子数组和题目描述： 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 example 1: 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 example 2: 输入：nums = [1] 输出：1 example 3: 输入：nums = [5,4,-1,7,8] 输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 题目来源:https://leetcode.cn/problems/maximum-subarray/description/ 题解：class Solution { public int maxSubArray(int[] nums) { //每次都更新局部的sum，并且每次都会更新全局的sum，贪心算法就体现在：当局部sum小于等于0时，就重置局部sum，这也是贪心算法的体现【略显牵强】 int max_sum=Integer.MIN_VALUE; int sum_temp=0; for(int i=0;i&lt;nums.length;i++){ //每次都更新sum sum_temp+=nums[i]; //并且每次更新完sum都需要判断当前sum是否是全局最大sum if(sum_temp&gt;max_sum){ max_sum=sum_temp; } //如果当前的局部sum已经小于等于0了，那么就重新统计局部sum， if(sum_temp&lt;=0) sum_temp=0; } return max_sum; } }","link":"/post/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C.html"},{"title":"530.二叉搜索树的最小绝对值差","text":"530.二叉搜索树的最小绝对值差题目描述： 二叉搜索树的最小绝对差 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 example 1： 输入：root = [4,2,6,1,3] 输出：1 example 2: 输入：root = [1,0,48,null,null,12,49] 输出：1 提示： 树中节点的数目范围是 [2, 104] 0 &lt;= Node.val &lt;= 105 题目来源：https://leetcode.cn/problems/minimum-absolute-difference-in-bst/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { //记录当前的最小绝对值之差 public int result=Integer.MAX_VALUE; //记录前一个节点的值 public TreeNode pre=null; public void findMin(TreeNode node){ if(node==null) return; findMin(node.left); if(pre!=null){ result=Math.min(result,node.val-pre.val); } pre=node; findMin(node.right); } public int getMinimumDifference(TreeNode root) { findMin(root); return result; } }","link":"/post/530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%80%BC%E5%B7%AE.html"},{"title":"538. 把二叉搜索树转换为累加树","text":"题目描述： 把二叉搜索树转换为累加树 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同 example 1: 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] example 2: 输入：root = [1,0,2] 输出：[3,3,2] example 3: 输入：root = [0,null,1] 输出：[1,null,1] example 4: 输入：root = [3,2,4,1] 输出：[7,9,4,10] 提示： 树中的节点数介于 0 和 104 之间。 每个节点的值介于 -104 和 104 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 题目来源：https://leetcode.cn/problems/convert-bst-to-greater-tree/description/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int pre=0; public void build(TreeNode root){ if(root==null) return ; build(root.right); root.val+=pre; pre=root.val; build(root.left); } public TreeNode convertBST(TreeNode root) { build(root); return root; } }","link":"/post/538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html"},{"title":"541.反转字符串Ⅱ","text":"541.反转字符串Ⅱ题目描述： 反转字符串 II 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 example 1： 输入：s = &quot;abcdefg&quot;, k = 2 输出：&quot;bacdfeg&quot; example 2: 输入：s = &quot;abcd&quot;, k = 2 输出：&quot;bacd&quot; 提示： 1 &lt;= s.length &lt;= 104 s 仅由小写英文组成 1 &lt;= k &lt;= 104 题目来源：https://leetcode.cn/problems/reverse-string-ii/ 题解：class Solution { public String reverseStr(String s, int k) { char[] ch = s.toCharArray(); // 1. 每隔 2k 个字符的前 k 个字符进行反转，每次循环挑出一个2k区间 for (int i = 0; i&lt; ch.length; i += 2 * k) { // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符 if (i + k &lt;= ch.length) { reverse(ch, i, i + k -1); continue; } // 3. 剩余字符少于 k 个，则将剩余字符全部反转 reverse(ch, i, ch.length - 1); } return new String(ch); } // 定义翻转函数 public void reverse(char[] ch, int i, int j) { for (; i &lt; j; i++, j--) { char temp = ch[i]; ch[i] = ch[j]; ch[j] = temp; } } }","link":"/post/541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1.html"},{"title":"55.跳跃游戏","text":"55.跳跃游戏题目描述： 跳跃游戏 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 example 1: 输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 example 2: 输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示： 1 &lt;= nums.length &lt;= 3 * 104 0 &lt;= nums[i] &lt;= 105 题目来源：https://leetcode.cn/problems/jump-game/description/ 题解：class Solution { public boolean canJump(int[] nums) { //当前可到达的最远距离 int cover=0; if(nums.length==1) return true; //从0到可覆盖的最远位置，这里的最远位置是根据数组元素不断更新的 for(int i=0;i&lt;=cover;i++){ cover=Math.max(i+nums[i],cover); if(cover&gt;=nums.length-1) return true; } return false; } }","link":"/post/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html"},{"title":"56.合并区间","text":"56.合并区间题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 example 1: 输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. example 2: 输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示： 1 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 104 题目来源： https://leetcode.cn/problems/merge-intervals/ 题解：class Solution { public int[][] merge(int[][] intervals) { List&lt;int[]&gt; result=new LinkedList&lt;&gt;(); //按照子数组的左边界进行排序 Arrays.sort(intervals, (x,y)-&gt;Integer.compare(x[0],y[0])); //初始化新子区间的左边界为第一个子区间的左边界 int start=intervals[0][0]; //初始化新子区间的最远边界为第一个子区间的右边界 int rightMaxBound=intervals[0][1]; for(int i=1;i&lt;intervals.length;i++){ //如果当前子区间的左边界大于最大右边界，表示当前区间和前一个区间分割开了 if(intervals[i][0]&gt;rightMaxBound){ //将上一个划分出来的区间加入到结果集合中 result.add(new int[]{start,rightMaxBound}); start=intervals[i][0]; rightMaxBound=intervals[i][1]; }else{ //如果这个遍历到的区间和之前遍历的区间是有重叠的，则更新最大右边界 rightMaxBound=Math.max(rightMaxBound,intervals[i][1]); } } result.add(new int[]{start,rightMaxBound}); return result.toArray(new int[result.size()][]); } }","link":"/post/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html"},{"title":"59.螺旋矩阵Ⅱ","text":"59.螺旋矩阵Ⅱ题目描述： 螺旋矩阵 II 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 example 1: 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] example 2: 输入：n = 1 输出：[[1]] 提示： 1 &lt;= n &lt;= 20 题目来源： https://leetcode.cn/problems/spiral-matrix-ii/ 题解：class Solution { public int[][] generateMatrix(int n) { int[][] ret=new int[n][n]; int offset=1; //每轮循环需要偏移的量，比如第一轮是要预留一个位置，offset=1 int loop=n/2; //需要进行的圈数，比如n=3只需要循环一次，n=6需要循环3次 int mid=n/2; //矩阵的中心位置，比如n=3，中心位置是(1,1) int count=1; //用于给各个位置赋值 int i=0; int j=0; int startx=0; int starty=0; //用于记录每一圈的开始位置 for(;loop&gt;0;loop--){ i=startx; j=starty; //从左向右移动，j小于n-offset，预留一个位置给后面 for(;j&lt;n-offset;j++){ ret[i][j]=count++; } //从上向下移动，预留一个位置给后面 for(;i&lt;n-offset;i++){ ret[i][j]=count++; } //从右向左移动，预留一个位置给后面，注意这里j不是大于0，而是大于starty，因为每一圈的开始位置是在改变的，只有第一圈才是0 for(;j&gt;starty;j--){ ret[i][j]=count++; } //从下向上移动，预留一个位置给后面，注意这里i不是大于0，而是大于startx，因为每一圈的开始位置是在移动的，只有第一圈才是0 for(;i&gt;startx;i--){ ret[i][j]=count++; } //更新便宜量，因为每一圈是在不断缩小的，所以边界是在变化的，所以偏移量也在变化 offset++; //更新下一圈的开始位置 startx++; starty++; } //若n为奇数，则中心会有一个多出的元素，需要进行赋值，其实就是最后一个元素n^2 if(n%2==1){ ret[mid][mid]=n*n; } return ret; } }","link":"/post/59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E2%85%A1.html"},{"title":"617.合并二叉树","text":"617.合并二叉树题目描述： 合并二叉树 给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 example 1: 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] 输出：[3,4,5,5,4,null,7] example 2: 输入：root1 = [1], root2 = [1,2] 输出：[2,2] 提示： 两棵树中的节点数目在范围 [0, 2000] 内 -104 &lt;= Node.val &lt;= 104 题目来源：https://leetcode.cn/problems/merge-two-binary-trees/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode buildTree(TreeNode node1,TreeNode node2){ if(node1==null&amp;&amp;node2==null) return null; TreeNode node; if(node1==null&amp;&amp;node2!=null){ //若node1为空，则构造出的树和node2相同，直接返回node2 return node2; }else if(node1!=null&amp;&amp;node2==null){ return node1; }else{ node=new TreeNode(node1.val+node2.val); node.left=buildTree(node1.left,node2.left); node.right=buildTree(node1.right,node2.right); } return node; } public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { return buildTree(root1,root2); } }","link":"/post/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{"title":"62.不同路径","text":"题目描述： 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ example 1: 输入：m = 3, n = 7 输出：28 example 2: 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向下 example 3: 输入：m = 7, n = 3 输出：28 example 4: 输入：m = 3, n = 3 输出：6 提示： 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 109 题目来源： https://leetcode.cn/problems/unique-paths/description/ 题解：class Solution { public int uniquePaths(int m, int n) { //初始化，表示到达每一个位置的走法 int[][] dp=new int[m][n]; //因为出发位置是（0，0），所以[0][j]和[i][0]只能存在一种走法 for(int i=0;i&lt;m;i++){ dp[i][0]=1; } for(int j=0;j&lt;n;j++){ dp[0][j]=1; } //递推公式：dp[k][s]=dp[k-1][s]+dp[k][s-1] for(int k=1;k&lt;m;k++){ for(int s=1;s&lt;n;s++){ dp[k][s]=dp[k-1][s]+dp[k][s-1]; } } return dp[m-1][n-1]; } }","link":"/post/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html"},{"title":"62.爬楼梯","text":"62.爬楼梯题目描述： 不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ example 1: 输入：m = 3, n = 7 输出：28 example 2: 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向下 example 3： 输入：m = 7, n = 3 输出：28 example 4: 输入：m = 3, n = 3 输出：6 提示： 题目来源：https://leetcode.cn/problems/unique-paths 题解：class Solution { public int uniquePaths(int m, int n) { //检查参数合法性 if(m==0||n==0){ return 0; } //定义dp数组，其中dp[i][j]表示的是从(0,0)点到达(i,j)点所存在的路径的数量 int[][] dp=new int[m][n]; //对dp进行初始化，dp[i][0]和dp[0][i]都初始化为1，因为从（0，0）点出发都是一条路径，因为机器人只能向下或者向右移动。 for(int i=0;i&lt;m;i++){ dp[i][0]=1; } for(int j=0;j&lt;n;j++){ dp[0][j]=1; } //确定状态变化公式：dp[i][j]=dp[i-1][j]+dp[i][j-1];因为到达i，j一共就两个方向 for(int i=1;i&lt;m;i++){ for(int j=1;j&lt;n;j++){ dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } return dp[m-1][n-1]; } }","link":"/post/62-%E7%88%AC%E6%A5%BC%E6%A2%AF.html"},{"title":"63.不同路径Ⅱ","text":"63.不同路径Ⅱ题目描述： 不同路径 II 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 example 1: 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释：3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 example 2: 输入：obstacleGrid = [[0,1],[0,0]] 输出：1 提示： m == obstacleGrid.lengthn == obstacleGrid[i].length1 &lt;= m, n &lt;= 100obstacleGrid[i][j] 为 0 或 1 题目来源：https://leetcode.cn/problems/unique-paths-ii 题解： 初始版本 class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { //若传入的数组为空，或者起始位置就是障碍物，那么就直接返回0，没有路径可以到达 if(obstacleGrid==null||obstacleGrid.length==0||obstacleGrid[0][0]==1){ return 0; } //构造dp数组，数组元素是每一个格子的不同路径 int[][] dp=new int[obstacleGrid.length][obstacleGrid[0].length]; //初始化第一行和第一列的路径数 //如果在第一行或者第一列中遇到了障碍物，则直接停止初始化，因为障碍物后面的格子没办法到达，默认初始化为0 for(int i=0;i&lt;obstacleGrid.length;i++){ if(obstacleGrid[i][0]==1){ break; }else{ dp[i][0]=1; } } for(int j=0;j&lt;obstacleGrid[0].length;j++){ if(obstacleGrid[0][j]==1){ break; }else{ dp[0][j]=1; } } //从[1][1]位置开始初始化，动态规划公式dp[m][n]=dp[m-1][n]+dp[m][n-1] for(int m=1;m&lt;obstacleGrid.length;m++){ for(int n=1;n&lt;obstacleGrid[0].length;n++){ if(obstacleGrid[m][n]==1){ dp[m][n]=0; } else{ dp[m][n]=dp[m-1][n]+dp[m][n-1]; } } } //返回右下角位置的路径数量 return dp[obstacleGrid.length-1][obstacleGrid[0].length-1]; } } 简化版本 class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { if(obstacleGrid==null||obstacleGrid.length==0||obstacleGrid[0].length==0){ return 0; } int m=obstacleGrid.length; int n=obstacleGrid[0].length; //定义dp数组，dp[i][j]表示从(0,0)出发到达（i，j）所包含的路线数 int[][] dp=new int[m][n]; //对dp数组进行初始化，注意，dp[i][0]和dp[0][j]为1，若遇到障碍，则为0。 for(int i=0;i&lt;m&amp;&amp;obstacleGrid[i][0]==0;i++){ dp[i][0]=1; } for(int j=0;j&lt;n&amp;&amp;obstacleGrid[0][j]==0;j++){ dp[0][j]=1; } //dp[i][j]=dp[i-1][j]+dp[i][j-1] for(int i=1;i&lt;m;i++){ for(int j=1;j&lt;n;j++){ //若当前遍历的位置（i,j）不是障碍时，才进行赋值 if(obstacleGrid[i][j]!=1){ dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } } return dp[m-1][n-1]; } }","link":"/post/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1.html"},{"title":"654.最大二叉树","text":"654.最大二叉树题目描述： 最大二叉树 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 *最大二叉树* 。 example 1： 输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 example 2: 输入：nums = [3,2,1] 输出：[3,null,2,null,1] 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 nums 中的所有整数 互不相同 题目来源：https://leetcode.cn/problems/maximum-binary-tree 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { //递归函数 public TreeNode buildTree(int[] nums,int start,int end){ //若超出范围，则表示没有节点，则返回null if(start&gt;=end){ return null; } //循环找出当前数组范围内的最大值及其下标 int max=-1; int index_max=-1; for(int i=start;i&lt;end;i++){ if(nums[i]&gt;max){ max=nums[i]; index_max=i; } } //构造节点 TreeNode node=new TreeNode(max); //递归构造左子树，注意传入的区间参数，左闭右开 node.left=buildTree(nums,start,index_max); //左闭右开 node.right=buildTree(nums,index_max+1,end); return node; } public TreeNode constructMaximumBinaryTree(int[] nums) { if(nums==null) return null; //左闭右开 return buildTree(nums,0,nums.length); } }","link":"/post/654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{"title":"669.修剪二叉搜索树","text":"669.修剪二叉搜索树题目描述： 修剪二叉搜索树 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 example 1: 输入：root = [1,0,2], low = 1, high = 2 输出：[1,null,2] example 2: 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3 输出：[3,2,null,1] 提示： 树中节点数在范围 [1, 104] 内 0 &lt;= Node.val &lt;= 104 树中每个节点的值都是 唯一 的 题目数据保证输入是一棵有效的二叉搜索树 0 &lt;= low &lt;= high &lt;= 104 题目来源： https://leetcode.cn/problems/trim-a-binary-search-tree/description/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { //若当前节点为空，则返回null if(root==null) return null; //若当前节点值小于下界，则表示该节点的左子树均小于下界（二叉搜索树），需要对该节点的右子树再次剪枝 if(root.val&lt;low){ TreeNode right=trimBST(root.right,low,high); return right; } //若当前节点值大于下界，则表示该节点的右子树均大于下界（二叉搜索树），需要对该节点的左子树再次剪枝 if(root.val&gt;high){ TreeNode left=trimBST(root.left,low,high); return left; } //若该节点的val符合要求，则对其左右子树再次剪枝 root.left=trimBST(root.left,low,high); root.right=trimBST(root.right,low,high); return root; } }","link":"/post/669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"},{"title":"70.爬楼梯","text":"70.爬楼梯题目描述： 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ example 1: 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 example 2: 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 提示： 1 &lt;= n &lt;= 45 题目来源：https://leetcode.cn/problems/climbing-stairs/ 题解：class Solution { public int climbStairs(int n) { if(n&lt;=2){ return n; } //定义dp数组 int[] dp=new int[n+1]; dp[0]=0; dp[1]=1; dp[2]=2; for(int i=3;i&lt;=n;i++){ //递推公式：dp[i]=dp[i-1]+dp[i-2] dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; } }","link":"/post/70-%E7%88%AC%E6%A5%BC%E6%A2%AF.html"},{"title":"700.二叉搜索树中的搜索","text":"700.二叉搜索树中的搜索题目描述： 二叉搜索树中的搜索 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 example 1： 输入：root = [4,2,7,1,3], val = 2 输出：[2,1,3] example 2: 输入：root = [4,2,7,1,3], val = 5 输出：[] 提示： 数中节点数在 [1, 5000] 范围内 1 &lt;= Node.val &lt;= 107 root 是二叉搜索树 1 &lt;= val &lt;= 107 题目来源：https://leetcode.cn/problems/search-in-a-binary-search-tree/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode findTree(TreeNode node,int val){ if(node==null) return null; if(node.val==val) return node; if(node.val&lt;val){ return findTree(node.right,val); } return findTree(node.left,val); } public TreeNode searchBST(TreeNode root, int val) { return findTree(root,val); } }","link":"/post/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html"},{"title":"701.二叉搜索树中的插入操作","text":"701.二叉搜索树中的插入操作题目描述： 二叉搜索树中的插入操作 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。 example 1: 输入：root = [4,2,7,1,3], val = 5 输出：[4,2,7,1,3,5] example 2: 输入：root = [40,20,60,10,30,50,70], val = 25 输出：[40,20,60,10,30,50,70,null,null,25] example 3: 输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5 输出：[4,2,7,1,3,5] 提示： 树中的节点数将在 [0, 104]的范围内。 -108 &lt;= Node.val &lt;= 108 所有值 Node.val 是 独一无二 的。 -108 &lt;= val &lt;= 108 保证 val 在原始BST中不存在 题目来源： https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { //若当前二叉搜索树为空，则创建新节点，并返回 if(root==null) return new TreeNode(val); //记录树的根节点，创建前驱节点 TreeNode newRoot=root; TreeNode pre=null; //当活动节点不为null时进行循环遍历 while(root!=null){ //记录当前位置 pre=root; //若当前节点val大于val则表示插入元素应该在当前节点的左子树 if(root.val&gt;val){ root=root.left; }else{ root=root.right; } } //当root=null时跳出循环，此时pre指向的是叶子节点，若叶子节点的val大于插入元素，则作为左孩子，否则作为右孩子 if(pre.val&gt;val){ pre.left=new TreeNode(val); }else{ pre.right=new TreeNode(val); } return newRoot; } }","link":"/post/701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html"},{"title":"714.买卖股票的最佳时机含手续费","text":"714.买卖股票的最佳时机含手续费问题描述： 买卖股票的最佳时机含手续费 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 example 1: 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 example 2: 输入：prices = [1,3,7,5,10,3], fee = 3 输出：6 提示： 1 &lt;= prices.length &lt;= 5 * 104 1 &lt;= prices[i] &lt; 5 * 104 0 &lt;= fee &lt; 5 * 104 题目来源： https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/ 题解：class Solution { public int maxProfit(int[] prices, int fee) { int result=0; int minPrice=prices[0]; //记录最低价格 for(int i=1;i&lt;prices.length;i++){ //记录股票最小价格 if(prices[i]&lt;minPrice) minPrice=prices[i]; //如果当前遍历到的股票价格无法获得收益,就不更新 if(prices[i]&gt;=minPrice&amp;&amp;prices[i]&lt;=minPrice+fee){ continue; } //计算利润，注意，这里获得利润不一定是直接将股票卖出了 if(prices[i]&gt;minPrice+fee){ result+=prices[i]-minPrice-fee; //收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润。 minPrice=prices[i]-fee; } } return result; } }","link":"/post/714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html"},{"title":"","text":"title: 738.单调递增数字date: 2022-12-24 21:33:47categories: 数据结构与算法tags: Java leetcode 贪心算法 738.单调递增数字题目描述： 单调递增的数字 当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。 给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。 example 1: 输入: n = 10 输出: 9 example 2: 输入: n = 1234 输出: 1234 example 3: 输入: n = 332 输出: 299 提示： 0 &lt;= n &lt;= 109 题目来源： https://leetcode.cn/problems/monotone-increasing-digits/description/ 题解：class Solution { //贪心算法，如果出现前一位大于后一位的情况，即出现非递增的情况，则前一位减一，后一位变成9，即可获得小于n的最大的递增数字 public int monotoneIncreasingDigits(int n) { String s=String.valueOf(n); //转化为字符串，并转化为字符数组 char[] chars=s.toCharArray(); //标记第一个9的位置，方便后面对9进行统一赋值 int start=s.length(); //遍历每一位数字，当出现前一位大于后一位的情况时，更新9的位置，并将前一位数字减一 for(int i=s.length()-2;i&gt;=0;i--){ if(chars[i]&gt;chars[i+1]){ start=i+1; chars[i]--; } } //对9进行统一赋值 for(int i=start;i&lt;s.length();i++){ chars[i]='9'; } //字符数组转换为整数并输出 return Integer.parseInt(String.valueOf(chars)); } }","link":"/post/738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E6%95%B0%E5%AD%97.html"},{"title":"739.每日温度","text":"739.每日温度问题描述： 每日温度 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。 example 1: 输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0] example 2: 输入: temperatures = [30,40,50,60] 输出: [1,1,1,0] example 3: 输入: temperatures = [30,60,90] 输出: [1,1,0] 提示： 1 &lt;= temperatures.length &lt;= 105 30 &lt;= temperatures[i] &lt;= 100 题目来源： https://leetcode.cn/problems/daily-temperatures/description/ 题解：//通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了 class Solution { public int[] dailyTemperatures(int[] temperatures) { int lens=temperatures.length; int []res=new int[lens]; /** 如果当前遍历的元素 大于栈顶元素，表示 栈顶元素的 右边的最大的元素就是 当前遍历的元素， 所以弹出 栈顶元素，并记录 如果栈不空的话，还要考虑新的栈顶与当前元素的大小关系 否则的话，可以直接入栈。 注意，单调栈里 加入的元素是 下标。 */ Deque&lt;Integer&gt; stack=new LinkedList&lt;&gt;(); stack.push(0); for(int i=1;i&lt;lens;i++){ if(temperatures[i]&lt;=temperatures[stack.peek()]){ stack.push(i); }else{ while(!stack.isEmpty()&amp;&amp;temperatures[i]&gt;temperatures[stack.peek()]){ res[stack.peek()]=i-stack.peek(); stack.pop(); } stack.push(i); } } return res; } }","link":"/post/739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html"},{"title":"746.使用最小的花费爬楼梯","text":"746.花费最小的花费爬楼梯题目描述： 使用最小花费爬楼梯 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。 请你计算并返回达到楼梯顶部的最低花费。 example 1： 输入：cost = [10,15,20] 输出：15 解释：你将从下标为 1 的台阶开始。 - 支付 15 ，向上爬两个台阶，到达楼梯顶部。 总花费为 15 。 example 2: 输入：cost = [1,100,1,1,1,100,1,1,100,1] 输出：6 解释：你将从下标为 0 的台阶开始。 - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。 - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。 - 支付 1 ，向上爬一个台阶，到达楼梯顶部。 总花费为 6 。 提示： 2 &lt;= cost.length &lt;= 1000 0 &lt;= cost[i] &lt;= 999 题目来源：https://leetcode.cn/problems/min-cost-climbing-stairs 题解：class Solution { public int minCostClimbingStairs(int[] cost) { //检查参数的合法性 if(cost==null||cost.length==0){ return 0; } //dp数组的长度和花费数组的长度一致 int[] dp=new int[cost.length]; //dp数组初始化，第0节台阶花费cost[0]（每次登上一节）,登上第1节台阶花费cost[1](每次登上两节) dp[0]=cost[0]; dp[1]=cost[1]; //递推直到cost.length-1节台阶 for(int i=2;i&lt;cost.length;i++){ dp[i]=Math.min(dp[i-1],dp[i-2])+cost[i]; } //因为登上最后一节台阶是不费力的，所以选择dp末尾两个的最小值即可。 return Math.min(dp[cost.length-1],dp[cost.length-2]); } }","link":"/post/746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E7%9A%84%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html"},{"title":"75.颜色排序--单指针","text":"75. 颜色排序–单指针题目描述：Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library’s sort function. example 1: Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] example 2: Input: nums = [2,0,1] Output: [0,1,2] 题解：class Solution { public void sortColors(int[] nums) { int index=0; //确定0的位置 for(int i=0;i&lt;nums.length;i++){ if(nums[i]==0){ swap(nums,i,index++); } } //确定1的位置 for(int j=index;j&lt;nums.length;j++){ if(nums[j]==1){ swap(nums,j,index++); } } } public void swap(int[] nums,int left,int right){ int temp=nums[left]; nums[left]=nums[right]; nums[right]=temp; } }","link":"/post/75SortColors01.html"},{"title":"","text":"title: 763.划分字母区间date: 2022-12-22 11:39:57categories: 数据结构与算法tags: Java leetcode 贪心算法 763.划分字母区间题目描述： 划分字母区间 给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。 返回一个表示每个字符串片段的长度的列表。 example 1: 输入：s = &quot;ababcbacadefegdehijhklij&quot; 输出：[9,7,8] 解释： 划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。 每个字母最多出现在一个片段中。 像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 example 2: 输入：s = &quot;eccbbbbdec&quot; 输出：[10] 提示： 1 &lt;= s.length &lt;= 500 s 仅由小写英文字母组成 题目来源： https://leetcode.cn/problems/partition-labels/description/ 题解：class Solution { public List&lt;Integer&gt; partitionLabels(String s) { //创建列表，用于最后划分的各个区间长度 List&lt;Integer&gt; list=new LinkedList&lt;&gt;(); //存储每个字符的最远边界 int[] edge=new int[26]; //将字符串转换为字符数组 char[] chars=s.toCharArray(); //获取每个字符的最远边界 for(int i=0;i&lt;chars.length;i++){ edge[chars[i]-'a']=i; } //当前遍历过的字符的最远边界 int temp_edge=0; //前一次划分的区间的边界 int last=-1; for(int i=0;i&lt;chars.length;i++){ //更新字符的最远边界 temp_edge=Math.max(temp_edge,edge[chars[i]-'a']); //如果已经到达了最远边界，则可以进行区间的划分了，由于这个tempt_edge是当前遍历字符的最远边界，表示其中字符的最远边界均小于或等于temp_edge,因此划分完成之后，其中包含的字符必定都在这个区间之内了 if(i==temp_edge){ list.add(i-last); last=i; } } return list; } }","link":"/post/763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html"},{"title":"77.组合","text":"77.组合题目描述： 组合 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 example 1： 输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] exmaple 2: 输入：n = 1, k = 1 输出：[[1]] 提示： 1 &lt;= n &lt;= 20 1 &lt;= k &lt;= n 题目来源：https://leetcode.cn/problems/combinations/description/ 题解：class Solution { public List&lt;List&lt;Integer&gt;&gt; result=new LinkedList&lt;&gt;(); public LinkedList&lt;Integer&gt; path=new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { getResult(n,k,1); return result; } public void getResult(int n,int k,int startIndex){ //若路径上的元素个数达到k个，则加入结果集 if(path.size()==k){ result.add(new ArrayList(path)); return ; } //减枝操作，剩余所需元素个数为k-path.size个 for(int i=startIndex;i&lt;=n-(k-path.size())+1;i++){ path.add(i); getResult(n,k,i+1); path.removeLast(); } } }","link":"/post/77-%E7%BB%84%E5%90%88.html"},{"title":"78.子集","text":"78.子集问题描述：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 example 1: 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] example 2: 输入：nums = [0] 输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 nums 中的所有元素 互不相同 题目来源： https://leetcode.cn/problems/subsets/ 题解：class Solution { List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; path=new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { getSubSet(nums,0); return result; } public void getSubSet(int[] nums,int startIndex){ //记录所有子集，包括空集 result.add(new LinkedList&lt;&gt;(path)); for(int i=startIndex;i&lt;nums.length;i++){ path.add(nums[i]); getSubSet(nums,i+1); path.removeLast(); } } }","link":"/post/78-%E5%AD%90%E9%9B%86.html"},{"title":"84.柱状图中最大的矩形","text":"84.柱状图中最大的矩形题目描述： 柱状图中最大的矩形 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 example 1: 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 example 2: 输入： heights = [2,4] 输出： 4 提示： 1 &lt;= heights.length &lt;=105 0 &lt;= heights[i] &lt;= 104 题目描述： https://leetcode.cn/problems/largest-rectangle-in-histogram/description/ 题解：class Solution { public int largestRectangleArea(int[] heights) { //由于最大面积=MAX(height[i]*(minRight[i]-minLeft[i]-1))求得，其中，minLeft[i]表示柱子i左边第一个高度小于i的柱子的下标，minRight表示柱子i右边第一个高度小于i的柱子的下标 int[] minLeft=new int[heights.length]; int[] minRight=new int[heights.length]; //构造两个数组 int length=heights.length; minLeft[0]=-1; //左数组，从0开始，在确定每一个柱子左边的第一根短柱子时都需要进行一次while循环。找到第一个小于柱子i的柱子下标，并赋值 for(int i=0;i&lt;length;i++){ int t=i-1; while(t&gt;=0&amp;&amp;heights[t]&gt;=heights[i]){ t=minLeft[t]; } minLeft[i]=t; } //右数组，从length-1开始，同左数组不断确定数组元素 minRight[length-1]=length; for(int i=length-2;i&gt;=0;i--){ int t=i+1; while(t&lt;length&amp;&amp;heights[t]&gt;=heights[i]){ t=minRight[t]; } minRight[i]=t; } //根据开头的公式，求得heights中的最大的矩形面积 int result=0; for(int i=0;i&lt;length;i++){ int sum=heights[i]*(minRight[i]-minLeft[i]-1); result=Math.max(sum,result); } return result; } }","link":"/post/84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html"},{"title":"860.柠檬水找零","text":"860.柠檬水找零题目描述： 柠檬水找零 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 example 1： 输入：bills = [5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。 example 2: 输入：bills = [5,5,10,10,20] 输出：false 解释： 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。 由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 1 &lt;= bills.length &lt;= 105 bills[i] 不是 5 就是 10 或是 20 题目来源：https://leetcode.cn/problems/lemonade-change/description/ 题解：class Solution { public boolean lemonadeChange(int[] bills) { //初始三类纸币数量都为0 int[] restChange=new int[3]; //当5元和10元的纸币数量为负数时，返回false，否则为true for(int i=0;i&lt;bills.length;i++){ //先找钱 //计算需要找的钱 int change=bills[i]-5; if(change==5) restChange[0]--; if(change==15){ //注意当我需要找15元的时候，有十块时，找钱的组合是10+5，没10块时，找钱的组合是5+5+5 if(restChange[1]&gt;0){ restChange[1]--; restChange[0]--; }else{ restChange[0]-=3; } } //后收钱 if(bills[i]==5) restChange[0]++; if(bills[i]==10) restChange[1]++; if(bills[i]==20) restChange[2]++; if(restChange[0]&lt;0||restChange[1]&lt;0){ return false; } } return true; } }","link":"/post/860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html"},{"title":"90.子集Ⅱ","text":"90.子集Ⅱ题目描述：90.子集 II 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 example 1： 输入：nums = [1,2,2] 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] example 2: 输入：nums = [0] 输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 题目来源： https://leetcode.cn/problems/subsets-ii/description/ 题解：class Solution { //本题和子集Ⅰ的那一题的区别在于，本次的nums数组中包含重复元素，需要进行去重操作，完成该操作的手段是通过对nums进行排序，则加入元素之前判断前一个元素和当前元素是否相同，如果相同，且没有使用过，则跳过该元素的选取 List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();// 存放符合条件结果的集合 LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();// 用来存放符合条件结果 boolean[] used; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { if (nums.length == 0){ result.add(path); return result; } Arrays.sort(nums); used = new boolean[nums.length]; subsetsWithDupHelper(nums, 0); return result; } private void subsetsWithDupHelper(int[] nums, int startIndex){ result.add(new ArrayList&lt;&gt;(path)); if (startIndex &gt;= nums.length){ return; } //used为true则表示使用过了，表示上一个元素和该元素位于不同的层次，此时可以出现重复数字，若used为false，则表示上一个元素已经被选取过了，该元素和上一个元素位于同一层，就不可以出现重复数字。通过下面的if判断完成去重的操作 for (int i = startIndex; i &lt; nums.length; i++){ if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]){ continue; } path.add(nums[i]); used[i] = true; subsetsWithDupHelper(nums, i + 1); path.removeLast(); used[i] = false; } } }","link":"/post/90-%E5%AD%90%E9%9B%86%E2%85%A1.html"},{"title":"93.复原IP地址","text":"93.复原IP地址问题描述： 复原 IP 地址 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。 例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 example 1： 输入：s = &quot;25525511135&quot; 输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;] example 2: 输入：s = &quot;0000&quot; 输出：[&quot;0.0.0.0&quot;] example 3： 输入：s = &quot;101023&quot; 输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;] 提示： 1 &lt;= s.length &lt;= 20 s 仅由数字组成 问题来源：https://leetcode.cn/problems/restore-ip-addresses/description/ 题解：class Solution { List&lt;String&gt; result = new ArrayList&lt;&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) { if (s.length() &gt; 12) return result; // 算是剪枝了 backTrack(s, 0, 0); return result; } // startIndex: 搜索的起始位置， pointNum:添加逗点的数量 private void backTrack(String s, int startIndex, int pointNum) { if (pointNum == 3) {// 逗点数量为3时，分隔结束 // 判断第四段⼦字符串是否合法，如果合法就放进result中 if (isValid(s,startIndex,s.length()-1)) { result.add(s); } return; } for (int i = startIndex; i &lt; s.length(); i++) { if (isValid(s, startIndex, i)) { s = s.substring(0, i + 1) + &quot;.&quot; + s.substring(i + 1); //在str的后⾯插⼊⼀个逗点 pointNum++; backTrack(s, i + 2, pointNum);// 插⼊逗点之后下⼀个⼦串的起始位置为i+2 pointNum--;// 回溯 s = s.substring(0, i + 1) + s.substring(i + 2);// 回溯删掉逗点 } else { break; } } } // 判断字符串s在左闭⼜闭区间[start, end]所组成的数字是否合法 private Boolean isValid(String s, int start, int end) { if (start &gt; end) { return false; } if (s.charAt(start) == '0' &amp;&amp; start != end) { // 0开头的数字不合法 return false; } int num = 0; for (int i = start; i &lt;= end; i++) { if (s.charAt(i) &gt; '9' || s.charAt(i) &lt; '0') { // 遇到⾮数字字符不合法 return false; } num = num * 10 + (s.charAt(i) - '0'); if (num &gt; 255) { // 如果⼤于255了不合法 return false; } } return true; } }","link":"/post/93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html"},{"title":"94-145-144-二叉树的中后前序遍历-迭代法","text":"94&amp;145&amp;144.二叉树的中后前序遍历题目描述[中]： 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 example 1: 输入：root = [1,null,2,3] 输出：[1,3,2] example 2: 输入：root = [] 输出：[] example 3: 输入：root = [1] 输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 题目来源：https://leetcode.cn/problems/binary-tree-inorder-traversal/ 题解[中]：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { /** 中序遍历为，左中右，所以和前序遍历不同，需要先从根节点开始，一直向左下遍历，遍历到最后一个左下结点，边遍历边入栈，当没有左孩子了，就将栈顶元素出栈，访问节点的value，并指向该节点的右孩子。 */ public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result=new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); if(root==null) return result; TreeNode p=root; while(p!=null||!stack.isEmpty()){ if(p!=null){ stack.push(p); p=p.left; }else{ p=stack.pop(); result.add(p.val); p=p.right; } } return result; } } 题目描述[后]： 二叉树的后序遍历 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。 example 1: 输入：root = [1,null,2,3] 输出：[3,2,1] example 2: 输入：root = [] 输出：[] example 3: 输入：root = [1] 输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 题目来源：https://leetcode.cn/problems/binary-tree-postorder-traversal/ 题解[后]：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { /** 只要在先序遍历迭代法的基础上进行修改即可，先入左孩子，再入右孩子。最后遍历完成后，对得到的列表元素进行反转，即可得到后序遍历序列 */ public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result=new ArrayList&lt;&gt;(); if(root==null) return result; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()){ TreeNode node=stack.pop(); result.add(node.val); if(node.left!=null) stack.push(node.left); if(node.right!=null) stack.push(node.right); } Collections.reverse(result); return result; } } 题目描述[前]： 二叉树的前序遍历 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 example 1: 输入：root = [1,null,2,3] 输出：[1,2,3] example 2: 输入：root = [] 输出：[] example 3: 输入：root = [1] 输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 题目来源：https://leetcode.cn/problems/binary-tree-preorder-traversal/ 题解[前]：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { /** 使用栈实现前序遍历，首先根节点入栈，开始循环，先出栈，访问出栈节点value，然后右孩子入栈，然后左孩子入栈，开始下一轮循环。之所以先右如，后左如，是为了保证出栈时先访问左孩子，后访问右孩子。 */ public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result=new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); if(root==null) return result; stack.push(root); while(!stack.isEmpty()){ TreeNode node=stack.pop(); result.add(node.val); if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); } return result; } }","link":"/post/94-145-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%90%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E6%B3%95.html"},{"title":"94&145&144.二叉树的中后前序遍历","text":"94&amp;145&amp;144.二叉树的中后前序遍历题目描述[中]： 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 example 1: 输入：root = [1,null,2,3] 输出：[1,3,2] example 2: 输入：root = [] 输出：[] example 3: 输入：root = [1] 输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 题目来源：https://leetcode.cn/problems/binary-tree-inorder-traversal/ 题解[中]：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void inOrder(TreeNode root,List&lt;Integer&gt; result){ if(root==null) return; inOrder(root.left,result); result.add(root.val); inOrder(root.right,result); } public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result=new ArrayList&lt;&gt;(); inOrder(root,result); return result; } } 题目描述[后]： 二叉树的后序遍历 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。 example 1: 输入：root = [1,null,2,3] 输出：[3,2,1] example 2: 输入：root = [] 输出：[] example 3: 输入：root = [1] 输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 题目来源：https://leetcode.cn/problems/binary-tree-postorder-traversal/ 题解[后]：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void postOrder(TreeNode root,List&lt;Integer&gt; result){ if(root==null) return ; postOrder(root.left,result); postOrder(root.right,result); result.add(root.val); } public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result=new ArrayList&lt;&gt;(); postOrder(root,result); return result; } } 题目描述[前]： 二叉树的前序遍历 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 example 1: 输入：root = [1,null,2,3] 输出：[1,2,3] example 2: 输入：root = [] 输出：[] example 3: 输入：root = [1] 输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 题目来源：https://leetcode.cn/problems/binary-tree-preorder-traversal/ 题解[前]：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void preOrder(TreeNode root,List&lt;Integer&gt; result){ if(root==null) return; result.add(root.val); preOrder(root.left,result); preOrder(root.right,result); } public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result=new ArrayList&lt;&gt;(); preOrder(root,result); return result; } }","link":"/post/94-145-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%90%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.html"},{"title":"96.不同的二叉搜索树","text":"96.不同的二叉搜索树题目描述： 不同的二叉搜索树 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 example 1: 输入：n = 3 输出：5 example 2: 输入：n = 1 输出：1 提示： 1 &lt;= n &lt;= 19 题目来源：https://leetcode.cn/problems/unique-binary-search-trees/ 题解： 2023/1/25 class Solution { public int numTrees(int n) { if(n&lt;=1){ return n; } //dp数组，dp[i]表示由i个节点可能组成的二叉树个数 int[] dp=new int[n+1]; dp[0]=1; dp[1]=1; dp[2]=2; //当前二叉树结构个数=左子树结构数量*右子树结构数量 for(int i=3;i&lt;=n;i++){ for(int j=0;j&lt;=i-1;j++){ dp[i]+=dp[j]*dp[i-j-1]; } } return dp[n]; } } class Solution { public int numTrees(int n) { //定义dp数组 int[] dp=new int[n+1]; //dp的初始值：当有0个节点时，看作一个空的二叉树，dp[0]=1；当有一个节点时，dp[1]=1; dp[0]=1; dp[1]=1; //状态公式：dp[i]+=dp[j-1]*dp[i-j]; //j表示当前二叉搜索树的头节点，dp[j-1]和dp[i-j]分别表示其左右子树的二叉搜索树个数 //详情见https://gitee.com/programmercarl/leetcode-master/blob/master/problems/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md for(int i=2;i&lt;=n;i++){ for(int j=1;j&lt;=i;j++){ dp[i]+=dp[j-1]*dp[i-j]; } } return dp[n]; } }","link":"/post/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"},{"title":"968.监控二叉树","text":"968.监控二叉树1.问题描述： 监控二叉树 给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。 example 1: 输入：[0,0,null,0,0] 输出：1 解释：如图所示，一台摄像头足以监控所有节点。 example 2: 输入：[0,0,null,0,null,0,null,null,0] 输出：2 解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。 提示： 给定树的节点数的范围是 [1, 1000]。 每个节点的值都是 0。 题目来源： https://leetcode.cn/problems/binary-tree-cameras/ 2.题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int res=0; public int minCameraCover(TreeNode root) { //根节点不一定被覆盖，需要检查一下 if(minCamera(root)==0){ res++; } return res; } /** 若未覆盖，return 0 若有相机，return 1 若已覆盖，return 2 */ public int minCamera(TreeNode root){ if(root==null){ return 2; } int left=minCamera(root.left); int right=minCamera(root.right); if(left==2&amp;&amp;right==2){ return 0; }else if(left==0||right==0){ res++; return 1; }else{ return 2; } } }","link":"/post/968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{"title":"977.有序数组的平方","text":"977.有序数组的平方题目描述： 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 example 1: 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] example 2: 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非递减顺序 排序 题目来源：https://leetcode.cn/problems/squares-of-a-sorted-array 题解：//先计算平方，然后排序，时间复杂度O(nlogn) class Solution { public int[] sortedSquares(int[] nums) { for(int i=0;i&lt;nums.length;i++){ nums[i]*=nums[i]; } Arrays.sort(nums); return nums; } } //使用双指针，一个i从头开始，一个j从尾巴开始，分别计算平方，比较大小，放入一个新的数组，新数组的指针为k，从尾部开始 class Solution { public int[] sortedSquares(int[] nums) { int[] ret=new int[nums.length]; for(int i=0,j=nums.length-1,k=ret.length-1;i&lt;=j;){ if(nums[i]*nums[i]&gt;=nums[j]*nums[j]){ ret[k--]=nums[i]*nums[i]; i++; }else{ ret[k--]=nums[j]*nums[j]; j--; } } return ret; } }","link":"/post/977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html"},{"title":"98.验证二叉搜索树","text":"98.验证二叉搜索树问题描述： 验证二叉搜索树 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 example 1： 输入：root = [2,1,3] 输出：true example 2: 输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内 -231 &lt;= Node.val &lt;= 231 - 1 题目来源：https://leetcode.cn/problems/validate-binary-search-tree/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { //进行中序遍历，并将遍历的节点值存入到list集合中 public void valid(TreeNode node,List&lt;Integer&gt; list){ if(node==null) return ; valid(node.left,list); list.add(node.val); valid(node.right,list); } public boolean isValidBST(TreeNode root) { List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); valid(root,list); //将集合转化为数组 Integer[] arr=list.toArray(new Integer[list.size()]); //判断数组是否为升序，如果不是升序，则不是二叉搜索树，否则是二叉搜索树 for(int i=1;i&lt;arr.length;i++){ if(arr[i]&lt;=arr[i-1]) return false; } return true; } }","link":"/post/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"},{"title":"分发饼干","text":"分发饼干题目描述：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 example1: 输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 example2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 提示： 1 &lt;= g.length &lt;= 3 * 104 0 &lt;= s.length &lt;= 3 * 104 1 &lt;= g[i], s[j] &lt;= 231 - 1 题目来源：https://leetcode.cn/problems/assign-cookies 题解：//方法1：饼干和胃口都从大到小进行匹配，当饼干不足以满足胃口时，就寻找下一个更小的胃口，即移动胃口数组指针 class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(s); Arrays.sort(g); int index_children=g.length-1; int index_supply=s.length-1; int count=0; while(index_children&gt;=0&amp;&amp;index_supply&gt;=0){ if(s[index_supply]&gt;=g[index_children]){ index_supply--; count++; } index_children--; } return count; } } //方法二、饼干和胃口都从小到大进行匹配，当饼干不足以满足胃口时，移动饼干，即找下一个更大的饼干。 class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(s); Arrays.sort(g); int index_supply=0; int index_children=0; int count=0; while(index_children&lt;g.length&amp;&amp;index_supply&lt;s.length){ if(s[index_supply]&gt;=g[index_children]){ //当前的child被满足，++ index_children++; //满足人数++ count++; } // 开始便利下一个饼干 index_supply++; } return count; } }","link":"/post/Assign-Cookies.html"},{"title":"Bucket Sort","text":"桶排序介绍：/* 桶排序是一个排序算法，工作原理是将数组分到有限数量的桶中。 每个桶内再进行个别排序（可以使用其他不同的排序算法实现）。 */ 基本步骤： 设定一个基准，将待排序的数据按照一定的范围，从小到大平均分搭配N个桶中，此时，桶与桶之间已经排好序了，但是桶内是无序的。 将桶内的元素进行排序 将每个桶按照从小到大的编号，一次取出桶内元素，排序完成。","link":"/post/BucketSort.html"},{"title":"Console失效","text":"console.log()失效问题描述：当使用console.log()想要打印到控制台时，发现idea出现下滑红线，并且num run serve也通不过。 错误信息：ESLint: Unexpected console statement.(no-console) 解决办法：进行简单的配置即可： 在package.json的eslintConfig:{}中的”rules”:{}，增加一行代码【”no-console”: “off”】 &quot;rules&quot;: { &quot;no-console&quot;:&quot;off&quot; },","link":"/post/CannotUseConsole.html"},{"title":"找到第k大的元素——快速排序","text":"Kth Largest Element in an Array——快速排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. You must solve it in O(n) time complexity. 题解：class Solution { public int findKthLargest(int[] nums, int k) { return fastSelection(nums,0,nums.length-1,k-1); //注意，传入的参数是nums.length-1和k-1 } //快速排序，递归 public int fastSelection(int[] nums,int start,int end,int kth){ //划分并确定一个元素的位置 int cur=partition(nums,start,end); //若为第k个元素，则直接返回 if(cur==kth){ return nums[cur]; }else if(cur&lt;kth){ //否则对右边区域进行划分 return fastSelection(nums,cur+1,end,kth); }else{ //对左边区域进行划分 return fastSelection(nums,start,cur-1,kth); } } //划分区间 public int partition(int[] nums,int start,int end){ //随机选择枢轴元素 int pivot=start+(int)(Math.random()*(end-start+1)); //将枢轴元素调换至右边界 swap(nums,pivot,end); //双指针index和i用于进行划分，确定枢轴元素的最终位置 int index=start-1; for(int i=start;i&lt;end;i++){ if(nums[i]&gt;nums[end]){ swap(nums,i,++index); } } swap(nums,++index,end); return index; } public void swap(int[] nums,int left,int right){ int temp=nums[left]; nums[left]=nums[right]; nums[right]=temp; } }","link":"/post/FindKthLargest.html"},{"title":"Kth Largest Element in an Array——堆排序","text":"Kth Largest Element in an Array——堆排序题目描述：Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. You must solve it in O(n) time complexity. 题解：class Solution { public int findKthLargest(int[] nums, int k) { //堆的大小 int heapSize=nums.length; //初始建立大根堆 buildMaxHeap(nums,heapSize); //取出堆顶元素，置换到堆底，再对置换完成的堆进行调整 for(int i=nums.length-1;i&gt;=nums.length-k+1;i--){ swap(nums,0,i); adjustHeap(nums,0,--heapSize); } //返回第k次调整的堆顶元素 return nums[0]; } //初始建堆 public void buildMaxHeap(int[] nums,int heapSize){ //找到第一个非叶节点，不断下坠 for(int i=heapSize/2;i&gt;=0;i--){ adjustHeap(nums,i,heapSize); } } //堆调整 public void adjustHeap(int[] nums,int i,int heapSize){ //创建指针分别指向i节点的左右孩子节点 int left=i*2+1; int right=i*2+2; int largest=i; //通过两次判断，将largest指针指向最大节点 if(left&lt;heapSize&amp;&amp;nums[left]&gt;nums[largest]){ largest=left; } if(right&lt;heapSize&amp;&amp;nums[right]&gt;nums[largest]){ largest=right; } //若不符合大根堆要求，则进行调整 if(largest!=i){ swap(nums,largest,i); adjustHeap(nums,largest,heapSize); } } public void swap(int[] nums,int left,int right){ int temp=nums[left]; nums[left]=nums[right]; nums[right]=temp; } }","link":"/post/FindKthLargest01.html"},{"title":"Hexo添加标签和分类","text":"如何在Hexo中添加分类和标签？分类： 创建分类选项： 生成【分类页】，并添加type属性 hexo new page categories 执行成功： INFO Created: H:\\blog\\source\\categories\\index.md 根据上述路径，找到index.md,添加type和layout： title: categories date: 2022-07-19 16:16:46 type: &quot;categories&quot; layout: &quot;categories&quot; 保存并关闭index.md 使用categories： title: Console失效 date: 2022-07-19 16:02:42 categories: - web前端 tags: - Vue - 报错 标签： 创建标签选项： 生成【标签页】，并添加type属性 hexo new page tags 执行成功： INFO Created: H:\\blog\\source\\tags\\index.md 根据上述路径，找到index.md,添加type和layout： title: 文章分类 date: 2022-01-07 22:53:43 type: &quot;tags&quot; layout: &quot;tags&quot; 保存并关闭index.md 使用tags： title: Console失效 date: 2022-07-19 16:02:42 categories: - web前端 tags: - Vue - 报错","link":"/post/HexoTagsAndCategories.html"},{"title":"Java并发编程实战-第二章","text":"Java并发编程实战——第二章【线程安全性】 判断一个对象是否是线程安全的，取决于它是否被多个线程访问 要使得对象是线程安全的，需要采用同步机制来协同对对象的可变状态的访问。 当多个线程访问同一个可变的状态变量时，若没有使用合适的同步，程序可能出现错误，可使用以下三种方式修复这个问题： 不在线程之间共享该状态变量 将状态变量修改为不可变的变量 在访问状态变量时使用同步 线程安全的程序是否完全由线程安全类构成？ 答案是否定的，完全由线程安全类构成的程序并不一定是线程安全的，并且在线程安全的类中也同样可以包含非线程安全的类。 1.什么是线程安全性？ 定义： 当有多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要额外的同步或协同，这个类始终都能表现出正确的行为，那么称这个类是线程安全的。 线程安全类中封装了必要的同步机制，因此客户端无须进一步采用同步机制 example 1： 一个无状态的servlet @ThreadSafe public class StatelessFactorizer implements Servlet{ public void service(ServletRequest req,ServletResponse resp){ BigInteger i=extractFromRequest(req); BigInteger[] factors=factor(i); encodeIntoResponse(resp,factors); } } 上面代码块中的StatelessFactorizer是无状态的，既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。访问StatelessFactorizer的线程不会影响另一个访问同一个StatelessFactorizer的线程的计算结果，因为这两个线程并没有共享状态。就像他们在访问不同的实例。 无状态的对象一定是线程安全的 ## 2.原子性 ### example 2： + 在没有同步的情况下统计已处理请求数量的Servlet ```java @NotThreadSafe public class UnsafeCountingFactorizer implements Servlet{ private long count=0; public long getCount(){return count;} public void service(ServletRequest req,ServletResponse resp){ BigInteger i=extractFromRequest(req); BigInteger[] factors=factor(i); ++count; encodeIntoResponse(resp,factors); } } 上面代码块中的代码是线程不安全的，在单线程环境中可以正确运行，但在多线程环境中可能会丢失更新，该错误是由于不恰当的执行时序而出现的不正确结果【也叫做：竞态条件（Race Condition）】。 当某个计算结果的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。【结果正确与否取决运气】 竞态条件的本质==&gt;【观察到的结果失效】 example 3： 延迟初始化中的竞态条件 @NotThreadSafe public class LazyInitRace{ private ExpensiveObject instance=null; public ExpensiveObject getInstance(){ if(instance==null){ instance=new ExpensiveObject(); } return instance; } } 和大多数的并发错误一样，竞态条件并不总是会产生错误，还需要某种不恰当的执行时序。 example 4：","link":"/post/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%BA%8C%E7%AB%A0.html"},{"title":"Java并发编程实战_第一章","text":"Java并发编程实战——第一章【简介】1.并发简史 早期的计算机仅仅包含一个操作系统，从头到尾仅执行一个程序，并且该程序可访问计算机中所有资源 操作系统的出现使得计算机每次可以运行多个程序 不同的程序在不同的进程中运行 操作系统为每个独立运行的进程分配各种资源：内存、文件句柄、安全证书等 不同进程间可进行通信，通信机制包括：套接字、信号处理器、共享内存、信号量以及文件等 为什么在计算机中加入操作系统以实现多个程序的同时执行？ 资源利用率：单个程序等待外部操作时，无法进行其他操作，造成计算资源的浪费 公平性：不同的用户和程序对计算机资源具有相同的使用权 便利性：编写多个程序，并且在必要时进行程序间通信相比于编写单个程序而言更易于实现 这些促使进程出现的因素，同样促使线程的出现： 线程允许同一个进程中存在多个程序控制流。 线程共享进程范围内的资源，例如内存句柄和文件句柄 每个线程都有自己的程序计数器、栈、变量等 在同一个程序中的多个线程可以被调度到多个CPU上运行 2.线程的优势 发挥多处理器的强大能力 在双处理器系统上，单线程的程序只能使用一半的CPU资源，在100个处理器的系统上，将有99%的资源无法使用，而多线程可以同时在多个处理器上执行，若设计正确，多线程程序可以通过提高处理器资源的利用率来提升系统吞吐率 使用多线程同样可以有助于在单处理器上获得更高的吞吐率 建模的简单性 若程序中只包含一种类型的任务，那么比包含多个不同类型的任务的程序要更加易于编写，错误更少，也更加易于测试 通过线程，可以将复杂且异步的工作流进一步分解为一组简单且同步的工作流，每个工作流在一个线程中运行，并且在特定同步位置进行交互。 异步事件的简化处理 服务器应用程序在接收来自多个远程客户端的套接字连接请求时，为每一个请求连接都分配其各自的一个线程并且使用同步IO将会降低该类程序的开发难度 若使用单线程，则每一次只可以处理一个请求，其他的请求必须阻塞，这大大降低了请求的处理速度，为了解决这个问题，可以使用非阻塞IO来实现请求阻塞的问题，但是非阻塞IO的复杂度远远高于同步IO 非阻塞IO不太了解 3.线程带来的风险 安全性问题：【永远不发生糟糕的事情】 线程安全性可能是非常复杂的，在没有充分同步的情况下，多个线程中的操作顺序是不可预测的，甚至会产生奇怪的结果 当多个线程要共享相同的内存地址空间，并且是并发运行时，可能会存在一个线程访问或修改其他线程正在使用的变量，这是一个极大的便利，同时也带来了巨大风险：线程会因为无法预料的数据变化而发生错误。 当多个线程同时访问和修改相同变量时，将会在串行编程模型中引入非串行因素，并且这种非串行性是很难分析的。 要使得多线程程序的行为是可以预测的，必须对共享便利的访问操作进行协同，防止线程之间相互干扰。 Java也提供了各种同步机制来协同这种访问 活跃性问题：【活跃性：某件事情终将会发生】 形式之一：无意中造成的无限循环，从而使得循环体之后的代码得不到执行 性能问题： 在多线程程序种，频繁的进行线程切换不仅会造成资源开销，同时会压缩线程执行的时间，因此，应该尽量分析和减少此类开销 4.线程无处不在 即使程序中没有显式的创建线程，但在框架种仍然可能会创建线程，因此在这些线程中调用的代码必须是线程安全的","link":"/post/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%B8%80%E7%AB%A0.html"},{"title":"列表导出为数组","text":"Java中List集合的toArray方法1. toArray() 当没有参数指定时，返回的数组中元素的类型是Object类型的。因为List在使用时一般会指定泛型，所以该方法是不常用的。 2.toArray(T[] a) leetcode-406使用到了该方法将列表对象转化为二维数组 可以导出数组为指定的类型 List&lt;String&gt; list=new List&lt;&gt;(); list.add(&quot;hello&quot;); list.add(&quot;world&quot;); String[] strs=list.toArray(new String[list.size()]); List&lt;int[]&gt; list=new List&lt;&gt;(); list.add(new int[]{0,1}); list.add(new int[]{1,0}); int[][] ret=list.toArray(new int[list.size()][]);","link":"/post/ListtoArray.html"},{"title":"452.Minimum Number of Arrows to Burst Balloons","text":"452.Minimum Number of Arrows to Burst Balloons题目描述：There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons. Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path. Given the array points, return the minimum number of arrows that must be shot to burst all balloons. 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。 example 1: 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：气球可以用2支箭来爆破: -在x = 6处射出箭，击破气球[2,8]和[1,6]。 -在x = 11处发射箭，击破气球[10,16]和[7,12]。 example 2: 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 解释：每个气球需要射出一支箭，总共需要4支箭。 example 3: 输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 解释：气球可以用2支箭来爆破: - 在x = 2处发射箭，击破气球[1,2]和[2,3]。 - 在x = 4处射出箭，击破气球[3,4]和[4,5]。 题目链接：https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/ 题解：/*排序+贪心*/ class Solution { public int findMinArrowShots(int[][] points) { //检查数组是否合法 if(points.length==0){ return 0; } //依据右边界的大小进行升序排序 Arrays.sort(points,new Comparator&lt;&gt;(){ public int compare(int[] m,int[] n){ //m小n大则不用交换位置，因为我们要的就是升序排序 if(m[1]&lt;n[1]){ return -1; //m大n小，则需要交换位置，保证升序 }else if(m[1]&gt;n[1]){ return 1; //若m=n则不需要交换位置，【当返回值小于等于0时，不进行元素交换，仅当返回值大于0时才需要进行交换！】 }else{ return 0; } } }); //获取第一个元素的右边界作为初始右边界 long right=points[0][1]; //用于箭矢计数，初始值为1 int num=1; //对元素进行遍历，如果需要遇到了不重叠的气球（即左边界大于right），则需要增加箭矢的数量，并更新右边界的值 for(int[] b:points){ if(b[0]&gt;right){ num++; right=b[1]; } } //返回箭矢的数量 return num; } }","link":"/post/MinimumNumberofArrowstoBurstBalloons.html"},{"title":"Non—overlapping Intervals","text":"435. Non-overlapping Intervals题目描述：Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. example 1: Input: intervals = [[1,2],[2,3],[3,4],[1,3]] Output: 1 Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping. example 2: Input: intervals = [[1,2],[1,2],[1,2]] Output: 2 Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping. 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 example 3: Input: intervals = [[1,2],[2,3]] Output: 0 Explanation: You don't need to remove any of the intervals since they're already non-overlapping. 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/non-overlapping-intervals 题解：/* 贪心法： 1.首先对数组参数interval中的各个区间元素进行排序，下面是按照右边界升序排序的。 2.选出排序后的第一个区间的右边界作为初始右边界，并初始化未重叠区间的数量。 3.依次遍历数组中其他的区间元素，若遍历到的区间元素的左边界并未超过初始右边界，则表示两个区间不重叠， 则：可以将该区间加入到非重叠区间集合中，更新未重叠区间数量，更新初始右边界。 4.最后遍历完成即可得到未重叠区间数量，最后获得需要删减的区间的数量作为返回值返回即可。 */ class Solution { public int eraseOverlapIntervals(int[][] intervals) { //检查参数是否合法,长度为0，则无需移除任何元素 if(intervals.length==0){ return 0; } //对间隔数组进行排序，对右边界进行排序，进行升序排序，排序完成后，最靠左的元素的右边界最小 Arrays.sort(intervals,new Comparator&lt;int[]&gt;(){ public int compare(int[] m,int[] n){ return m[1]-n[1]; } }); //获取间隔数组的长度 int length=intervals.length; //获取初始右边界，即具有最小右边界的元素 int right_bound=intervals[0][1]; //non_overlapping_num记录的是不重叠的间隔的数量,因为至少存在一个元素，所以初始化ans为1. int non_overlapping_num=1; //若找到不重叠的下一个间隔【因为这里的数组已经按照右边界进行排序了，替换的右边界是逐渐增加的】 for(int i=1;i&lt;length;i++){ //若当前间隔元素不重叠 if(intervals[i][0]&gt;=right_bound){ non_overlapping_num++; right_bound=intervals[i][1]; } } //数组长度减去ans（当前不重叠元素个数），得到的就是需要移除的元素的个数 return length-non_overlapping_num; } }","link":"/post/NonoverlappingIntervals.html"},{"title":"PriorityQueue的简单使用","text":"Java中的优先队列Java中的PriorityQueue默认是小顶堆，逻辑上是堆，物理上是数组，每次取出的元素是最小的。【可以通过比较器的方式传入不同的比较规则】 特点： 实现了Queue接口 不允许放入null元素 插入方法： add()和offer(),前者插入失败抛出异常，后者插入失败返回false。 获取堆顶元素： element()和peek():都是获取堆顶元素，前者获取失败抛出异常，后者返回null 获取并删除队首元素： remove()和poll()都是获取并删除队首元素，前者失败抛出异常，后者失败返回null。 构造： 构造小顶堆 PriorityQueue small=new PriorityQueue&lt;&gt;(); 构造大顶堆 PriorityQueue big=new PriorityQueue&lt;&gt;(Collections.reverseOrder()); //使用比较器构造大顶堆 PriorityQueue&lt;int[]&gt; queue=new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() { public int compare(int[] m, int[] n) { return m[1] - n[1]; } });","link":"/post/PriorityQueue_SimpleUse.html"},{"title":"Pycharm模块不存在","text":"Pycharm模块不存在问题描述：当运行Python文件时，出现以下报错： python中已经用pip安装了某模块，但pycharm中为什么仍然显示没有该模块 出现原因：pycharm里面自带一个Python解释器，而这个里面是没有几个模块的。因为咱们在DOS命令行里面下载的模块是下载到Python的解释器里而不是pycharm里面的那个。 解决方案：打开pycharm依次点击file-&gt;Settings-&gt;Project Interpreter； 可以看到当前项目正在使用的Python解释器，即Project Interpreter那一栏。 可以将其替换为本机上安装的Python解释器，即cmd中可以查看到的python解释器： 1.查找本机Python的安装地址： C:\\Users\\26485&gt;where python C:\\Users\\26485\\AppData\\Local\\Programs\\Python\\Python39\\python.exe C:\\Users\\26485\\AppData\\Local\\Microsoft\\WindowsApps\\python.exe 2.在Project Interpreter添加对应地址中新的解释器，添加完成后，可以看到我们在本机环境下已经安装的模块和工具包。","link":"/post/Pycharm%E6%A8%A1%E5%9D%97%E4%B8%8D%E5%AD%98%E5%9C%A8.html"},{"title":"Python语法错误01","text":"Python语法错误01#出现语法错误一般是python版本问题，解决方案一般是两种 &quot;&quot;&quot; 1.修改python版本 2.修改代码语法 &quot;&quot;&quot; 1.except Exception, e: 语法无效except Exception e:#python2支持，3版本不支持 #修改为3版本语法 except Exception as e: 2.TypeError: a bytes-link object is requeired, not ‘str’ 需要的是byte类型的对象，而非str类型 #解决方案：将字符串类型转为字节类型 &quot;&quot;&quot; 假设s为一个str类型的变量 =&gt;type(s) &lt;class 'str'&gt; 存在以下三种常见的类型转换公式 1.b1=bytes(s.encoding='utf-8') 2.b2=str.encoding(s) 3.b3=s.encode(encoding='utf=8') &quot;&quot;&quot;","link":"/post/Python%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF01.html"},{"title":"Sort Characters By Frequency_桶排序","text":"Sort Characters By Frequency——桶排序题目描述：Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them. example 1: Input: s = &quot;tree&quot; Output: &quot;eert&quot; Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore &quot;eetr&quot; is also a valid answer. example 2: Input: s = &quot;cccaaa&quot; Output: &quot;aaaccc&quot; Explanation: Both 'c' and 'a' appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers. Note that &quot;cacaca&quot; is incorrect, as the same characters must be together. 题解：class Solution { public String frequencySort(String s) { //创建map存储字符及其出现次数 Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); int max_frequency=0; int frequency=0; char ch=' '; for(int i=0;i&lt;s.length();i++){ ch=s.charAt(i); map.put(ch,map.getOrDefault(ch,0)+1); max_frequency=Math.max(max_frequency,map.get(ch)); } //创建buckets，并初始化buckets StringBuffer[] buckets=new StringBuffer[max_frequency+1]; for(int i=0;i&lt;max_frequency+1;i++){ buckets[i]=new StringBuffer(); } for(Map.Entry&lt;Character,Integer&gt; entry:map.entrySet()){ ch=entry.getKey(); frequency=entry.getValue(); buckets[frequency].append(ch); } //创建返回值 StringBuffer ret=new StringBuffer(); //添加返回值 for(int i=max_frequency;i&gt;=1;i--){ StringBuffer bucket=buckets[i]; for(int j=0;j&lt;bucket.length();j++){ for(int k=0;k&lt;i;k++){ ret.append(bucket.charAt(j)); } } } return ret.toString(); } }","link":"/post/SortCharactersByFrequency-BucketSort.html"},{"title":"Sort Characters By Frequency","text":"Sort Characters By Frequency题目描述：Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them. example 1: Input: s = &quot;tree&quot; Output: &quot;eert&quot; Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore &quot;eetr&quot; is also a valid answer. example 2: Input: s = &quot;cccaaa&quot; Output: &quot;aaaccc&quot; Explanation: Both 'c' and 'a' appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers. Note that &quot;cacaca&quot; is incorrect, as the same characters must be together. 题解：class Solution { public String frequencySort(String s) { //创建map存储字符及其出现次数 Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); char ch=' '; for(int i=0;i&lt;s.length();i++){ ch=s.charAt(i); map.put(ch,map.getOrDefault(ch,0)+1); } //创建list列表存储字符 List&lt;Character&gt; list=new ArrayList&lt;&gt;(map.keySet()); //对list进行降序排序，根据出现次数 Collections.sort(list,(m,n)-&gt;map.get(n)-map.get(m)); //创建返回值 StringBuffer ret=new StringBuffer(); //将结果存储返回值 for(int k=0;k&lt;list.size();k++){ ch=list.get(k); int frequency=map.get(ch); for(int j=0;j&lt;frequency;j++){ ret.append(ch); } } return ret.toString(); } }","link":"/post/SortCharactersByFrequency.html"},{"title":"Top K Frequent Elements","text":"Top K Frequent Elements题目描述：Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] example 2: Input: nums = [1], k = 1 Output: [1] 题解：class Solution { public int[] topKFrequent(int[] nums, int k) { //创建map，记录元素及其出现次数 Map&lt;Integer,Integer&gt; map=new HashMap&lt;Integer,Integer&gt;(); for(int num:nums){ map.put(num,map.getOrDefault(num,0)+1); } //创建结构为小根堆的优先队列，队列元素为一个大小为2的数组，[0]表示元素，[1]表示出现次数 //这里创建优先队列时，由于队列中的元素类型并非整型，所以需要传入比较器，规定比较规则 PriorityQueue&lt;int[]&gt; queue=new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;(){ public int compare(int[] m,int[] n){ return m[1]-n[1]; } }); //将map中的键值对存入优先队列 for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()){ int key=entry.getKey(); int value=entry.getValue(); //若队列已满，则需要判断是否需要替换 if(k==queue.size()){ //若当前元素出现次数小于堆顶元素，则表示堆内元素出现次数均大于key，则无需替换，否则需要替换堆顶元素 if(value&gt;queue.peek()[1]){ queue.poll(); queue.offer(new int[]{key,value}); } }else{ //若队列元素个数小于k，则直接加入队列中 queue.offer(new int[]{key,value}); } } //将队列中维护的元素存入ret数组并返回 int[] ret=new int[k]; for(int i=0;i&lt;k;i++){ ret[i]=queue.poll()[0]; } return ret; } }","link":"/post/TopKFrequentElements.html"},{"title":"我的第一篇博客","text":"第一篇博客哈哈，我有自己的博客啦！","link":"/post/demo01.html"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","link":"/post/hello-world.html"},{"title":"Vue中localStorage的简单使用","text":"Vue中localStorage的简单使用localStorage主要作为本地存储来使用。下面记录三个主要用法： 存储数据 localStorage.setItem('key','value') 取出数据 localStorage.getItem('key') 删除本地存储数据 localStorage.removeItem('key') 当存储的是json格式时，需要使用JSON.stringify()转化为字符串","link":"/post/localStorage.html"},{"title":"Ryu的Rest API初体验","text":"ryu.app.ofctl_restryu.app.ofctl_rest provides REST APIs for retrieving the switch stats and Updating the switch stats. This application helps you debug your application and get various statistics. 【其实就是ryu自己提供的一个应用程序，提供了获取交换机状态以及更新交换机状态的REST APIs。该应用可以帮助我们debug自己创建的应用并获取各种统计数据】 This application supports OpenFlow version 1.0, 1.2, 1.3, 1.4 and 1.5. 【支持OpenFlow版本 1.0 1.2 1.3 1.4和1.5】 使用 将ofctl_rest和simple_switch_13.py一起启动 启动拓扑 另起一个终端，进行请求发送，测试接口 其余接口尚未测试，该接口响应成功，响应结果是否正确要看具体实验情况。 【注】使用的是python3，则需要修改ofctl_rest源码： 第133行： #原本 body=json.dumps(dps) #改为 body = json.dumps(list(dps)).encode(&quot;utf-8&quot;) 若是python2，则应该不需要修改，运行时不会报错","link":"/post/ofctlrest.html"},{"title":"平台开发所使用的前端组件工具","text":"平台开发中所使用到的Vue工具和组件vue-prism-editor1. 实现效果 可输入代码，并且代码语法高亮 支持编辑模式与不可编辑模式 2. 使用步骤 安装依赖 npm install vue-prism-editor 由于vue-prism-editor需要prismjs依赖，所以需要导入prismjs依赖 npm install prismjs 在需要使用的页面导入组件 import { PrismEditor } from &quot;vue-prism-editor&quot;; import &quot;vue-prism-editor/dist/prismeditor.min.css&quot;; import { highlight, languages } from &quot;prismjs/components/prism-core&quot;; import &quot;prismjs/components/prism-clike&quot;; import &quot;prismjs/components/prism-javascript&quot;; import &quot;prismjs/themes/prism-tomorrow.css&quot;; html &lt;prism-editor class=&quot;my-editor height-300&quot; v-model=&quot;code&quot; aria-disabled :highlight=&quot;highlighter&quot; line-numbers :readonly=&quot;false&quot; :tabSize=&quot;4&quot; &gt;&lt;/prism-editor&gt; javascript export default { components: { PrismEditor }, data: () =&gt; ({ code: ' ', }), methods: { highlighter(code) { return highlight(code, languages.js); //returns html } } }; CSS &lt;style lang=&quot;scss&quot;&gt; .my-editor { background: #2d2d2d; color: #ccc; font-family: Fira code, Fira Mono, Consolas, Menlo, Courier, monospace; font-size: 14px; line-height: 1.5; padding: 5px; } .prism-editor__textarea:focus { outline: none; } /* 非必须 */ .height-300 { height: 300px; } &lt;/style&gt; 参考资料：https://blog.csdn.net/c_qianxia5040/article/details/124008768 file-saver1. 实现效果 可以将一段字符串保存为一个文件 2. 使用步骤 安装依赖 npm install file-saver --save 在需要使用文件保存的页面导入依赖 import { saveAs } from 'file-saver'; 保存文件demo downloadTxt() { let str_file = '文件内的字符串内容' let strData = new Blob([str_file], { type: 'text/plain;charset=utf-8' }); saveAs(strData, &quot;文件.py&quot;); }, 参考资料：https://wjw1014.blog.csdn.net/article/details/124320511","link":"/post/toolsInVue.html"},{"title":"x的平方根","text":"69. x的平方根题目描述：给你一个非负整数 x ，计算并返回 x 的 算术平方根 。 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。 example 1: 输入：x = 4 输出：2 example 2: 输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 题目来源：https://leetcode.cn/problems/sqrtx 题解：//左开右闭区间 class Solution { public int mySqrt(int x) { if(x==1){ return 1; } int left=0; int right=x; int result=0; while(left&lt;right){ int mid=(right-left)/2+left; if((long)mid*mid&lt;=x){ result=mid; left=mid+1; }else{ right=mid; } } return result; } } int mid = (left + right) / 2; 与 int mid = left + (right - left) / 2; 二者的区别 二者结果一样，但是left + right 可能会溢出 //左闭右闭区间 class Solution { public int mySqrt(int x) { //闭区间 int left=0; int right=x; //暂存符合条件的元素 int result=0; while(left&lt;=right){ int mid=left+(right-left)/2; if((long)mid*mid&lt;=x){ result=mid; left=mid+1; }else{ right=mid-1; } } return result; } }","link":"/post/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.html"},{"title":"不同的二叉搜索树Ⅱ","text":"95.不同的二叉搜索树Ⅱ题目描述： 不同的二叉搜索树 II 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。 example 1: 输入：n = 3 输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] example 2: 输入：n = 1 输出：[[1]] 提示： 1&lt;=n&lt;=8 题目来源：https://leetcode.cn/problems/unique-binary-search-trees-ii/ 题解：/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;TreeNode&gt; generateTrees(int n) { //若n=0则直接返回一个空的列表 if(n==0){ return new ArrayList&lt;TreeNode&gt;(); } //递归生成二叉搜索树 return generateNodes(1,n); } public List&lt;TreeNode&gt; generateNodes(int left,int right){ //返回值，存放不同的头节点，（头节点包含子对象left和right，我们只管传入不同的二叉搜索树的头节点即可） List&lt;TreeNode&gt; list=new ArrayList&lt;TreeNode&gt;(); //当left&gt;right表示左边或者右边没有节点了，返回null if(left&gt;right){ list.add(null); return list; } //循环所有的节点，将每个遍历的节点作为根节点 for(int i=left;i&lt;=right;i++){ //获取左子树和右子树的所有可能的组合 List&lt;TreeNode&gt; left_sub_tree=generateNodes(left,i-1); List&lt;TreeNode&gt; right_sub_tree=generateNodes(i+1,right); //对根节点进行拼接。组成不同的二叉搜索树 for(TreeNode a:left_sub_tree){ for(TreeNode b:right_sub_tree){ //注意根节点在此处创建，因为左右子树不同代表不同的二叉搜索树 TreeNode root=new TreeNode(i); root.left=a; root.right=b; //将该二叉搜索树存入list list.add(root); } } } return list; } }","link":"/post/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E2%85%A1.html"},{"title":"为运算表达式设计优先级","text":"241.为运算表达式设计优先级题目描述： 为运算表达式设计优先级 给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。 生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104 。 example1: 输入：expression = &quot;2-1-1&quot; 输出：[0,2] 解释： ((2-1)-1) = 0 (2-(1-1)) = 2 example2: 输入：expression = &quot;2*3-4*5&quot; 输出：[-34,-14,-10,-10,10] 解释： (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 提示： 提示： 1 &lt;= expression.length &lt;= 20expression 由数字和算符 ‘+’、’-‘ 和 ‘*’ 组成。输入表达式中的所有整数值在范围 [0, 99] 题目来源：https://leetcode.cn/problems/different-ways-to-add-parentheses 题解：class Solution { char[] cs; public List&lt;Integer&gt; diffWaysToCompute(String s) { //转化为字符数组 char[] chars=s.toCharArray(); //调用递归函数，初始边界是0~s.length()-1 return dfs(chars,0,chars.length-1); } public List&lt;Integer&gt; dfs(char[] chars,int left,int right){ //创建返回值列表 List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); //循环遍历每一个字符 for(int i=left;i&lt;=right;i++){ //若为数字字符，则跳过 if(chars[i]&lt;='9'&amp;&amp;chars[i]&gt;='0') continue; //若为运算符字符，则递归左边的所有运算结果和右边的所有运算结果 List&lt;Integer&gt; left_ret=dfs(chars,left,i-1); List&lt;Integer&gt; right_ret=dfs(chars,i+1,right); //遍历左边所有的运算结果和右边所有的运算结果，根据当前遇到的运算符进行相应的运算 for(int a:left_ret){ for(int b:right_ret){ if(chars[i]=='+'){ list.add(a+b); }else if(chars[i]=='-'){ list.add(a-b); }else if(chars[i]=='*'){ list.add(a*b); } } } } //若list为空，则表示全部为数字字符，则将数字字符加入到list中 if(list.isEmpty()){ int ret=0; for(int i=left;i&lt;=right;i++){ ret=ret*10+(chars[i]-'0'); } list.add(ret); } return list; } }","link":"/post/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7.html"},{"title":"买股票的最佳时机","text":"121. 买股票的最佳时机题目描述：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 example 1: 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 example 2: 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 题目来源：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/ 题解：/* 贪心：最大收益一定是在历史最低点买入 */ public class Solution { public int maxProfit(int[] prices) { //最大收益，初始化为0 int maxprofit = 0; //最低买入点，初始化为最大值 int min_time=Integer.MAX_VALUE; //遍历每天价格 for(int price:prices){ //若出现了更低的买入点，则更新买入点 min_time=Math.min(min_time,price); //若当前价格高于最低买入点，则计算收益，并更新最大收集 maxprofit=Math.max(maxprofit,price-min_time); } return maxprofit; } }","link":"/post/%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html"},{"title":"划分字母区间","text":"763.划分字母区间题目描述：763. 划分字母区间字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。 example 1: 输入：S = &quot;ababcbacadefegdehijhklij&quot; 输出：[9,7,8] 解释： 划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。 每个字母最多出现在一个片段中。 像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。 题目来源：https://leetcode.cn/problems/partition-labels/ 题解：class Solution { public List&lt;Integer&gt; partitionLabels(String s) { /** 贪心算法： 由于每个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。 在得到每个字母的最后一次出现的下标位置之后，可以使用贪心算法将字符串划分为尽可能多的片段，具体做法如下： 1.从左到右遍历字符串，遍历的同时维护当前片段的开始下标start和结束下标end，初始化start=end=0； 2.对于每一个访问到的字母c，得到当前字母的最后一次出现的下标位置endc，则当前片段的结束下标一定不会小于endc，因此令end=max(end,endc); 3.当访问到下标end时，当前片段访问结束，当前片段的下标范围是[start,end]，长度为end-start+1，将当前片段的长度添加到返回值，然后令start=end+1，继续寻找下一个片段； 4.重复上述过程，知道遍历完字符串 */ 用于记录每个字母出现的最后位置 int[] chars=new int[26]; for(int i=0;i&lt;s.length();i++){ //将当前字母在s中出现的位置存入chars数组中对应字母的下标位置中 chars[s.charAt(i)-'a']=i; } List&lt;Integer&gt; partition=new ArrayList&lt;&gt;(); int start=0; int end=0; for(int i=0;i&lt;s.length();i++){ //得到对应字母c的最迟出现位置，若endc&gt;end则更新end的值，表示出现了比之前end对应字母还晚的字母，如果endc&lt;end则表示字母c的end所对应的字母的最晚出现位置已经在c的最晚出现位置之后了 end=Math.max(end,chars[s.charAt(i)-'a']); if(end==i){ //添加片段长度，更新start的值 partition.add(end-start+1); start=end+1; } } return partition; } }","link":"/post/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html"},{"title":"判断子序列","text":"392.判断子序列题目描述：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 example 1: 输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot; 输出：true example 2: 输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot; 输出：false 题目来源：https://leetcode.cn/problems/is-subsequence/ 题解：class Solution { public boolean isSubsequence(String s, String t) { //定义分别指向两个字符串序列的指针 int index_s=0; int index_t=0; //当匹配成功，子序列后移，匹配失败，主序列后移==贪心算法 while(index_s&lt;s.length()&amp;&amp;index_t&lt;t.length()){ if(s.charAt(index_s)==t.charAt(index_t)){ index_s++; } index_t++; } //当子序列达到末尾，表示子序列匹配成功，返回true if(index_s==s.length()){ return true; } //否则表示匹配失败，返回false return false; } }","link":"/post/%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html"},{"title":"剑指Offer58-II.左旋转字符串","text":"剑指Offer58-II.左旋转字符串题目描述：剑指 Offer 58 - II. 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 example 1: 输入: s = &quot;abcdefg&quot;, k = 2 输出: &quot;cdefgab&quot; example 2: 输入: s = &quot;lrloseumgh&quot;, k = 6 输出: &quot;umghlrlose&quot; 提示： 1 &lt;= k &lt; s.length &lt;= 10000 题目来源：剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode） 题解： class Solution { //先反转1-n的字符串，然后反转n+1到末尾的字符串 //最后对整个字符串进行反转，不需要额外的空间 public String reverseLeftWords(String s, int n) { int len=s.length(); StringBuilder sb=new StringBuilder(s); reverseString(sb,0,n-1); reverseString(sb,n,len-1); return sb.reverse().toString(); } public void reverseString(StringBuilder sb, int start, int end) { while (start &lt; end) { char temp = sb.charAt(start); sb.setCharAt(start, sb.charAt(end)); sb.setCharAt(end, temp); start++; end--; } } }","link":"/post/%E5%89%91%E6%8C%87Offer58-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{"title":"买卖股票的最佳时机2","text":"122. 买卖股票的最佳时机2题目描述：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 example 1: 输入：prices = [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 example 2: 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 题目来源：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/ 题解：class Solution { public int maxProfit(int[] prices) { //贪心，只要股票能涨，就卖，只要能赚到钱，就卖 int max_profit=0; //从第二天开始遍历，只要比前一天价格高，就卖掉 for(int i=1;i&lt;prices.length;i++){ if(prices[i]&gt;prices[i-1]){ max_profit+=prices[i]-prices[i-1]; } } return max_profit; } }","link":"/post/%E5%8D%96%E5%87%BA%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2.html"},{"title":"寻找峰值","text":"162. 寻找峰值题目描述：162. 寻找峰值峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞ 。 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。 example 1: 输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 example 2: 输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 题目来源：https://leetcode.cn/problems/find-peak-element/ 题解：class Solution { public int findPeakElement(int[] nums) { if(nums.length==1){ return 0; } int left=0; int right=nums.length-1; int ret=0; //这里使用的是左开右闭区间，不可使用左闭右闭区间，因为在进行查找时需要和右边的元素进行比较，所以必须保证，搜索区间包含至少两个元素，因此left&lt;=right时，是不满足条件的，当left==right进行判断时，会发生数组越界异常，因此该题只可以使用左闭右开区间。 while(right&gt;left){ int mid=(right-left)/2+left; if(nums[mid]&gt;nums[mid+1]){ right=mid; }else{ left=mid+1; } } return right; } }","link":"/post/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC.html"},{"title":"寻找旋转排序数组中的最小值","text":"153.寻找旋转排序数组中的最小值题目描述：153. 寻找旋转排序数组中的最小值已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 example 1： 输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 example 2： 输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 example 3: 输入：nums = [11,13,15,17] 输出：11 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 题目来源：https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/ 题解：class Solution { public int findMin(int[] nums) { int left=0; int right=nums.length-1; int ret=0; while(left&lt;right){ int mid=(right-left)/2+left; //在访问时需要访问mid以及右边的元素，所以至少访问两个元素，left&lt;right为循环结束的条件 if(nums[mid]&gt;nums[right]){ left=mid+1; }else{ right=mid; } } return nums[right]; } }","link":"/post/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC.html"},{"title":"寻找比目标字母大的最小字母","text":"744. 寻找比目标字母大的最小字母题目描述：给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。 在比较时，字母是依序循环出现的。举个例子： 如果目标字母 target = ‘z’ 并且字符列表为 letters = [‘a’, ‘b’]，则答案返回 ‘a’ example 1: 输入: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]，target = &quot;a&quot; 输出: &quot;c&quot; example 2: 输入: letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;c&quot; 输出: &quot;f&quot; example 3: 输入: letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;d&quot; 输出: &quot;f&quot; 题目来源：https://leetcode.cn/problems/find-smallest-letter-greater-than-target 题解：1.二分法：开区间 class Solution { public char nextGreatestLetter(char[] letters, char target) { //当target大于数组的最大值的时候，表示数组中所有元素均小于target，因为数组中字符是有序的。 if(target&gt;=letters[letters.length-1]){ return letters[0]; } //若上述if语句不符合则表示该数组必定存在大于target的元素。 int left=0; int right=letters.length-1; // 如果为左闭右闭那么while里面的判断语句是left&lt;=right ；若为左闭右开或者左开右闭，则while的判断语句是left &lt; right //左开右闭：left=mid;right=mid-1; //左闭右开：left=mid+1;right=mid; while(left&lt;right){ int mid=(right-left)/2+left; if(letters[mid]&gt;target){ //当mid指向的元素大于target时，则有可能是最小的大于target的元素 right=mid; }else{ //当mid元素小于或等于target时，mid指向的元素必然不是我们最终要找的元素，可以直接跳过mid指向的元素，mid+1 left=mid+1; } } return letters[left]; } } 2.线性搜索： class Solution { public char nextGreatestLetter(char[] letters, char target) { int min=Integer.MAX_VALUE; int min_index=0; for(int i=0;i&lt;letters.length;i++){ //i指向的元素在target后面，则比较当前维护的最短距离 if(letters[i]-target&gt;0){ min=Math.min(min,letters[i]-target); if(min==letters[i]-target){ min_index=i; } } } //若target大于letters数组中的所有元素，则直接返回0号元素 if(min==Integer.MAX_VALUE){ return letters[0]; } return letters[min_index]; } } 3.二分法：闭区间 class Solution { public char nextGreatestLetter(char[] letters, char target) { if(letters[letters.length-1]&lt;=target){ return letters[0]; } int right=letters.length; int left=0; int result=0; //闭区间写法，left&lt;=right；right=mid-1;left=mid+1;因为当mid指向的元素大于target时，该元素可能就是我们要找的目标元素，所以需要记录mid指向的元素result=mid;，对比开区间，right=mid；left&lt;right当left==right时结束循环，不会漏掉这个解，但是闭区间更清楚一些 while(left&lt;=right){ int mid=(right-left)/2+left; if(letters[mid]&gt;target){ result=mid; right=mid-1; }else{ left=mid+1; } } return letters[result]; } }","link":"/post/%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D.html"},{"title":"搜索旋转排序数组","text":"33. 搜索旋转排序数组题目描述：33. 搜索旋转排序数组整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 example 1: 输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 example 2: 输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 example 3: 输入：nums = [1], target = 0 输出：-1 题目来源：https://leetcode.cn/problems/search-in-rotated-sorted-array/ 题解：class Solution { public int search(int[] nums, int target) { //初始边界 int left=0; int right=nums.length-1; //区间 while(left&lt;=right){ int mid=(right-left)/2+left; if(nums[mid]==target) return mid; //mid位于左边的升序序列当中 if(nums[mid]&gt;=nums[left]){ //target位于左侧有序序列中 if(target&lt;nums[mid]&amp;&amp;target&gt;=nums[left]){ right=mid-1; }else{ left=mid+1; } }else{ //右侧为升序 //target位于右侧有序序列中 if(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right]){ left=mid+1; }else{ right=mid-1; } } } return -1; } }","link":"/post/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.html"},{"title":"509.斐波那契数列","text":"509.斐波那契数列 斐波那契数 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给定 n ，请计算 F(n) 。 题目描述：example 1: 输入：n = 2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 example 2: 输入：n = 3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 example 3: 输入：n = 4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 &lt;= n &lt;= 30 题目来源：https://leetcode.cn/problems/fibonacci-number/ 题解：class Solution { public int fib(int n) { if(n&lt;2) return n; //确定dp数组，dp[i] int[] dp=new int[n+1]; //确定递推公式，f(n)=f(n-1)+f(n-2) //dp数组的初始化，dp[0]=0,dp[1]=1 dp[0]=0; dp[1]=1; for(int i=2;i&lt;=n;i++){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; } }","link":"/post/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html"},{"title":"最大子数组和","text":"最大子数组和题目描述： 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 example 1: 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 example 2: 输入：nums = [1] 输出：1 example 3: 输入：nums = [5,4,-1,7,8] 输出：23 题目来源：https://leetcode.cn/problems/maximum-subarray/ 题解：class Solution { public int maxSubArray(int[] nums) { /* 贪心算法：从左到右跌倒，一个一个遍历，遇到sum&lt;0,则重置sum，，return记录每次出现的sum的值的最大值。 */ //return的初始大小为整型数据的最小值，为了和sum进行比较时可以接受任意小的sum int result=Integer.MIN_VALUE; int sum=0; for(int i=0;i&lt;nums.length;i++){ //加上当前的被遍历的元素 sum+=nums[i]; //和result维护的之前sum的最大值进行比较，更新sum最大值 result=Math.max(result,sum); //若当前和小于0，则重置sum的值为0，重新开始找子序列 if(sum&lt;0){ sum=0; } } return result; } }","link":"/post/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C.html"},{"title":"有序数组的单一元素","text":"540. 有序数组的单一元素题目描述： 给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。 请你找出并返回只出现一次的那个数。 你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。 example 1： 输入: nums = [1,1,2,3,3,4,4,8,8] 输出: 2 example 2: 输入: nums = [3,3,7,7,10,11,11] 输出: 10 题目来源：https://leetcode.cn/problems/single-element-in-a-sorted-array 题解：class Solution { public int singleNonDuplicate(int[] nums) { if(nums.length==1){ return nums[0]; } int left=0; int right=nums.length-1; int result=0; while(right&gt;left){ int mid=(right-left)/2+left; //若mid为偶数，则判断mid与mid+1是否相等，若mid为奇数，则判断mid和mid-1是否相等 if(nums[mid]==nums[mid^1]){ //若相等则表示单个数字x位于右边 //并且因为相等，所以mid所指向的数字一定不是单个数字x left=mid+1; }else{ //若不相等，则表示单个数字x位于左边，并且因为不相等，所以当前mid所指向的数字可能就是我们要找的单个数字x,不能直接提剔除 right=mid; } } //直接返回right return nums[right]; } }","link":"/post/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0.html"},{"title":"根据身高重建队列","text":"406.根据身高重建队列题目描述：假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 example 1: 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 解释： 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 example 2: 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 题目来源：https://leetcode.cn/problems/queue-reconstruction-by-height/ 题解class Solution { public int[][] reconstructQueue(int[][] people) { /* 第一个元素进行降序排序，即元素越小，排的越靠后， 对于第一个元素相同的数组，针对第二个元素进行升序排序，即越小越靠前，之所以这样排序，是因为，最后是按照第二个元素 进行插入的，也就是说，被插入的时间比较早的元素比较容易被挤到后面，也是因为这个原因，第一个元素是降序，越小的插入的时间越迟，越大的越有可能后移，这样是不会出错的。 同理第二个元素，越大的越靠后，因为后面元素的插入不会影响前面的元素，而前面元素的插入是会影响后面的，所以先插小，后插大 */ //对第一个元素进行降序排序，在第一个元素相同时对第二个元素进行降序 Arrays.sort(people,(m,n)-&gt;{ //第一个元素不相等时，使用降序 if(m[0]!=n[0]){ return n[0]-m[0]; //第一个元素相等时，使用升序 }else{ return m[1]-n[1]; } }); //创建返回值 List&lt;int[]&gt; list=new ArrayList&lt;&gt;(); //将排序后的数组插入到返回值中 for(int[] person:people){ //若返回值列表大小大于要插入位置，则直接插入 if(list.size()&gt; person[1]){ list.add(person[1],person); }else{ //若返回值列表大小小于要插入位置，则将person插入列表末尾位置 list.add(list.size(),person); } } //将列表转化为二维数组进行返回 return list.toArray(new int[list.size()][]); } }","link":"/post/%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html"},{"title":"种花问题","text":"605.种花问题题目描述：假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。 example 1: 输入：flowerbed = [1,0,0,0,1], n = 1 输出：true example 2: 输入：flowerbed = [1,0,0,0,1], n = 2 输出：false 题目来源：https://leetcode.cn/problems/can-place-flowers/ 题解：class Solution { public boolean canPlaceFlowers(int[] flowerbed, int n) { if(flowerbed.length==0){ return false; } for(int i=0;i&lt;flowerbed.length;i++){ //遇到的情况 //1.当前元素为0，并且后续也为0，则插入花，并减少剩余数量，i++，向后跳两格 //2.当前元素为0，且为最后一个元素，则插入花，向后跳两格子 //3.当前元素为1，则继续向后跳两格，因为后一个位子必定没法插入 //4.若当前元素为0，后续为1，则跳一格，进入第三种情况 //每次只需要判断当前元素和后一个元素，无需考虑前一个元素，并且从第一个元素开始判断 if(flowerbed[i]==0&amp;&amp;(i+1==flowerbed.length||flowerbed[i+1]==0)){ i++; n--; }else if(flowerbed[i]==1){ i++; } } return n&lt;=0? true:false; } }","link":"/post/%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98.html"},{"title":"第一个错误版本","text":"278.第一个错误版本题目描述：278. 第一个错误的版本你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 example 1: 输入：n = 5, bad = 4 输出：4 解释： 调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true 所以，4 是第一个错误的版本。 example 2: 输入：n = 1, bad = 1 输出：1 题目来源：https://leetcode.cn/problems/first-bad-version/ 题解： //左闭右闭区间，循环结束时left&gt;right，则此时最后一次得到的mid（即最后一次查找到的版本是没有保存的，所以需要ret变量进行保存） /* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */ public class Solution extends VersionControl { public int firstBadVersion(int n) { int left=0; int right=n; int ret=-1; while(left&lt;=right){ int mid=left+(right-left)/2; //当前版本如果是错误版本，则当前版本可能是第一个出现错误的版本，需要暂存 if(isBadVersion(mid)){ ret=mid; right=mid-1; }else{ left=mid+1; } } return ret; } } /* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */ public class Solution extends VersionControl { public int firstBadVersion(int n) { int left=0; int right=n; int ret=-1; //循环的结束条件是left=right，并且right=最后一个mid，所以返回值也是最后一个mid=right=left while(left&lt;right){ int mid=left+(right-left)/2; //左闭右开区间，循环结束条件是left&lt;right,下一轮循环是从left~right-1，右边是开区间 if(isBadVersion(mid)){ // ret=mid; right=mid; }else{ left=mid+1; } } return right; } }","link":"/post/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC.html"},{"title":"ERROR 2003 (HY000) Can't connect to MySQL server on 'localhost:3306' (10061)","text":"ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost:3306’ (10061)问题描述：mysql -uroot -p 输入上传命令之后，出现标题上的错误。 数据库无法成功连接 解决方案： 打开win搜索栏，输入“计算机管理” 选择服务 找到mysql，并启动即可","link":"/post/%E8%BF%9E%E6%8E%A5mysql%E5%A4%B1%E8%B4%A5.html"},{"title":"非递减数列","text":"非递减数列题目描述：665. 非递减数列难度中等681收藏分享切换为英文接收动态反馈 给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1] example 1: 输入: nums = [4,2,3] 输出: true 解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。 example 2: 输入: nums = [4,2,1] 输出: false 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 题目来源：https://leetcode.cn/problems/non-decreasing-array/ 题解：class Solution { public boolean checkPossibility(int[] nums) { /** 贪心算法：三种逆序情况 1.当i=1时，与前一个元素发生逆序，则改变前一个元素的值，【4，2，5】，当遍历至2时发生逆序，将4改为2； 2.当i&gt;1,并且与i-1元素发生逆序时，需要查看i-2位置的元素，若i-2位置小于或者等于i位置元素，则依旧改变i-2位置元素，eg【1, 4, 2, 5】遍历至2时发生逆序，由于1&lt;2依旧是有序的，只需要改变4即可，将4改为2； 3.当i&gt;1,并且与i-1元素发生逆序时，需要查看i-2位置的元素，若i-2位置大于i位置元素，则此时仅改变i-1位置的元素依旧是无法实现递增的，此时只能将i位置的元素修改为i-1位置的元素。eg【3, 4, 2, 5】，此时2与4发生逆序，若仅仅修改4的值是无法实现递增的，因为3依旧是大于2的，所以只能将2修改为4实现递增。 总结： 当 nums[i] 破坏了数组的单调递增时，即 nums[i] &lt; nums[i - 1] 时，为了让数组有序，我们发现一个规律（在上面三个例子中， nums[i] 都为 2， nums[i -1] 都为 4）： 如例①的情况，当 i = 1 ，那么修改 num[i- 1] ，不要动 nums[i] ，因为nums[i]后面的元素是啥我们还不知道呢，少动它为妙。 如例②的情况，当 i &gt; 1 时，我们应该优先考虑把 nums[i - 1] 调小到 &gt;= nums[i - 2] 并且 &lt;= nums[i]。同样尽量不去修改 nums[i] ，理由同上。 如例③的情况，当 i &gt; 1 且 nums[i] &lt; nums[i - 2] 时，我们无法调整 nums[i - 1] ，我们只能调整 nums[i] 到 nums[i - 1] 。 */ //用于记录改变元素的数量 int count=0; for(int i=1;i&lt;nums.length;i++){ //发生逆序，即不是递增 if(nums[i]&lt;nums[i-1]){ //当逆序发生在1位置,改变前一个元素的位置 if(i==1){ nums[i-1]=nums[i]; }else if(nums[i]&lt;nums[i-2]){ //i位置元素小于i-2位置，则改变i的值 nums[i]=nums[i-1]; }else if(nums[i]&gt;=nums[i-2]){ //i位置元素大于等于i-2位置，改变i-1位置 nums[i-1]=nums[i]; } if(++count&gt;1){ return false; } } } return true; } } 参考资料：https://leetcode.cn/problems/non-decreasing-array/solution/3-zhang-dong-tu-bang-zhu-ni-li-jie-zhe-d-06gi/","link":"/post/%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97.html"},{"title":"comeback","text":"我又回来了长时间没有写的，都快忘记怎么用了。","link":"/post/comeback.html"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"贪心算法","slug":"贪心算法","link":"/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"栈和队列","slug":"栈和队列","link":"/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"name":"回溯算法","slug":"回溯算法","link":"/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"报错","slug":"报错","link":"/tags/%E6%8A%A5%E9%94%99/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"使用说明","slug":"使用说明","link":"/tags/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"},{"name":"Java并发编程实战","slug":"Java并发编程实战","link":"/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Pycharm","slug":"Pycharm","link":"/tags/Pycharm/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"语法错误","slug":"语法错误","link":"/tags/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF/"},{"name":"记录","slug":"记录","link":"/tags/%E8%AE%B0%E5%BD%95/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"使用方法","slug":"使用方法","link":"/tags/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"科研","slug":"科研","link":"/tags/%E7%A7%91%E7%A0%94/"},{"name":"模块","slug":"模块","link":"/tags/%E6%A8%A1%E5%9D%97/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数据结果与算法","slug":"数据结果与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数据结构和算法","slug":"数据结构和算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"个人博客","slug":"个人博客","link":"/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"阅读笔记","slug":"阅读笔记","link":"/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"实验","slug":"实验","link":"/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"个人","slug":"个人","link":"/categories/%E4%B8%AA%E4%BA%BA/"},{"name":"WEB前端","slug":"WEB前端","link":"/categories/WEB%E5%89%8D%E7%AB%AF/"},{"name":"SDN","slug":"SDN","link":"/categories/SDN/"},{"name":"Web前端","slug":"Web前端","link":"/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"后端开发","slug":"后端开发","link":"/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"个人日志","slug":"个人日志","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"}]}